{"meta":{"title":"MAOoo","subtitle":null,"description":null,"author":"MAOoo","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-01-17T12:48:12.233Z","updated":"2019-01-17T12:48:12.233Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-01-17T12:42:26.595Z","updated":"2019-01-17T12:42:26.595Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello 2019 (TBC)","slug":"Hello 2019 (TBC)","date":"2019-01-17T14:07:58.065Z","updated":"2019-01-17T14:31:23.570Z","comments":true,"path":"2019/01/17/Hello 2019 (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Hello 2019 (TBC)/","excerpt":"","text":"Hello 2019 A. Gennady and a Card Game题目大意给$~1~$张匹配扑克牌和$~5~$张手牌，判断是否存在$~1~$张手牌的花色或者数值和匹配牌一样。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str, hand; cin &gt;&gt; str; for (int i = 0; i ^ 5; ++i) &#123; cin &gt;&gt; hand; if (str.front() == hand.front() || str.back() == hand.back()) return cout &lt;&lt; \"YES\" &lt;&lt; endl, 0; &#125; cout &lt;&lt; \"NO\" &lt;&lt; endl;&#125; B. Petr and a Combination Lock题目大意一个$~360^\\circ~$的刻度盘，指针初始在$~0^\\circ~$处。给定每次旋转的度数$~a_1,~a_2,~\\dots,~a_n~$，但是旋转方向不定，判断是否存在一种旋转方式使得最后指针回到$~0^\\circ~$。数据范围$~1\\leq n\\leq15,~1\\leq a\\leq180~$。 题解爆搜即可。时间复杂度为$~O(2^n)~$。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; for (int i = 0; i ^ 1 &lt;&lt; n; ++i) &#123; int sum = 0; for (int j = 0; j ^ n; ++j) sum += i &amp; 1 &lt;&lt; j ? a[j] : 360 - a[j]; if (sum % 360 == 0) return cout &lt;&lt; \"YES\" &lt;&lt; endl, 0; &#125; cout &lt;&lt; \"NO\" &lt;&lt; endl;&#125; C. Yuhao and a Parenthesis题目大意给$~n~$个括号串，问最多多少括号穿有序对连在一起合法，每个串至多使用一次。 题解经典合法括号串问题。合法性考虑前缀和即可。 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;int&gt; cnt1(1 &lt;&lt; 19, 0), cnt2(1 &lt;&lt; 19, 0); int n; cin &gt;&gt; n; int res = 0; while (n--) &#123; string str; cin &gt;&gt; str; int pre = 0; bool flag = true; for (auto ch : str) &#123; ch == '(' ? ++pre : --pre; if (pre &lt; 0) flag = false; &#125; if (flag) &#123; if (pre) ++cnt1[pre]; else ++res; continue; &#125; int suf = -pre; for (auto ch : str) &#123; ch == ')' ? ++pre : --pre; if (pre &gt; 0) break; &#125; if (!pre) ++cnt2[suf]; &#125; res &gt;&gt;= 1; for (int i = 1; i ^ 1 &lt;&lt; 19; ++i) res += min(cnt1[i], cnt2[i]); cout &lt;&lt; res &lt;&lt; endl;&#125; D. Makoto and a Blackboard题目大意定义一种操作，对任何正整数$~x~$，它会等概率随机变为它的一个因子。现给两个数字$~n~$和$~k~$，问$~n~$经过$~k~$次操作后所得到的期望。数据范围$~1\\leq n\\leq10^{15},~1\\leq k\\leq10^4~$。 题解令$~\\xi(x,~y)~$表示$~x~$经过$~y~$次操作对应答案的随机变量，则此题的答案可用$~\\Bbb{E}(\\xi(n,~k))~$。将$~n~$因式分解为$~\\prod_{i=1}^{m}p_i^{\\alpha_i}~$，于是$~\\xi(n,~k)=\\prod_{i=1}^{m}\\xi(p_i^{\\alpha_i},~k)~$，且$~\\xi(p_i^{\\alpha_i},~k)~$之间相互独立。所以答案可以表示为 \\begin{aligned} \\Bbb{E}(\\xi(n,~k)) &=\\Bbb{E}\\left(\\prod_{i=1}^{m}\\xi(p_i^{\\alpha_i},~k)\\right) \\\\ &=\\prod_{i=1}^{m}\\Bbb{E}\\left(\\xi(p_i^{\\alpha_i},~k)\\right) \\\\ \\end{aligned}接下来计算$~\\Bbb{E}\\left(\\eta_k=\\xi(p^\\alpha,~k)\\right)~$。显然$~\\eta~$是个简单随机变量且值域$~\\eta(\\Omega)={1,~p,~\\dots,~p^\\alpha}~$。记$~f(x,~y)=P(\\eta_y=p^x)~$，不难得出$~y=1~$时，有 f(x,~1)=\\frac{1}{\\alpha+1},~0\\leq x\\leq\\alpha那么对于$~y&gt;1~$，有 f(x,~y)=\\sum_{i=x}^{\\alpha}\\frac{f(i,~y-1)}{i+1}直接递推即可。总时间复杂度为$~O(\\sqrt{n}+k\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;const int maxn = 1 &lt;&lt; 14;int inv[maxn], a[64], b[64];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int calc(long long pp, int n, int k) &#123; int p = pp % mod; for (int i = 0; i &lt;= n; ++i) a[i] = inv[n + 1]; b[n + 1] = 0; while (--k) &#123; for (int i = n; ~i; --i) b[i] = add(b[i + 1], mul(a[i], inv[i + 1])); memcpy(a, b, (n + 1) * sizeof (int)); &#125; int ret = 0; for (int i = 0, base = 1; i &lt;= n; ++i) &#123; if (i) base = mul(base, p); ret = add(ret, mul(a[i], base)); &#125; return ret;&#125;int main() &#123; inv[0] = inv[1] = 1; for (int i = 2; i ^ maxn; ++i) inv[i] = mul(inv[mod % i], mod - mod / i); long long n; int k; cin &gt;&gt; n &gt;&gt; k; vector&lt;pair&lt;long long, int&gt;&gt; factors; for (long long p = 2; p * p &lt;= n; ++p) if (n % p == 0) &#123; int cnt = 0; while (n % p == 0) n /= p, ++cnt; factors.push_back(make_pair(p, cnt)); &#125; if (n ^ 1) factors.push_back(make_pair(n, 1)); int res = 1; for (auto factor : factors) res = mul(res, calc(factor.first, factor.second, k)); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; E. Egor and an RPG game题目大意对于一个全排列$~a_1,~a_2,~\\dots,~a_n~$，将其划分为若干个单调子序列，记最少的数量为$~k~$。对于所有长度为$~n~$的全排列，所对应的$~k~$的最大值记为$~f(n)~$。现给出一个全排列$~a_1,~a_2,~\\dots,~a_n~$，输出一种不超过$~f(n)~$的单调子序列划分方式。数据范围$~1\\leq n\\leq10^5~$。 题解考虑全排列$~1,~3,~2,~6,~5,~4,~10,~9,~8,~7~$，显然它至少要划分为$~4~$个单调子序列。所以对于$~\\frac{k(k+1)}{2}\\leq n~$，必有$~f(n)\\geq k~$。那么对于$~\\frac{k(k+1)}{2}&gt;n~$，下面证明存在$~k-1~$个单调子序列划分。考虑当前序列的任意一个$~\\text{LIS}~$，如果$~{\\mid\\text{LIS}\\mid}\\geq k~$，那么将其划分，对于剩余的部分，此时有$~\\frac{k(k-1)}{2}&gt;n-{\\mid\\text{LIS}\\mid}~$，可以数学归纳。如果$~{\\mid\\text{LIS}\\mid}&lt; k~$，那么根据$~\\text{dilworth}~$定理，可以将序列划分为$~\\mid\\text{LIS}\\mid~$个$~\\text{LDS}~$。这样总时间复杂度为$~O(n\\sqrt n\\log n)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;int&gt; lim; for (int i = 0; i ^ 500; ++i) for (int j = i; ~j; --j) lim.push_back(i); int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; now(n), tmp, to(n + 1); vector&lt;bool&gt; flag(n + 1, true); vector&lt;vector&lt;int&gt;&gt; res; for (auto&amp; in : now) cin &gt;&gt; in; while (!now.empty()) &#123; vector&lt;int&gt; lis; vector&lt;vector&lt;int&gt;&gt; rem; for (auto a : now) &#123; int idx = lower_bound(lis.begin(), lis.end(), a) - lis.begin(); if (idx) to[a] = lis[idx - 1]; else to[a] = a; if (idx == lis.size()) &#123; lis.push_back(a); rem.push_back(vector&lt;int&gt;(1, a)); &#125; else &#123; lis[idx] = a; rem[idx].push_back(a); &#125; &#125; if (lis.size() &gt; lim[now.size()]) &#123; for (int i = lis.size() - 2; ~i; --i) lis[i] = to[lis[i + 1]]; res.push_back(lis); for (auto a : lis) flag[a] = false; tmp.clear(); for (auto a : now) if (flag[a]) tmp.push_back(a); swap(now, tmp); &#125; else &#123; for (auto ans : rem) res.push_back(ans); now.clear(); &#125; &#125; cout &lt;&lt; res.size() &lt;&lt; endl; for (auto arr : res) &#123; cout &lt;&lt; arr.size(); for (auto a : arr) cout &lt;&lt; ' ' &lt;&lt; a; cout &lt;&lt; endl; &#125; &#125;&#125; F. Alex and a TV Show题目大意初始有$~n~$个空的可重集合$~S_1,~S_2,~\\dots,~S_n~$。接下有$~q~$次操作或询问： 把$~S_x~$变为$~{v}~$。 把$~S_x~$变为$~S_y\\bigcup S_z~$。 把$~S_x~$变为$~{\\gcd(a,~b)\\mid a\\in S_y,~b\\in S_z}~$。 输出$~S_x~$中$~v~$的数量模$~2~$。 数据范围$~1\\leq n\\leq10^5,~1\\leq q\\leq10^6,~1\\leq v\\leq7000~$。 题解先考虑这样的计数矩阵$~A_{n\\times7000}~$，其中$~a_{xv}~$表示$~S_x~$中$~v~$的数量。那么会发现操作$~3~$的复杂度为$~O(q^2)~$。于是考虑因子矩阵$~B_{n\\times7000}~$，其中$~b_{xv}~$表示$~S_x~$中$~v~$的倍数的数量。关于$~B~$能否唯一的表示$~A~$，只要存在可逆矩阵$~T~$，使得$~B=AT~$即可。令 t_{ij}=\\begin{cases} 1 &\\text{$j\\mid i$} \\\\ 0 &\\text{$j\\nmid i$} \\\\ \\end{cases}则$~B=AT~$成立（根据$~B~$的定义），且$~T~$是主对角线全为$~1~$的下三角矩阵，必定可逆，于是$~B~$所对应的集族的唯一性得到了保证。事实上$~T^{-1}~$是莫比乌斯函数矩阵 t_{ij}^{-1}=\\begin{cases} \\mu(ij^{-1}) &\\text{$j\\mid i$} \\\\ 0 &\\text{$j\\nmid i$} \\\\ \\end{cases}$~T^{-1}~$的构造过程可以利用容斥的思想，那么$~\\mu~$则时容斥系数。于是操作$~1~$等价于$~b_{x\\small\\bullet}=t_{v\\small\\bullet}~$，操作$~2~$等价于$~b_{x\\small\\bullet}=b_{y\\small\\bullet}+b_{z\\small\\bullet}~$，操作$~3~$等价于$~b_{x\\small\\bullet}=b_{y\\small\\bullet}\\times b_{z\\small\\bullet}~$，询问$~4~$等价于计算$~b_{x\\small\\bullet}\\cdot t_{v\\small\\bullet}^{-1}~$。注意到$~v~$的数据范围以及答案模$~2~$的要求，可以用$~\\text{bitset}~$来模拟集合对应的因子矩阵。总时间复杂度为$~O(v\\log v+\\frac{qv}{\\text{bitset}})~$，注意可能需要$~\\text{fastIO}~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); const int maxn = 1e5 + 5; const int maxv = 7e3 + 5; vector&lt;int&gt; prime, mu(maxv, 0); vector&lt;bool&gt; vis(maxv, false); mu[1] = 1; for (int i = 2; i ^ maxv; ++i) &#123; if (!vis[i]) &#123; prime.push_back(i); mu[i] = -1; &#125; for (auto p : prime) &#123; if (i * p &gt;= maxv) break; vis[i * p] = true; if (i % p) mu[i * p] = -mu[i]; else break; &#125; &#125; vector&lt;bitset&lt;maxv&gt;&gt; factor(maxv), inv(maxv), set(maxn); for (int i = 1; i ^ maxv; ++i) for (int j = i; j &lt; maxv; j += i) &#123; factor[j].flip(i); if (mu[j / i]) inv[i].flip(j); &#125; int n, q; cin &gt;&gt; n &gt;&gt; q; while (q--) &#123; int op, x, y, z, v; cin &gt;&gt; op; if (op == 1) &#123; cin &gt;&gt; x &gt;&gt; v; set[x] = factor[v]; &#125; if (op == 2) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; set[x] = set[y] ^ set[z]; &#125; if (op == 3) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; set[x] = set[y] &amp; set[z]; &#125; if (op == 4) &#123; cin &gt;&gt; x &gt;&gt; v; cout &lt;&lt; ((set[x] &amp; inv[v]).count() &amp; 1 ? '1' : '0'); &#125; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Educational Codeforces Round 58 (Rated for Div. 2)","slug":"Educational Codeforces Round 58 (Rated for Div. 2)","date":"2019-01-17T14:07:58.054Z","updated":"2019-01-17T14:16:45.369Z","comments":true,"path":"2019/01/17/Educational Codeforces Round 58 (Rated for Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Educational Codeforces Round 58 (Rated for Div. 2)/","excerpt":"","text":"Educational Codeforces Round 58 (Rated for Div. 2) A. Minimum Integer题目大意输出不在$~[l,~r]~$内的$~d~$的最小整数倍。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int q; cin &gt;&gt; q; while (q--) &#123; long long l, r, d; cin &gt;&gt; l &gt;&gt; r &gt;&gt; d; cout &lt;&lt; ((d &lt; l ? 0 : r / d) + 1) * d &lt;&lt; endl; &#125;&#125; B. Accordion题目大意输出给定字符串满足左边为$~\\text{[:}~$右边为$~\\text{:]}~$中间为任意（可以没有）数量的$~\\text{|}~$的子序列最大长度。 题解水题。 代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; int left = -1, right = -1, size = str.size(); bool flag = false; for (int i = 0; i ^ size; ++i) &#123; if (str[i] == '[') flag = true; if (str[i] == ':' &amp;&amp; flag) &#123; left = i; break; &#125; &#125; flag = false; for (int i = size - 1; ~i; --i) &#123; if (str[i] == ']') flag = true; if (str[i] == ':' &amp;&amp; flag) &#123; right = i; break; &#125; &#125; if (!~left || !~ right || left &gt;= right) return cout &lt;&lt; -1 &lt;&lt; endl, 0; int res = 4; for (int i = left + 1; i ^ right; ++i) if (str[i] == '|') ++res; cout &lt;&lt; res &lt;&lt; endl;&#125; C. Division and Union题目大意将$~n~$个给定的闭区间划分到两个集合之中，使得在这两个集合之中分别任选一个闭区间，它们不交。输出任意一种划分或者不存在。 题解首先，如果有合法的划分，当且仅当这两个集合分别并起来得到的两个数集不交。于是合法划分不存在当前仅当所有区间并起来还是一个区间。对所有的区间按左端点升序，先将第$~1~$个区间划分给集合$~1~$，然后按顺序看当前区间与第$~1~$个区间是否有交。如果有交则划分给集合$~1~$同时与第$~1~$个区间并起来。如果没有则后面所有的区间都划分给集合$~2~$，这样所有在集合$~2~$区间里的数都大于在集合$~1~$区间里的数。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; seg(n); for (int i = 0; i ^ n; ++i) &#123; cin &gt;&gt; seg[i].first.first &gt;&gt; seg[i].first.second; seg[i].second = i; &#125; sort(seg.begin(), seg.end()); vector&lt;int&gt; res(n); bool flag = true; for (int i = 0, back = seg.front().first.second; i ^ n; ++i) &#123; if (seg[i].first.first &lt;= back) &#123; back = max(back, seg[i].first.second); res[seg[i].second] = 1; &#125; else &#123; flag = false; for (int j = i; j ^ n; ++j) res[seg[j].second] = 2; cout &lt;&lt; res.front(); for (int j = 1; j ^ n; ++j) cout &lt;&lt; ' ' &lt;&lt; res[j]; cout &lt;&lt; endl; break; &#125; &#125; if (flag) cout &lt;&lt; -1 &lt;&lt; endl; &#125;&#125; D. GCD Counting题目大意给定一颗带点值的树，找出最长的简单路径满足路径上所有点值不互质。数据范围$~1\\leq n\\leq2\\cdot10^5,~1\\leq a\\leq2\\cdot10^5~$。 题解对于最长的合法路径，必存在一个质数$~p~$是路径上所有点值的公因数。注意到点值的数据范围，可以先预处理所有数字的所有质因子，这一步的时间复杂度为$~O(a\\log a)~$。树形$~\\text{DP}~$。任取一个点为根节点，考虑在以节点$~u~$为根的子树上经过$~u~$且有公因数$~p~$的最长路径$~cal[u][p]~$。先计算以$~u~$为一个端点，另一端点在子树中且公因数为$~p~$的最长路径路径$~len[u][p]~$。那么对于$~u~$的所有儿子$~v~$，在$~\\text{dfs}~$过程中用$~len[v][p]~$的最大值更新$~len[u][p]~$，最大值和次大值更新$~cal[u][p]~$。为节省空间，注意到$~a~$的不同质因子个数很少，可以用$~\\text{map}~$来维护$~len~$，且不用记录$~cal~$直接更新答案即可。总时间复杂度为$~O(a\\cdot\\log a+n\\cdot\\log a\\cdot\\log\\log a)~$。事实上可以写成$~O((n+a)\\log a)~$，但是没有必要。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;int a[maxn], res, max1[maxn], max2[maxn];vector&lt;int&gt; adj[maxn], prime[maxn];vector&lt;bool&gt; vis(maxn);map&lt;int, int&gt; len[maxn];void dfs(int u, int pa) &#123; for (auto v : adj[u]) if (v ^ pa) dfs(v, u); for (auto p : prime[a[u]]) max1[p] = max2[p] = 0; for (auto v : adj[u]) if (v ^ pa) for (auto p : prime[a[u]]) &#123; max2[p] = max(max2[p], len[v][p]); if (max1[p] &lt; max2[p]) swap(max1[p], max2[p]); &#125; if (a[u] == 1) return; int cal = 0; for (auto p : prime[a[u]]) &#123; cal = max(cal, max1[p] + max2[p]); len[u][p] = max1[p] + 1; &#125; res = max(res, ++cal);&#125;int main() &#123; for (int i = 2; i ^ maxn; ++i) if (!vis[i]) for (int j = i; j &lt; maxn; j += i) &#123; vis[j] = true; prime[j].push_back(i); &#125; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i ^ n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; dfs(1, 0); cout &lt;&lt; res &lt;&lt; endl;&#125; E. Polycarp’s New Job题目大意一共$~n~$次添加或者询问： 加入一个大小为$~x\\times y~$的矩形。 询问是否所有矩形都能被$~h\\times w~$的矩形包含。数据范围$~2\\leq n\\leq5\\cdot10^5,~1\\leq x,~y,~h,~w\\leq10^9~$。 题解首先离散化。注意到矩形可以翻转，不妨让$~x\\geq y,~h\\geq w~$。那么题目变成了平面加点和询问平面内所有点是否都在$~[0,~h]\\times[0,~w]~$或$~[0,~w]\\times[0,~h]~$内。空间范围显然不允许使用二维树状数组，但是可以将询问等价为所有点都在$~[0,~h]\\times[0,~h]~$内且不在$~(w,~\\infty)\\times(w,~\\infty)~$内。那么用两个一维树状数组维护即可。总时间复杂度$~O(n\\log n)~$。数据范围过大，注意$~\\text{IO}~$速度。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; struct Query &#123; char op; int x, y; &#125;; vector&lt;Query&gt; query(n); set&lt;int&gt; num; for (auto&amp; qry : query) &#123; cin &gt;&gt; qry.op &gt;&gt; qry.x &gt;&gt; qry.y; if (qry.x &lt; qry.y) swap(qry.x, qry.y); num.insert(qry.x); num.insert(qry.y); &#125; map&lt;int, int&gt; to; int maxn = 1; for (auto x : num) to[x] = maxn++; vector&lt;int&gt; bit1(maxn, 0), bit2(maxn, 0); #define lowbit(x) (x &amp; -x) int cnt = 0; for (auto qry : query) &#123; qry.x = to[qry.x]; qry.y = to[qry.y]; if (qry.op == '+') &#123; ++cnt; for (int i = qry.x; i &lt; maxn; i += lowbit(i)) ++bit1[i]; for (int i = qry.y; i; i -= lowbit(i)) ++bit2[i]; &#125; else &#123; int sum = 0; for (int i = qry.x; i; i -= lowbit(i)) sum += bit1[i]; for (int i = qry.y + 1; i &lt; maxn; i += lowbit(i)) sum -= bit2[i]; if (sum == cnt) cout &lt;&lt; \"YES\\n\"; else cout &lt;&lt; \"NO\\n\"; &#125; &#125;&#125; F. Trucks and Cities题目大意坐标轴上有$~n~$个城市和$~m~$趟卡车。给定城市坐标$~a~$，卡车的起点$~s~$、终点$~f~$、每公里耗油$~c~$和可中途加油次数$~r~$。问油箱的最小容量。 题解动态规划。记$~dp[r][s][f]~$为最优策略下卡车从$~a_s~$到$~a_f~$最多停靠加油$~r~$次的最长的两次停靠城市距离。那么答案则是$~\\max(dp[r][s][f]\\cdot c)~$。通过枚举最后一次停靠城市$~a_l~$，有状态转移式 dp[r][s][f]=\\min_{s< t< f}\\max(dp[r-1][s][t],~a[f]-a[t])此时总时间复杂度为$~O(n^4)~$显然会$~\\text{tle}~$。但是不难发现在固定$~r~$和$~s~$后，最优转移点$~t~$随着$~f~$递增，所以双指针优化后时间复杂度变为$~O(n^3)~$。但是直接开$~O(n^3)~$的三位数组空间复杂度很危险（擦着边其实可以过），那么对于所有的输入$~(s,~f,~c,~r)~$离线操作，按$~r~$升序，这样$~dp~$的$~r~$维度可以滚动数组实现。总时间复杂度为$~O(n^3+m\\log m)~$，空间复杂度为$~O(n^2+m)~$。 代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; vector&lt;vector&lt;int&gt;&gt; dp0(n + 1, vector&lt;int&gt;(n + 1)); vector&lt;vector&lt;int&gt;&gt; dp1(n + 1, vector&lt;int&gt;(n + 1)); for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; ++j) dp0[i][j] = a[j] - a[i]; struct Query &#123;int s, f, c, r;&#125;; vector&lt;Query&gt; query(m); for (auto&amp; qry : query) cin &gt;&gt; qry.s &gt;&gt; qry.f &gt;&gt; qry.c &gt;&gt; qry.r; sort(query.begin(), query.end(), [](Query a, Query b) &#123;return a.r &lt; b.r;&#125;); long long res = 0; int now = 0; for (auto qry : query) &#123; while (now ^ qry.r) &#123; for (int j = 1; j &lt;= n; ++j) for (int k = j, l = j; k &lt;= n; ++k) &#123; while (l &lt; k &amp;&amp; max(dp0[j][l], a[k] - a[l]) &gt; max(dp0[j][l + 1], a[k] - a[l + 1])) ++l; dp1[j][k] = max(dp0[j][l], a[k] - a[l]); &#125; swap(dp0, dp1); ++now; &#125; res = max(res, 1LL * qry.c * dp0[qry.s][qry.f]); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; G. (Zero XOR Subset)-less题目大意给定数列$~a_1,~a_2,~\\dots,~a_n~$，要划分为若干个连续子序列$~A_1,~A_2,~\\dots,~A_k~$。令每个子序列的$~\\text{xor}~$和记为$~\\alpha_i,~i=1,~2,~\\dots,~k~$，集合$~S={\\alpha_1,~\\alpha_2,~\\dots,~\\alpha_k}~$。问满足$~S~$的所有非空子集的$~\\text{xor}~$和互不相同的最大$~k~$或不存在。数据范围$~1\\leq n\\leq2\\cdot10^5,~0\\leq a\\leq10^9~$。 题解记录$~a_1,~a_2,~\\dots,~a_n~$的前缀$~\\text{xor}~$和$~pre_1,~pre_2,~\\dots,~pre_n~$，显然如果$~pre_n=0~$则答案不存在，反之存在。再考虑合法集合$~S~$，记$~\\alpha_1,~\\alpha_2,~\\dots,~\\alpha_k~$的前缀$~\\text{xor}~$和为$~\\beta_1,~\\beta_2,~\\dots,~\\beta_k~$，则不难发现$~\\bar{S}={\\beta_1,~\\beta_2,~\\dots,~\\beta_k}~$也是合法集合。且根据定义$~\\beta~$也是$~a~$的前缀$~\\text{xor}~$和，所以$~\\bar{S}\\subseteq{pre_1,~pre_2,~\\dots,~pre_n}~$。对于所有正整数，考虑二进制表示的$~01~$向量，可以等价于$~\\Bbb{Z}_2~$上的某向量空间的向量，合法集合可以看作是这个向量空间上的一个线性无关组。这是一个线性基问题，答案是包含$~pre~$的最小空间的维数。时间复杂度为$~O(n\\log a)~$。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), base; cin &gt;&gt; a.front(); for (int i = 1; i ^ n; ++i) cin &gt;&gt; a[i], a[i] ^= a[i - 1]; if (!a.back()) return cout &lt;&lt; -1 &lt;&lt; endl, 0; for (auto e : a) &#123; for (auto v : base) e = min(e, e ^ v); if (e) base.push_back(e); &#125; cout &lt;&lt; base.size() &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Educational Codeforces Round 57 (Rated for Div. 2)","slug":"Educational Codeforces Round 57 (Rated for Div. 2)","date":"2019-01-17T14:07:58.047Z","updated":"2019-01-17T14:09:23.552Z","comments":true,"path":"2019/01/17/Educational Codeforces Round 57 (Rated for Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Educational Codeforces Round 57 (Rated for Div. 2)/","excerpt":"","text":"Educational Codeforces Round 57 (Rated for Div. 2) A. Find Divisible题目大意输出任意一组$~(x,~y)\\in [l,~r]^2~$满足$~x~$整除$~y~$，保证有解。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; l * 2 &lt;&lt; endl; &#125;&#125; B. Substring Removal题目大意给定一个小写字母串，询问有多少子串那满足删去子串后剩余部分仅有$~1~$种字母，保证输入串至少含$~2~$种字母。 题解显然剩余的串必须为单字母构成前缀或后缀，或者字母一样的前后缀。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const int mod = 998244353; int n; string str; cin &gt;&gt; n &gt;&gt; str; int l, r; for (l = 0; l ^ n &amp;&amp; str[l] == str.front(); ++l); for (r = n - 1; ~r &amp;&amp; str[r] == str.back(); --r); if (str.front() == str.back()) cout &lt;&lt; (long long)(l + 1) * (n - r) % mod &lt;&lt; endl; else cout &lt;&lt; l + n - r &lt;&lt; endl;&#125; C. Polygon for the Angle题目大意给一个在$~1^\\circ~$到$~179^\\circ~$之间的整数度数，输出最小的$~n~$满足正$~n~$边形上可以取$~3~$个点构成这个角度。 题解不难得出正$~n~$边形可以得到的角度为$~\\frac{1}{n}\\times180^\\circ,~\\frac{2}{n}\\times180^\\circ,~\\dots,~\\frac{n-2}{n}\\times180^\\circ~$这一结论。考虑分数$~\\frac{ang}{180}~$的最简形式$~\\frac{p}{q}~$，答案即为$~q~$或者$~2q~$（如果$~p=q-1~$）。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int ang; cin &gt;&gt; ang; int gcd = __gcd(ang, 180); cout &lt;&lt; (gcd + ang ^ 180 ? 180 : 360) / gcd &lt;&lt; endl; &#125;&#125; D. Easy Problem题目大意给一个字符串以及删除每个字符的花费$~a_i~$，输出使得字符串不包含$~\\text{hard}~$这一子序列的最小删除花费。 题解动态规划。记$~dp[i][j]~$表示考虑到第$~i~$位，已经构成了$~\\text{hard}~$前$~j~$个字符的最小花费。从左至右模拟即可，时间复杂度为$~O(n)~$。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; string str; cin &gt;&gt; n &gt;&gt; str; vector&lt;long long&gt; a(n); for (auto&amp; arr : a) cin &gt;&gt; arr; vector&lt;vector&lt;long long&gt;&gt; dp(n + 1, vector&lt;long long&gt;(4)); dp[0][0] = 0; dp[0][1] = dp[0][2] = dp[0][3] = 0x3f3f3f3f; for (int i = 1; i &lt;= n; ++i) &#123; dp[i][0] = dp[i - 1][0]; dp[i][1] = dp[i - 1][1]; dp[i][2] = dp[i - 1][2]; dp[i][3] = dp[i - 1][3]; if (str[i - 1] == 'h') &#123; dp[i][0] += a[i - 1]; dp[i][1] = min(dp[i][1], dp[i - 1][0]); &#125; if (str[i - 1] == 'a') &#123; dp[i][1] += a[i - 1]; dp[i][2] = min(dp[i][2], dp[i - 1][1]); &#125; if (str[i - 1] == 'r') &#123; dp[i][2] += a[i - 1]; dp[i][3] = min(dp[i][3], dp[i - 1][2]); &#125; if (str[i - 1] == 'd') &#123; dp[i][3] = dp[i][3] + a[i - 1]; &#125; &#125; cout &lt;&lt; min(min(dp[n][0], dp[n][1]), min(dp[n][2], dp[n][3])) &lt;&lt; endl;&#125; E. The Top Scorer题目大意有$~p~$个人比赛，每人都有未知的非负得分$~a_i~$，但总和$~\\sum_{i=1}^{p}{a_i}=s~$已知。分数最高的一人获胜，如果最高分有多人同分，则他们的获胜概率均等。现已知$~\\text{Hason}~$的分数至少为$~r~$，所有不同的结果出现的概率均等，求他获胜的概率。数据范围$~1\\leq p\\leq 100,~0\\leq r\\leq s\\leq5000~$。 题解先将$~\\text{Hason}~$的分数和总分数减去$~r~$，那么插板法可以算出所有合法的结果数量为 \\binom{p+s-r-1}{p-1}接下来枚举$~\\text{Hason}~$的得分$~i=r,~r+1,~\\dots,~s~$，有$~j=1,~2,~\\dots,~\\lfloor \\frac{s}{i}\\rfloor~$人与他同分（算上$~\\text{Hason}~$他自己），且其余的得分均小于$~i~$的情况。此时$~\\text{Hason}~$获胜的结果数量期望为 \\frac{1}{j}\\binom{p-1}{p-j}f(p-j,~i,~s-ij)其中$~f(x,~y,~z)~$表示$~x~$人得分均小于$~y~$且总和为$~z~$的合法结果数量。对于$~f(x,~y,~z)~$的计算，先考虑在没有$~y~$的限制下，用插板法可以得到答案为$~g(x,~z)=\\binom{x+z-1}{x-1}~$。那么将条件变为$~x~$人，至少有$~w~$人得分不少于$~y~$，且总和为$~z~$，则它的结果数量等于$~\\binom{x}{w}g(x,~z-wy)~$。于是通过容斥，得到$~f(x,~y,~z)~$的计算式 \\begin{aligned} f(x,~y,~z) &=\\sum_{i=0}^{\\min(x,~\\lfloor\\frac{z}{y}\\rfloor)}{(-1)^i\\binom{x}{i}g(x,~z-iy)} \\\\ &=\\sum_{i=0}^{\\min(x,~\\lfloor\\frac{z}{y}\\rfloor)}{(-1)^i\\binom{x}{i}\\binom{x+z-iy-1}{x-1}} \\\\ \\end{aligned}注意特判$~f(x=0,~y,~z)~$的情况。总时间复杂度为$~O(p^2s)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 6e3;int inv[maxn], fact[maxn], finv[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int bino(const int&amp; a, const int&amp; b) &#123;return mul(mul(fact[a], finv[b]), finv[a - b]);&#125;inline int binv(const int&amp; a, const int&amp; b) &#123;return mul(mul(finv[a], fact[b]), fact[a - b]);&#125;inline int calc(const int&amp; n, const int&amp; up, const int&amp; s) &#123; if (!n) return s == 0; int ret = 0; for (int i = 0; i &lt;= n &amp;&amp; i * up &lt;= s; ++i) &#123; int temp = mul(bino(n + s - i * up - 1, n - 1), bino(n, i)); ret = i &amp; 1 ? sub(ret, temp) : add(ret, temp); &#125; return ret;&#125;int main() &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125; int p, s, r; cin &gt;&gt; p &gt;&gt; s &gt;&gt; r; int cnt = 0; for (int i = r; i &lt;= s; ++i) for (int j = 1; j &lt;= p &amp;&amp; i * j &lt;= s; ++j) cnt = add(cnt, mul(mul(calc(p - j, i, s - i * j), inv[j]), bino(p - 1, j - 1))); cout &lt;&lt; mul(cnt, binv(p - r + s - 1, p - 1)) &lt;&lt; endl;&#125; F. Inversion Expectation题目大意给一个不完整的全排列，输出逆序对期望数。数据范围$~1\\leq n\\leq 2\\cdot10^5~$。 题解记总共有$~m~$个未知数，分为$~4~$种情况讨论： 所有已知数与已知数对于逆序对的贡献。即为计算一个序列的逆序对数量，用排序或者树状数组均可实现，时间复杂度为$~O(n\\log n)~$。 所有未知数与未知数对于逆序对的贡献。对于任意一种可能的未知数的排列，将其翻转后原来的逆序对变为顺序对，顺序对变为逆序对。于是任意一对未出现的数字，在所有可能的排列情况种它们一半为顺序对，一半为逆序对。所以$~m~$个未知数相互之间对于逆序对的贡献期望为$~\\binom{m}{2}\\frac{m!}{2}~$。 所有已知数与未知数对于逆序对的贡献。先单独考虑一个已知数$~p_i~$与它左边比它大的未知数对于逆序对的贡献。设它左边有$~left_i~$个未知数，所有未知数种有$~lgreater_{p_i}~$个比$~p_i~$大，那么逆序对的期望则是$~left_i\\cdot lgreater_{p_i}\\cdot m^{-1}~$。同理对于$~p_i~$与它右边比它小的未知数对于逆序对期望则是$~right_j\\cdot rsmaller_{p_j}\\cdot m^{-1}~$。这些都可以在线性时间里处理完。总时间复杂度为$~(n\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 2e5 + 5;int inv[maxn], a[maxn], exist[maxn], blank[maxn], bit[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;#define lowbit(x) (x &amp; -x)int main() &#123; inv[1] = 1; for (int i = 2; i ^ maxn; ++i) inv[i] = mul(inv[mod % i], mod - mod / i); int n; cin &gt;&gt; n; int cnt = 0, res = 0; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; if (~a[i]) &#123; blank[i] = blank[i - 1]; exist[a[i]] = 1; res = add(res, i - cnt - 1); for (int j = a[i]; j; j -= lowbit(j)) res = sub(res, bit[j]); for (int j = a[i]; j &lt; maxn; j += lowbit(j)) ++bit[j]; &#125; else &#123; blank[i] = ++cnt; &#125; &#125; for (int i = 1; i &lt;= n; ++i) exist[i] += exist[i - 1]; res = add(res, mul(mul(cnt, cnt - 1), inv[4])); for (int i = 1; i &lt;= n; ++i) if (~a[i]) res = add(res, mul(add(mul(blank[i], cnt + exist[a[i]] - a[i]), mul(cnt - blank[i], a[i] - exist[a[i]])), inv[cnt])); cout &lt;&lt; res &lt;&lt; endl;&#125; G. Lucky Tickets题目大意问有多少个可以首零的$~n~$（偶数）位数字满足前一半的各位数数字之和与后一半的各位数数字之和一样。限定这个数只能由$~d_1,~d_2,~\\dots,~d_k~$组成。数据范围$~2\\leq n\\leq2\\cdot10^5,~1\\leq k\\leq10~$。 题解考虑所有前$~\\frac{n}{2}~$位数加起来可以得到的总和$~s~$，令$~calc(s)~$为所有满足各位数数字之和位$~s~$的合法的$~\\frac{n}{2}~$位数的数量，则答案为$~\\sum_{s=0}^{5n}calc^2(s)~$。考虑这样一个多项式 f(x)=\\sum_{i=1}^{k}x^{d_i}则$~calc(s)~$即为$~f^\\frac{n}{2}(x)~$的$~s~$次系数。于是$~\\text{NTT}~$即可得出答案。时间复杂度$~O(n\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int root = 3;const int maxn = 1 &lt;&lt; 20;int f[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;#define lowbit(x) (x &amp; -x)inline int fpow(int a, int n) &#123; if (n &lt; 0) n = (2LL - mod) * n % (mod - 1); int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;inline void to_pow2(int&amp; x) &#123;while (x ^ lowbit(x)) x += lowbit(x);&#125;inline void bit_reverse(int f[], int size) &#123; for (int i = 1, j = size &gt;&gt; 1; i ^ size - 1; ++i) &#123; if (i &lt; j) swap(f[i], f[j]); int k = size &gt;&gt; 1; while (j &gt;= k) &#123; j -= k; k &gt;&gt;= 1; &#125; if (j &lt; k) j += k; &#125;&#125;inline void ntt(int f[], int size, int op = 1) &#123; bit_reverse(f, size); for (int i = 2; i &lt;= size; i &lt;&lt;= 1) &#123; int wn = fpow(root, op * (1 - mod) / i); for (int j = 0; j ^ size; j += i) &#123; int w = 1; for (int k = j; k ^ j + (i &gt;&gt; 1); ++k) &#123; int u = f[k]; int v = mul(w, f[k + (i &gt;&gt; 1)]); f[k] = add(u, v); f[k + (i &gt;&gt; 1)] = sub(u, v); w = mul(w, wn); &#125; &#125; &#125; if (!~op) &#123; int inv = fpow(size, -1); for (int i = 0; i ^ size; ++i) f[i] = mul(f[i], inv); &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; while (k--) &#123; int d; cin &gt;&gt; d; f[d] = 1; &#125; int size = n * 5; to_pow2(size); ntt(f, size); for (int i = 0; i ^ size; ++i) f[i] = fpow(f[i], n &gt;&gt; 1); ntt(f, size, -1); int res = 0; for (int i = 0; i ^ size; ++i) res = add(res, mul(f[i], f[i])); cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Educational Codeforces Round 56 (Rated for Div. 2)","slug":"Educational Codeforces Round 56 (Rated for Div. 2)","date":"2019-01-17T14:07:58.042Z","updated":"2019-01-17T14:09:21.495Z","comments":true,"path":"2019/01/17/Educational Codeforces Round 56 (Rated for Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Educational Codeforces Round 56 (Rated for Div. 2)/","excerpt":"","text":"Educational Codeforces Round 56 (Rated for Div. 2) A. Dice Rolling题目大意一个点数为$~2~$至$~7~$的骰子，求任意一种可能的次数使得点数之和为$~x~$。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int x; cin &gt;&gt; x; cout &lt;&lt; (x &gt;&gt; 1) &lt;&lt; endl; &#125;&#125; B. Letters Rearranging题目大意给一个小写字母串，输出任意一种不回文重排列。 题解水题。排序即可。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; string str; cin &gt;&gt; str; sort(str.begin(), str.end()); if (str.front() == str.back()) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; str &lt;&lt; endl; &#125;&#125; C. Mishka and the Last Exam题目大意输出一个长度为$~n~$的数列${a_n}$满足对称位之差为给定的数列$~{b_\\frac{n}{2}}~$。 题解水题。从数列边缘向内部贪心，左边尽量小，右边尽量大。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; n &gt;&gt;= 1; vector&lt;long long&gt; left(n), right(n); for (int i = 0; i ^ n; ++i) &#123; long long b; cin &gt;&gt; b; right[i] = b - (left[i] = (i ? max(left[i - 1], b - right[i - 1]) : 0)); &#125; for (auto res : left) cout &lt;&lt; res &lt;&lt; ' '; long long last = right.front(); reverse(right.begin(), right.end()); right.pop_back(); for (auto res : right) cout &lt;&lt; res &lt;&lt; ' '; cout &lt;&lt; last &lt;&lt; endl;&#125; D. Beautiful Graph题目大意给一个简单图（无重边无自环可能不连通），求点的$~{1,~2,~3}~$染色方案数，使得每条边两边加起来是奇数。 题解考虑染色的奇偶性，显然对于每个点，它相邻的点均与它奇偶性不同。所以如果存在奇环，则答案为$~0~$。跑一遍$~\\text{DFS}~$然后对于每个联通块的方案数乘起来即是答案。时间复杂度为$~O(n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 3e5 + 5;vector&lt;int&gt; adj[maxn];int two[maxn], color[maxn], cnt[2];bool vis[maxn], flag;inline int add(const int&amp; a, const int&amp; b) &#123;return a + b &lt; mod ? a + b : a + b - mod;&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;void dfs(int u, int c = 0) &#123; vis[u] = true; ++cnt[color[u] = c]; for (auto v : adj[u]) &#123; if (vis[v]) flag &amp;= (color[u] ^ color[v]); else dfs(v, !c); &#125;&#125;int main() &#123; two[0] = 1; for (int i = 1; i ^ maxn; ++i) two[i] = add(two[i - 1], two[i - 1]); int t; cin &gt;&gt; t; while (t--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) adj[i].clear(); while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; memset(vis + 1, 0, n * sizeof (bool)); flag = true; int res = 1; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; cnt[0] = cnt[1] = 0; dfs(i); if (flag) res = mul(res, add(two[cnt[0]], two[cnt[1]])); else break; &#125; cout &lt;&lt; (flag ? res : 0) &lt;&lt; endl; &#125;&#125; E. Intersection of Permutations题目大意给定$~1,~\\dots,~n~$的两个全排列$~a~$和$~b~$，和$~q~$个查询或修改操作。查询操作给出$~l_a,~r_a,~l_b,~r_b~$，输出$~a_{[l_a,~r_a]}~$和$~b_{[l_b,~r_b]}~$之间相同同的数字个数。修改操作给出$~x~$和$~y~$，交换$~b_x~$和$~b_y~$。 题解应为$~a~$不会被修改，那么做置换使得$~a_i=i~$，这样对于询问操作，只要输出$~[l_a,~r_a]~$在$~b_{[l_b,~r_b]}~$中出现的次数。考虑二维坐标系上的$~n~$个点$~(b_i,~i),~i=1,~2,~\\dots,~n~$，查询操作等价于输出$~[la,~ra]\\times[lb,~rb]~$内的点的个数；修改操作等价于将$~(b_x,~x)~$和$~(b_y,~y)~$变为$~(b_y,~x)~$和$~(b_x,~y)~$。用树状数组维护$~\\text{treap}~$即可，时间复杂度为$~O(n\\log^2n)~$。由于我不会写$~\\text{treap}~$，所以使用了$~\\text{pb_ds}~$库，常数比较大。 代码（使用$~\\text{pb_ds}~$库）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;using namespace std;using namespace __gnu_pbds;const int maxn = 2e5 + 5;int a[maxn], b[maxn];tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; bit[maxn];#define lowbit(x) (x &amp; -x)int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; int in; cin &gt;&gt; in; a[in] = i; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int in; cin &gt;&gt; in; b[i] = a[in]; for (int j = i; j &lt;= n; j += lowbit(j)) bit[j].insert(b[i]); &#125; while (m--) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; int la, ra, lb, rb; cin &gt;&gt; la &gt;&gt; ra &gt;&gt; lb &gt;&gt; rb; int res = 0; for (int i = rb; i; i -= lowbit(i)) &#123; auto ite = bit[i].upper_bound(ra); if (ite == bit[i].end()) res += bit[i].size(); else res += bit[i].order_of_key(*ite); &#125; for (int i = rb; i; i -= lowbit(i)) &#123; auto ite = bit[i].upper_bound(la - 1); if (ite == bit[i].end()) res -= bit[i].size(); else res -= bit[i].order_of_key(*ite); &#125; for (int i = lb - 1; i; i -= lowbit(i)) &#123; auto ite = bit[i].upper_bound(ra); if (ite == bit[i].end()) res -= bit[i].size(); else res -= bit[i].order_of_key(*ite); &#125; for (int i = lb - 1; i; i -= lowbit(i)) &#123; auto ite = bit[i].upper_bound(la - 1); if (ite == bit[i].end()) res += bit[i].size(); else res += bit[i].order_of_key(*ite); &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; else &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; for (int i = x; i &lt;= n; i += lowbit(i)) bit[i].erase(b[x]); for (int i = y; i &lt;= n; i += lowbit(i)) bit[i].erase(b[y]); swap(b[x], b[y]); for (int i = x; i &lt;= n; i += lowbit(i)) bit[i].insert(b[x]); for (int i = y; i &lt;= n; i += lowbit(i)) bit[i].insert(b[y]); &#125; &#125;&#125; F. Vasya and Array题目大意一个长度为$~n~$的数列由$~1,~\\dots,~k~$组成，部分位置的值已给定。求有多少个数列满足所有长度为$~len~$的区间内至少由$~2~$种不同的数字。 题解动态规划，有点复杂。记$~pre[i][j]~$为区间$~[1,~i]~$中至多有多少$~j~$，从而计算$~fuck[i][j]~$，表示区间$~(i-len,~i]~$是否有可能全部为$~j~$。记$~dp[i][j][0/1]~$为区间$~[1,~i]~$上满足$~a[i]=j~$的合法或非法数量，记求和$~sum[i][0/1]=\\sum_{j=1}^k{dp[i][j][0/1]}~$以及$~cnt[i]=sum[i][0]+sum[i][1]~$。于是有状态转移式 \\begin{aligned} dp[i][j][0] &=sum[i-1][0]+\\begin{cases} sum[i-len][1]-dp[i-len][j][1] &\\text{$flag[i][j]$} \\\\ 0 &\\text{$!flag[i][j]$}\\end{cases} \\\\ dp[i][j][1] &=cnt[i-1]-dp[i][j][0] \\\\ \\end{aligned}所有的状态转移都是$~O(1)~$的，所以时间复杂度与空间复杂度均为$~O(nk)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 1e5 + 5;const int maxk = 105;int a[maxn], pre[maxn][maxk], cnt[maxn], sum[maxn][2], dp[maxn][maxk][2];bool fuck[maxn][maxk];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;int main() &#123; int n, k, len; cin &gt;&gt; n &gt;&gt; k &gt;&gt; len; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; if (~a[i]) pre[i][a[i]] = 1; else for (int j = 1; j &lt;= k; ++j) pre[i][j] = 1; &#125; if (len == 1) return cout &lt;&lt; 0 &lt;&lt; endl, 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= k; ++j) &#123; pre[i][j] += pre[i - 1][j]; if (i &gt;= len &amp;&amp; pre[i][j] - pre[i - len][j] == len) fuck[i][j] = true; &#125; if (~a[1]) &#123; cnt[1] = sum[1][1] = dp[1][a[1]][1] = 1; &#125; else &#123; for (int i = 1; i &lt;= k; ++i) dp[1][i][1] = 1; cnt[1] = sum[1][1] = k; &#125; sum[0][1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (~a[i]) &#123; cnt[i] = cnt[i - 1]; dp[i][a[i]][0] = sum[i - 1][0]; if (fuck[i][a[i]]) dp[i][a[i]][0] = add(dp[i][a[i]][0], sub(sum[i - len][1], dp[i - len][a[i]][1])); dp[i][a[i]][1] = sum[i][1] = sub(cnt[i], sum[i][0] = dp[i][a[i]][0]); &#125; else &#123; for (int j = 1; j &lt;= k; ++j) &#123; dp[i][j][0] = sum[i - 1][0]; if (fuck[i][j]) dp[i][j][0] = add(dp[i][j][0], sub(sum[i - len][1], dp[i - len][j][1])); sum[i][0] = add(sum[i][0], dp[i][j][0]); dp[i][j][1] = sub(cnt[i - 1], dp[i][j][0]); &#125; sum[i][1] = sub(cnt[i] = mul(cnt[i - 1], k), sum[i][0]); &#125; &#125; cout &lt;&lt; sum[n][1] &lt;&lt; endl;&#125; G. Multidimensional Queries题目大意给定$~k~$维空间的$~n~$个点，和$~q~$次修改或查询操作。修改为重新赋值第$~i~$个点，查询为区间$~[l,~r]~$的最大曼哈顿距离。数据范围$~1\\leq n\\leq2\\times10^5,~1\\leq k\\leq5,~1\\leq q\\leq2\\times10^5,~-10^6\\leq a_{ij}\\leq10^6,~$。 题解考虑曼哈顿距离公式 \\begin{aligned} \\sum_{i=1}^{k}\\mid a_{xi}-a_{yi}\\mid &=\\max\\sum_{i=1}^{k}c_i(a_{xi}-a_{yi}) \\\\ &=\\max\\left(\\sum_{i=1}^{k}c_i a_{xi}-\\sum_{i=1}^{k}c_i a_{xi}\\right) \\\\ c_i &=\\pm1 \\\\ \\end{aligned}注意到$~k~$的数据范围很小，上式的系数列的取法共$~2^k~$种，那么建立$~2^{k+1}~$棵线段树维护$~\\sum_{i=1}^{k}c_i a_{xi}~$的最大最小值即可。时间复杂度为$~O((n+q)2^k\\log n)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;int size, seg[maxn &lt;&lt; 2][32][2], a[maxn][32], b[5], idx[maxn], cal[32][2];void build(int begin, int end, int index) &#123; if (begin == end) &#123; for (int i = 0; i ^ size; ++i) seg[index][i][0] = seg[index][i][1] = a[begin][i]; idx[begin] = index; return; &#125; int mid = begin + end &gt;&gt; 1; build(begin, mid, index &lt;&lt; 1); build(mid + 1, end, index &lt;&lt; 1 ^ 1); for (int i = 0; i ^ size; ++i) &#123; seg[index][i][0] = min(seg[index &lt;&lt; 1][i][0], seg[index &lt;&lt; 1 ^ 1][i][0]); seg[index][i][1] = max(seg[index &lt;&lt; 1][i][1], seg[index &lt;&lt; 1 ^ 1][i][1]); &#125;&#125;void push_up(int pos) &#123; int index = idx[pos]; for (int i = 0; i ^ size; ++i) seg[index][i][0] = seg[index][i][1] = a[pos][i]; while (index ^ 1) &#123; index &gt;&gt;= 1; for (int i = 0; i ^ size; ++i) &#123; seg[index][i][0] = min(seg[index &lt;&lt; 1][i][0], seg[index &lt;&lt; 1 ^ 1][i][0]); seg[index][i][1] = max(seg[index &lt;&lt; 1][i][1], seg[index &lt;&lt; 1 ^ 1][i][1]); &#125; &#125;&#125;void push_down(int begin, int end, int index, int l, int r) &#123; if (begin &gt;= l &amp;&amp; end &lt;= r) &#123; for (int i = 0; i ^ size; ++i) &#123; cal[i][0] = min(cal[i][0], seg[index][i][0]); cal[i][1] = max(cal[i][1], seg[index][i][1]); &#125; return; &#125; int mid = begin + end &gt;&gt; 1; if (mid &gt;= l) push_down(begin, mid, index &lt;&lt; 1, l, r); if (mid &lt; r) push_down(mid + 1, end, index &lt;&lt; 1 ^ 1, l, r);&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; size = 1 &lt;&lt; k; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j ^ k; ++j) cin &gt;&gt; b[j]; for (int j = 0; j ^ 1 &lt;&lt; k; ++j) for (int l = 0; l ^ k; ++l) j &amp; (1 &lt;&lt; l) ? a[i][j] += b[l] : a[i][j] -= b[l]; &#125; build(1, n, 1); int q; cin &gt;&gt; q; while (q--) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; int pos; cin &gt;&gt; pos; for (int i = 0; i ^ k; ++i) cin &gt;&gt; b[i]; memset(a[pos], 0, size * sizeof (int)); for (int i = 0; i ^ size; ++i) for (int j = 0; j ^ k; ++j) i &amp; (1 &lt;&lt; j) ? a[pos][i] += b[j] : a[pos][i] -= b[j]; push_up(pos); &#125; else &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; for (int i = 0; i ^ size; ++i) cal[i][0] = ~(1 &lt;&lt; 31), cal[i][1] = 1 &lt;&lt; 31; push_down(1, n, 1, l, r); int res = 0; for (int i = 0; i ^ size; ++i) res = max(res, cal[i][1] - cal[i][0]); cout &lt;&lt; res &lt;&lt; endl; &#125; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round","slug":"Codeforces Round #532 (Div. 2)","date":"2019-01-17T14:07:58.033Z","updated":"2019-01-17T14:09:18.864Z","comments":true,"path":"2019/01/17/Codeforces Round #532 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round #532 (Div. 2)/","excerpt":"","text":"Codeforces Round #532 (Div. 2) A. Roman and Browser题目大意给定一个长度为$~n~$的$~\\pm1~$串，在不考虑所有角标模$~k~$结果一样的位置上的值，问剩下的和的绝对值的最大值。 题解水题。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n), b(k, 0); for (auto&amp; in : a) cin &gt;&gt; in; int sum = accumulate(a.begin(), a.end(), 0), res = 0; for (int i = 0; i ^ n; ++i) b[i % k] += a[i]; for (auto x : b) res = max(res, abs(sum - x)); cout &lt;&lt; res &lt;&lt; endl;&#125; B. Build a Contest题目大意在可重集合里加入$~m~$个数字，每次加入时如果集合里$~1,~2,~\\dots,~n~$都至少有$~1~$个，则都删去$~1~$个然后输出$~1~$，否则输出$~0~$。数据范围$~1\\leq n,~m\\leq10^5~$。 题解直接暴力地维护这个集合时间复杂度为$~O(nm)~$显然会$~\\text{TLE}~$。不做删除操作，而是开$~2~$个数组维护集合：数组$~tot[i]~$表示有多少种数字在集合里至少有$~i~$个；数组$~cnt[i]~$表示数字$~i~$在集合里出现的次数。那么每加入一个数字$~a~$则更新$~cnt[a]~$和$~tot[cnt[a]]~$，输出$~1~$当且仅当$~tot[cnt[a]]=n~$。总时间复杂度为$~O(m)~$。 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; tot(m, 0), cnt(n, 0); int now = 0; while (m--) &#123; int a; cin &gt;&gt; a; ++tot[cnt[a - 1]++]; if (tot[now] == n) &#123; cout &lt;&lt; 1; ++now; &#125; else &#123; cout &lt;&lt; 0; &#125; &#125; cout &lt;&lt; endl;&#125; C. NN and the Optical Illusion题目大意一个中心圆和$~n~$个外圆外切，外圆半径一样且外切构成一个环，给出中心圆半径$~r~$，输出外圆半径$~R~$。 题解平面几何。答案是$~\\frac{r}{\\csc\\frac{\\pi}{n}-1}~$。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; double n, r; cin &gt;&gt; n &gt;&gt; r; printf(\"%.7f\\n\", r / (1 / sin(acos(-1) / n) - 1));&#125; D. Dasha and Chess题目大意交互题。初始在$~999\\times999~$的国际象棋棋盘上有$~\\text{NN}~$的$~1~$个$~\\text{king}~$和$~\\text{Dasha}~$的$~666~$个$~\\text{rook}~$。由$~\\text{NN}~$先走，规则和国际象棋的$~\\text{king}~$一样但是不能走到任意一个$~\\text{rook}~$所在的位置上（不能不动）。如果$~\\text{NN}~$走完后按国际象棋规则被将军，则获胜。这里的$~\\text{rook}~$的规则是任意闪现到空的位置上且不能将军（可以不动）。要求不能超过$~2000~$回合，否则$~\\text{NN}~$失败。 题解别问为什么，先让$~\\text{king}~$走到中心点$~(500,~500)~$。根据抽屉原理，四个角落必有一角落的$~\\text{rook}~$数量不超过$~166~$，于是在某两个方向上的$~\\text{rook}~$数量之和至少是$~500~$，走斜线必然胜利。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;bool vis[1 &lt;&lt; 10][1 &lt;&lt; 10];pair&lt;int, int&gt; chess[667];void query(int x, int y) &#123; vis[chess-&gt;first][chess-&gt;second] = false; if (vis[chess-&gt;first + x][chess-&gt;second + y]) vis[chess-&gt;first][chess-&gt;second += y] = true; else vis[chess-&gt;first += x][chess-&gt;second += y] = true; cout &lt;&lt; chess-&gt;first &lt;&lt; ' ' &lt;&lt; chess-&gt;second &lt;&lt; endl; int k; cin &gt;&gt; k &gt;&gt; x &gt;&gt; y; if (!~k) exit(0); vis[chess[k].first][chess[k].second] = false; vis[chess[k].first = x][chess[k].second = y] = true;&#125;int main() &#123; for (int i = 0; i ^ 667; ++i) &#123; cin &gt;&gt; chess[i].first &gt;&gt; chess[i].second; vis[chess[i].first][chess[i].second] = true; &#125; while (chess-&gt;first &lt; 500) query(1, 0); while (chess-&gt;first &gt; 500) query(-1, 0); while (chess-&gt;second &lt; 500) query(0, 1); while (chess-&gt;second &gt; 500) query(0, -1); int up_left = 0, down_left = 0, up_right = 0, down_right = 0; for (int i = 1; i ^ 1000; ++i) for (int j = 1; j ^ 1000; ++j) if (vis[i][j]) &#123; if (i &lt; 500 &amp;&amp; j &lt; 500) ++up_left; if (i &gt; 500 &amp;&amp; j &lt; 500) ++down_left; if (i &lt; 500 &amp;&amp; j &gt; 500) ++up_right; if (i &gt; 500 &amp;&amp; j &gt; 500) ++down_right; &#125; int minn = min(min(up_left, down_left), min(up_right, down_right)); if (minn == up_left) while(true) query(1, 1); if (minn == down_left) while(true) query(-1, 1); if (minn == up_right) while(true) query(1, -1); if (minn == down_right) while(true) query(-1, -1);&#125; E. Andrew and Taxi题目大意给一个$~n~$个点$~m~$条边的无自环带边权有向图，通过将边的方向翻转使得新图是一个$~\\text{DAG}~$。问所有翻转的边的边权的最大值最小是多少。 题解对答案二分，那么所有当前二分值以下的边都可以选择翻转或者不翻转。这时如果存在一种变为$~\\text{DAG}~$的翻转方式，当且仅当将所有二分值以下的边删除之后的图是$~\\text{DAG}~$。判断是否有环即可，由于还需要输出翻转的方案，所以用拓扑排序。总时间复杂度为$~O((n+m)\\log c)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;vector&lt;int&gt; adj[maxn];bool vis[maxn];int n, m, deg[maxn], topo[maxn];pair&lt;pair&lt;int, int&gt;, int&gt; edge[maxn];bool topo_sort(int lim) &#123; memset(deg, 0, sizeof (deg)); for (int i = 0; i ^ maxn; ++i) adj[i].clear(); for (int i = 1; i &lt;= m; ++i) if (edge[i].second &gt; lim) &#123; adj[edge[i].first.first].push_back(edge[i].first.second); ++deg[edge[i].first.second]; &#125; queue&lt;int&gt; que; for (int i = 0; i ^ maxn; ++i) if (!deg[i]) que.push(i); int rk = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); topo[u] = rk++; for (auto v : adj[u]) if (!--deg[v]) que.push(v); &#125; return rk == maxn;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; edge[i].first.first &gt;&gt; edge[i].first.second &gt;&gt; edge[i].second; int l = -1, r = 0x3f3f3f3f; while (r - l ^ 1) &#123; int m = l + r &gt;&gt; 1; if (topo_sort(m)) r = m; else l = m; &#125; topo_sort(r); vector&lt;int&gt; res; for (int i = 1; i &lt;= m; ++i) if (topo[edge[i].first.first] &gt; topo[edge[i].first.second]) res.push_back(i); cout &lt;&lt; r &lt;&lt; ' ' &lt;&lt; res.size() &lt;&lt; endl; for (auto out : res) &#123; cout &lt;&lt; out; out == res.back() ? cout &lt;&lt; endl : cout &lt;&lt; ' '; &#125;&#125; F. Ivan and Burgers题目大意给定数列$~c_1,~c_2,~\\dots,~c_n~$和$~q~$次询问，问在$~c_l,~c_{l+1},~\\dots,~c_r~$中取若干个数所得到的最大$~\\text{xor}~$和。数据范围$~1\\leq n,~q\\leq5\\cdot10^5,~0\\leq c\\leq10^6~$。 题解显然是个线性基问题，可以用线段树维护，但是递归写法的线段树常数很大会$~\\text{TLE}~$，所以选择常数小的$~\\text{CDQ}~$分治写法。总时间复杂度为$~O((n+q)\\log n\\log c)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 19;int c[maxn];pair&lt;int, int&gt; seg[maxn];struct Vec &#123; vector&lt;int&gt; base; Vec() &#123;base.clear();&#125; Vec(const vector&lt;int&gt;&amp; vec) &#123;base = vec;&#125; bool push(int e) &#123; for (auto v : base) e = min(e, e ^ v); if (e) base.push_back(e); return e; &#125; int max() &#123; int ret = 0; for (auto v : base) ret = std::max(ret, ret ^ v); return ret; &#125; void join(const Vec&amp; vec) &#123;for (auto v : vec.base) push(v);&#125; Vec operator + (const Vec&amp; vec) const &#123; Vec ret(base); ret.join(vec); return ret; &#125; void clear() &#123;base.clear();&#125;&#125;res[maxn], vec[maxn], tmp;void cdq(auto&amp; que,int l, int r) &#123; if (l == r) &#123; for (auto i : que) res[i].push(c[l]); return; &#125; int m = l + r &gt;&gt; 1; tmp.clear(); for (int i = m; i &gt;= l; --i) &#123; tmp.push(c[i]); vec[i] = tmp; &#125; tmp.clear(); for (int i = m + 1; i &lt;= r; ++i) &#123; tmp.push(c[i]); vec[i] = tmp; &#125; vector&lt;int&gt; left, right; for (auto i : que) &#123; if (seg[i].second &lt;= m) left.push_back(i); else if (seg[i].first &gt; m) right.push_back(i); else res[i] = vec[seg[i].first] + vec[seg[i].second]; &#125; que.clear(); cdq(left, l, m); cdq(right, m + 1, r);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; int q; cin &gt;&gt; q; vector&lt;int&gt; que(q); iota(que.begin(), que.end(), 0); for (int i = 0; i ^ q; ++i) cin &gt;&gt; seg[i].first &gt;&gt; seg[i].second; cdq(que, 1, n); for (int i = 0; i ^ q; ++i) cout &lt;&lt; res[i].max() &lt;&lt; '\\n';&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round","slug":"Codeforces Round #530 (Div. 2)","date":"2019-01-17T14:07:58.028Z","updated":"2019-01-17T14:21:51.826Z","comments":true,"path":"2019/01/17/Codeforces Round #530 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round #530 (Div. 2)/","excerpt":"","text":"Codeforces Round #530 (Div. 2) A. Snowball题目大意山坡滚雪球，每秒雪球会增加当前高度的质量然后下落$~1~$米。有$~2~$个石头，每撞一次减少对应的质量最小变为$~0~$。输雪球滚到坡底的质量。 题解水题。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int w, h, u1, d1, u2, d2; cin &gt;&gt; w &gt;&gt; h &gt;&gt; u1 &gt;&gt; d1 &gt;&gt; u2 &gt;&gt; d2; if (d1 &lt; d2) &#123; swap(u1, u2); swap(d1, d2); &#125; for (int i = h; i &gt;= d1; --i) w += i; w = max(0, w - u1); for (int i = d1 - 1; i &gt;= d2; --i) w += i; w = max(0, w - u2); for (int i = d2 - 1; i; --i) w += i; cout &lt;&lt; w &lt;&lt; endl;&#125; B. Squares and Segments要画$~n~$个$~1\\times1~$的正方形格子，每一笔的长度只能为$~1~$。对于以画出的横（竖）的的线段，可以垂直（水平）地平移复制。问至少要画多少不复制的线段。 题解即输出$~\\min(a+b),~ab\\geq n~$。 代码1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int sqr = sqrt(n + 0.5); if (sqr * sqr == n) cout &lt;&lt; (sqr &lt;&lt; 1) &lt;&lt; endl; else if (sqr * sqr + sqr &gt;= n) cout &lt;&lt; (sqr &lt;&lt; 1) + 1 &lt;&lt; endl; else cout &lt;&lt; (sqr + 1 &lt;&lt; 1) &lt;&lt; endl;&#125; C. Postcard题目大意给一个小写字母和?*组成的字符串。字符?代表前一个字母可以删除或保留，字符*代表前一个字母可以删除或保留或重复若干次。输出任意由它生成的长度为$~k~$的字符串或不存在。 题解直接模拟。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; int k; cin &gt;&gt; str &gt;&gt; k; int cnt = 0, tot = 0; for (auto ch : str) &#123; if (ch == '?') ++cnt; if (ch == '*') ++tot; &#125; if (k &lt; str.size() - (cnt + tot &lt;&lt; 1) || !tot &amp;&amp; k &gt; str.size() - cnt) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; string res; int rem = k - str.size() + cnt + tot; if (rem &gt; 0) &#123; bool flag = true; for (auto ch : str) &#123; if (isalpha(ch)) res.push_back(ch); if (ch == '*' &amp;&amp; flag) &#123; flag = false; while (rem--) res.push_back(res.back()); &#125; &#125; &#125; else &#123; for (auto ch : str) &#123; if (isalpha(ch)) &#123; res.push_back(ch); &#125; else if (rem) &#123; res.pop_back(); ++rem; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. Sum in the tree题目大意有一颗非负点权树，根的深度为$~1~$。给出根到所有奇数深度的点的链上的点权值之和$~s_u=\\sum_{v\\in L(1,~u)}a_v,~2\\nmid dep_u~$。输出最小的可能的点权之和$~\\sum_{i=1}^{n}a_i~$或不存在。 题解对于偶数度数的点的$~s_u~$值，取所有儿子的最大值，再和它的父亲比较合法性即可。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; son(n + 1); vector&lt;int&gt; p(n + 1); vector&lt;long long&gt; s(n + 1, 0); for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i]; son[p[i]].push_back(i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; if (~s[i] &amp;&amp; i ^ 1 &amp;&amp; s[i] &lt; s[p[p[i]]]) return cout &lt;&lt; -1 &lt;&lt; endl, 0; &#125; queue&lt;int&gt; que; que.push(1); long long res = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (auto v : son[u]) que.push(v); if (!~s[u]) &#123; s[u] = 0x3f3f3f3f3f3f3f3f; for (auto v : son[u]) s[u] = min(s[u], s[v]); if (s[u] == 0x3f3f3f3f3f3f3f3f) s[u] = s[p[u]]; &#125; res += s[u] - s[p[u]]; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; E. Nice table题目大意给一个由$~\\text{ATCG}~$组成的字母矩阵，输出一个同样大小的的字母矩阵满足所有$~2\\times2~$均由$~\\text{ATCG}~$组成，且使的两矩阵尽量相同。 题解对于任意的合法矩阵，若第$~1~$行的字母超过$~2~$个，则不难推断出每列均由$~2~$个字母组成且奇偶性相同的列所用的字母组成一样。于是合法矩阵必满足每行（或列）均由$~2~$个字母组成，且相同的行（或列）所用的字母组成一样。枚举头$~2~$个字母组成的所有情况即可。考验代码能力。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;char&gt; ch&#123;'A', 'T', 'C', 'G'&#125;; vector&lt;int&gt; p(4); iota(p.begin(), p.end(), 0); int n, m; cin &gt;&gt; n &gt;&gt; m; string res, str, tmp(n * m, '#'); for (int i = 0; i ^ n * m; ++i) &#123; char ch; cin &gt;&gt; ch; str += ch; &#125; int same = 0; do &#123; int tot = 0, cnt[2]; for (int i = 0; i ^ n; ++i) &#123; cnt[0] = cnt[1] = 0; for (int j = 0; j ^ m; ++j) for (int k = 0; k ^ 2; ++k) if (str[i * m + j] == ch[p[(i &amp; 1) &lt;&lt; 1 ^ k]]) ++cnt[(j ^ k) &amp; 1]; if (cnt[0] &lt; cnt[1]) for (int j = 0; j ^ m; ++j) tmp[i * m + j] = ch[p[(i &amp; 1) &lt;&lt; 1 ^ j &amp; 1 ^ 1]]; else for (int j = 0; j ^ m; ++j) tmp[i * m + j] = ch[p[(i &amp; 1) &lt;&lt; 1 ^ j &amp; 1]]; tot += max(cnt[0], cnt[1]); &#125; if (same &lt; tot) &#123; same = tot; res = tmp; &#125; tot = 0; for (int j = 0; j ^ m; ++j) &#123; cnt[0] = cnt[1] = 0; for (int i = 0; i ^ n; ++i) for (int k = 0; k ^ 2; ++k) if (str[i * m + j] == ch[p[(j &amp; 1) &lt;&lt; 1 ^ k]]) ++cnt[(i ^ k) &amp; 1]; if (cnt[0] &lt; cnt[1]) for (int i = 0; i ^ n; ++i) tmp[i * m + j] = ch[p[(j &amp; 1) &lt;&lt; 1 ^ i &amp; 1 ^ 1]]; else for (int i = 0; i ^ n; ++i) tmp[i * m + j] = ch[p[(j &amp; 1) &lt;&lt; 1 ^ i &amp; 1]]; tot += max(cnt[0], cnt[1]); &#125; if (same &lt; tot) &#123; same = tot; res = tmp; &#125; &#125; while (next_permutation(p.begin(), p.end())); for (int i = 0; i ^ n; ++i) &#123; for (int j = 0; j ^ m; ++j) cout &lt;&lt; res[i * m + j]; cout &lt;&lt; endl; &#125;&#125; F. Cookies题目大意给定一颗大小为$~n~$的树，根为$~1~$，每个节点上$~i~$有$~x_i~$个饼干，每个饼干要花费$~t_i~$的时间吃掉，经过连接节点$~u\\neq1~$和它父亲的边的时间花费为$~l_u~$。游戏开始前$~\\text{Mitya}~$在根节点，每一回合$~\\text{Mitya}~$走向当前节点的某一儿子，然后$~\\text{Vasya}~$剪去$~\\text{Mitya}~$所在节点与某一儿子的路径。当$~\\text{Mitya}~$选择结束时他必须通过简单路径走回根节点，过程中可以吃路上的饼干。在总时间花费不超过$~T~$的条件下，问$~\\text{Mitya}~$最多能吃多少饼干。数据范围$~2\\leq n\\leq10^5,~1\\leq T\\leq10^{18},~1\\leq x_i\\leq10^6,~1\\leq t_i\\leq10^6,~0\\leq l_i\\leq10^9~$。 题解先不考虑$~\\text{Vasya}~$的选择。对于每个节点$~u~$，计算它到根节点的路径上$~\\text{Mitya}~$最多能吃到的饼干数量$~cal_u~$。显然为了最大化$~cal_u~$，必须先吃路径上花费时间少的饼干。注意到$~t~$的数据范围，那么可以在$~\\text{dfs}~$过程中维护节点$~u~$到根节点的$~L(u,~1)~$这条路径上单位时间花费为$~t~$的饼干数量$~cnt_t~$。于是当前节点的答案就是在$~T-2\\sum_v l_v,~v\\in L(u,~1)~$的范围内最大化$~cnt~$的前缀和。这个过程可以用二分树状数组，线段树二分，或者树状数组二分来维护。在计算出所有的$~cal_i,~1\\leq i\\leq n~$之后，考虑终点在节点$~u~$的子树上时的答案$~res_u~$。若$~u~$为叶节点，则$~res_u=cal_u~$。若$~u~$为非根非叶节点，考虑到$~\\text{Vasya}~$的存在，则$~res_u=\\max(cal_u,~res_v)~$，其中$~res_v~$为$~u~$的所有儿子的次大$~res~$值给根节点$~1~$增加一个$~cal=\\inf~$的儿子，则可以$~\\text{DFS}~$线性地计算出最终答案$~res_1~$。总时间复杂度为：二分树状数组$~O(n\\log^2n)~$，线段树二分$~O(n\\log n)~$，树状数组二分$~O(n\\log n)~$。据说我的树状数组二分写法就是$~\\text{zkw}~$，但是由于$~\\text{Codeforces}~$的玄学优化，上面$~3~$种数据结构速度基本一样。。。 代码（二分树状数组$~O(n\\log^2n)~$）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;const int maxt = 1 &lt;&lt; 20;int p[maxn], t[maxn];bool vis[maxn], cut[maxn];long long x[maxn], l[maxn], cal[maxn], bit1[maxt], bit2[maxt];vector&lt;int&gt; son[maxn];#define lowbit(x) (x &amp; -x)void dfs1(int u, long long rem) &#123; rem -= l[u] &lt;&lt; 1; for (int i = t[u]; i &lt; maxt; i += lowbit(i)) bit1[i] += x[u], bit2[i] += x[u] * t[u]; if (rem &gt; 0) &#123; int l = 0, r = maxt - 1; long long sum = 0; for (int i = r; i; i -= lowbit(i)) cal[u] += bit1[i], sum += bit2[i]; if (sum &gt; rem) &#123; while (r - l ^ 1) &#123; int mid = l + r &gt;&gt; 1; sum = 0; for (int i = mid; i; i -= lowbit(i)) sum += bit2[i]; if (sum &gt; rem) r = mid; else l = mid; &#125; cal[u] = sum = 0; for (int i = l; i; i -= lowbit(i)) cal[u] += bit1[i], sum += bit2[i]; cal[u] += (rem - sum) / r; &#125; &#125; for (auto v : son[u]) dfs1(v, rem); for (int i = t[u]; i &lt; maxt; i += lowbit(i)) bit1[i] -= x[u], bit2[i] -= x[u] * t[u];&#125;long long dfs2(int u) &#123; long long max1 = u ^ 1 ? 0 : 0x3f3f3f3f3f3f3f3f, max2 = 0; for (auto v : son[u]) &#123; long long temp = dfs2(v); if (max2 &lt; temp) max2 = temp; if (max1 &lt; max2) swap(max1, max2); &#125; return max(max2, cal[u]);&#125;int main() &#123; int n; long long T; cin &gt;&gt; n &gt;&gt; T; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; x[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; t[i]; for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i] &gt;&gt; l[i]; son[p[i]].push_back(i); &#125; dfs1(1, T); cout &lt;&lt; dfs2(1) &lt;&lt; endl;&#125; 代码（线段树二分$~O(n\\log n)~$）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;const int maxt = 1 &lt;&lt; 20;int p[maxn], t[maxn];long long x[maxn], l[maxn], cal[maxn], seg1[maxt &lt;&lt; 2], seg2[maxt &lt;&lt; 2];vector&lt;int&gt; son[maxn];void push_up(int begin, int end, int index, int pos, long long del) &#123; seg1[index] += del; seg2[index] += del * pos; if (begin + 1 == end) return; int mid = begin + end &gt;&gt; 1; if (pos &gt; mid) push_up(mid, end, index &lt;&lt; 1 ^ 1, pos, del); else push_up(begin, mid, index &lt;&lt; 1, pos, del);&#125;long long push_down(int begin, int end, int index, long long rem) &#123; if (begin + 1 == end) return min(rem / end, seg1[index]); int mid = begin + end &gt;&gt; 1; return rem &lt; seg2[index &lt;&lt; 1] ? push_down(begin, mid, index &lt;&lt; 1, rem) : seg1[index &lt;&lt; 1] + push_down(mid, end, index &lt;&lt; 1 ^ 1, rem - seg2[index &lt;&lt; 1]); &#125;void dfs1(int u, long long rem) &#123; push_up(0, maxt, 1, t[u], x[u]); if ((rem -= l[u] &lt;&lt; 1) &gt; 0) cal[u] = push_down(0, maxt, 1, rem); for (auto v : son[u]) dfs1(v, rem); push_up(0, maxt, 1, t[u], -x[u]);&#125;long long dfs2(int u) &#123; long long max1 = u ^ 1 ? 0 : 0x3f3f3f3f3f3f3f3f, max2 = 0; for (auto v : son[u]) &#123; long long temp = dfs2(v); if (max2 &lt; temp) max2 = temp; if (max1 &lt; max2) swap(max1, max2); &#125; return max(max2, cal[u]);&#125;int main() &#123; int n; long long T; cin &gt;&gt; n &gt;&gt; T; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; x[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; t[i]; for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i] &gt;&gt; l[i]; son[p[i]].push_back(i); &#125; dfs1(1, T); cout &lt;&lt; dfs2(1) &lt;&lt; endl;&#125; 代码（树状数组二分$~O(n\\log n)~$）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;const int maxt = 1 &lt;&lt; 20;int p[maxn], t[maxn];bool vis[maxn], cut[maxn];long long x[maxn], l[maxn], cal[maxn], bit1[maxt + 1], bit2[maxt + 1];vector&lt;int&gt; son[maxn];#define lowbit(x) (x &amp; -x)void dfs1(int u, long long rem) &#123; for (int i = t[u]; i &lt; maxt; i += lowbit(i)) bit1[i] += x[u], bit2[i] += x[u] * t[u]; int now = maxt; long long temp = (rem -= l[u] &lt;&lt; 1); for (int i = maxt, j = 0; rem &gt; 0; i &gt;&gt;= 1) &#123; if (i == 1) &#123; cal[u] += j &amp; 1 ? min(temp / (j + 1), bit1[j + 1] - bit1[j]) : min(temp / (j ^ 1), bit1[j ^ 1]); break; &#125; if (temp &gt; bit2[i &gt;&gt; 1 ^ j]) &#123; cal[u] += bit1[i &gt;&gt; 1 ^ j]; temp -= bit2[i &gt;&gt; 1 ^ j]; j ^= i &gt;&gt; 1; &#125; &#125; for (auto v : son[u]) dfs1(v, rem); for (int i = t[u]; i &lt; maxt; i += lowbit(i)) bit1[i] -= x[u], bit2[i] -= x[u] * t[u];&#125;long long dfs2(int u) &#123; long long max1 = u ^ 1 ? 0 : 0x3f3f3f3f3f3f3f3f, max2 = 0; for (auto v : son[u]) &#123; long long temp = dfs2(v); if (max2 &lt; temp) max2 = temp; if (max1 &lt; max2) swap(max1, max2); &#125; return max(max2, cal[u]);&#125;int main() &#123; int n; long long T; cin &gt;&gt; n &gt;&gt; T; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; x[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; t[i]; for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i] &gt;&gt; l[i]; son[p[i]].push_back(i); &#125; dfs1(1, T); cout &lt;&lt; dfs2(1) &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round","slug":"Codeforces Round #530 (Div. 1) (TBC)","date":"2019-01-17T14:07:58.024Z","updated":"2019-01-17T14:31:20.202Z","comments":true,"path":"2019/01/17/Codeforces Round #530 (Div. 1) (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round #530 (Div. 1) (TBC)/","excerpt":"","text":"Codeforces Round #530 (Div. 1) A. Sum in the tree题目大意有一颗非负点权树，根的深度为$~1~$。给出根到所有奇数深度的点的链上的点权值之和$~s_u=\\sum_{v\\in L(1,~u)}a_v,~2\\nmid dep_u~$。输出最小的可能的点权之和$~\\sum_{i=1}^{n}a_i~$或不存在。 题解对于偶数度数的点的$~s_u~$值，取所有儿子的最大值，再和它的父亲比较合法性即可。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; son(n + 1); vector&lt;int&gt; p(n + 1); vector&lt;long long&gt; s(n + 1, 0); for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i]; son[p[i]].push_back(i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; if (~s[i] &amp;&amp; i ^ 1 &amp;&amp; s[i] &lt; s[p[p[i]]]) return cout &lt;&lt; -1 &lt;&lt; endl, 0; &#125; queue&lt;int&gt; que; que.push(1); long long res = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (auto v : son[u]) que.push(v); if (!~s[u]) &#123; s[u] = 0x3f3f3f3f3f3f3f3f; for (auto v : son[u]) s[u] = min(s[u], s[v]); if (s[u] == 0x3f3f3f3f3f3f3f3f) s[u] = s[p[u]]; &#125; res += s[u] - s[p[u]]; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; B. Nice table题目大意给一个由$~\\text{ATCG}~$组成的字母矩阵，输出一个同样大小的的字母矩阵满足所有$~2\\times2~$均由$~\\text{ATCG}~$组成，且使的两矩阵尽量相同。 题解对于任意的合法矩阵，若第$~1~$行的字母超过$~2~$个，则不难推断出每列均由$~2~$个字母组成且奇偶性相同的列所用的字母组成一样。于是合法矩阵必满足每行（或列）均由$~2~$个字母组成，且相同的行（或列）所用的字母组成一样。枚举头$~2~$个字母组成的所有情况即可。考验代码能力。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;char&gt; ch&#123;'A', 'T', 'C', 'G'&#125;; vector&lt;int&gt; p(4); iota(p.begin(), p.end(), 0); int n, m; cin &gt;&gt; n &gt;&gt; m; string res, str, tmp(n * m, '#'); for (int i = 0; i ^ n * m; ++i) &#123; char ch; cin &gt;&gt; ch; str += ch; &#125; int same = 0; do &#123; int tot = 0, cnt[2]; for (int i = 0; i ^ n; ++i) &#123; cnt[0] = cnt[1] = 0; for (int j = 0; j ^ m; ++j) for (int k = 0; k ^ 2; ++k) if (str[i * m + j] == ch[p[(i &amp; 1) &lt;&lt; 1 ^ k]]) ++cnt[(j ^ k) &amp; 1]; if (cnt[0] &lt; cnt[1]) for (int j = 0; j ^ m; ++j) tmp[i * m + j] = ch[p[(i &amp; 1) &lt;&lt; 1 ^ j &amp; 1 ^ 1]]; else for (int j = 0; j ^ m; ++j) tmp[i * m + j] = ch[p[(i &amp; 1) &lt;&lt; 1 ^ j &amp; 1]]; tot += max(cnt[0], cnt[1]); &#125; if (same &lt; tot) &#123; same = tot; res = tmp; &#125; tot = 0; for (int j = 0; j ^ m; ++j) &#123; cnt[0] = cnt[1] = 0; for (int i = 0; i ^ n; ++i) for (int k = 0; k ^ 2; ++k) if (str[i * m + j] == ch[p[(j &amp; 1) &lt;&lt; 1 ^ k]]) ++cnt[(i ^ k) &amp; 1]; if (cnt[0] &lt; cnt[1]) for (int i = 0; i ^ n; ++i) tmp[i * m + j] = ch[p[(j &amp; 1) &lt;&lt; 1 ^ i &amp; 1 ^ 1]]; else for (int i = 0; i ^ n; ++i) tmp[i * m + j] = ch[p[(j &amp; 1) &lt;&lt; 1 ^ i &amp; 1]]; tot += max(cnt[0], cnt[1]); &#125; if (same &lt; tot) &#123; same = tot; res = tmp; &#125; &#125; while (next_permutation(p.begin(), p.end())); for (int i = 0; i ^ n; ++i) &#123; for (int j = 0; j ^ m; ++j) cout &lt;&lt; res[i * m + j]; cout &lt;&lt; endl; &#125;&#125; C. Construct a tree题目大意给定两个数$~n~$和$~s~$，输出一个大小为$~n~$的树满足所有子树的大小之和为$~s~$或不存在，若存在输出的树必须满足最大分叉$~k~$尽量小。数据范围$~2\\leq n\\leq10^5,~1\\leq s\\leq10^{10}~$。 题解考虑所有节点$~u~$对于$~s~$的贡献，当且仅当子树的根$~v~$为$~u~$的祖先时，$~u~$才会对答案贡献$~1~$。所以$~s=\\sum_{i=1}^{n}dep_i\\in[2n-1,~\\frac{n(n+1)}{2}]~$。对于$~k~$叉树，$~s~$值的下限随着$~k~$增大减小。所以考虑二分，可以得出最小的$~k~$值。先构造出最小的$~k-1~$叉树，然后移动深的点即可。时间复杂度为$~O(n\\log n)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int num[maxn], lim[maxn], dep[maxn], sta[maxn], son[maxn];int main() &#123; int n; long long s; cin &gt;&gt; n &gt;&gt; s; if (1LL * n * (n + 1) &lt; s &lt;&lt; 1 || n &lt;&lt; 1 &gt; s + 1) return cout &lt;&lt; \"No\" &lt;&lt; endl, 0; cout &lt;&lt; \"Yes\" &lt;&lt; endl; if (1LL * n * (n + 1) == s &lt;&lt; 1) &#123; cout &lt;&lt; 1; for (int i = 2; i ^ n; ++i) cout &lt;&lt; ' ' &lt;&lt; i; cout &lt;&lt; endl; return 0; &#125; int l = 1, r = n - 1; while (r - l ^ 1) &#123; int m = l + r &gt;&gt; 1; long long rem = n - 1, cnt = 1, cal = 1; for (int i = 2; rem; ++i) &#123; cnt *= m; if (rem &lt; cnt) cal += rem * i, rem = 0; else cal += cnt * i, rem -= cnt; &#125; cal &gt; s ? (l = m) : (r = m); &#125; int right = r; long long flr = 1; for (int i = 1, tot = 0; tot ^ n; ++i, flr *= l) &#123; if (tot + flr &gt; n) num[i] = n - tot, tot = n; else num[i] = flr, tot += flr; &#125; lim[1] = 1; for (int i = 1; 1LL * lim[i] * r &lt; n &lt;&lt; 1; ++i) lim[i + 1] = lim[i] * r; long long cnt = 0; for (r = 1; num[r]; ++r) cnt += 1LL * r * num[r]; l = 2; cnt -= s; while (cnt) &#123; if (num[l] == lim[l]) ++l; if (!num[r]) --r; if (cnt &lt; r - l) &#123; --num[r]; ++num[r - cnt]; break; &#125; --num[r]; ++num[l]; cnt += l - r; &#125; sta[1] = 1; for (int i = 1, d = 1; i &lt;= n; ++i) &#123; dep[i] = d; if (!--num[d]) sta[++d] = i + 1; &#125; for (int i = 2; i ^ n; ++i) &#123; cout &lt;&lt; sta[dep[i] - 1] &lt;&lt; ' '; if (++son[sta[dep[i] - 1]] == right) ++sta[dep[i] - 1]; &#125; cout &lt;&lt; sta[dep[n] - 1] &lt;&lt; endl;&#125; D. Eels题目大意大鱼吃小鱼，小鱼吃虾米。鱼缸里如果有$~n~$条鱼，则会发生$~n-1~$次生死$~\\text{solo}~$，最终一人吃鸡。小鱼被大鱼吃掉后质量也送给了大鱼，类似于球球大作战。定义质量为$~a\\leq b~$的两条鱼生死$~\\text{solo}~$是危险的，如果$~a\\leq b\\leq2a~$。一个鱼缸的危险值定义为最多可能发生的危险$~\\text{solo}~$次数。最开始鱼缸为空，每次加一条或者减一条质量为$~x~$的鱼，输出每次的危险值。数据范围$~1\\leq q\\leq5\\cdot10^5,~1\\leq x\\leq10^9~$。 题解对所有鱼的质量升序得到$~a_1,~a_2,~\\dots,~a_n~$。定义如果$~a_i&gt;2\\sum_{j&lt; i}a_j~$，则称它为肥鱼（算上第一只$~a_1~$）。设当前鱼缸有$~k~$只肥鱼，则下面证明危险值为$~n-k~$： 对于肥鱼，它一定不会在危险$~\\text{solo}~$中作为大鱼出现，所以危险值的上限为$~n-k~$。 在每次选择最小的两只鱼$~\\text{solo}~$，这样危险$~\\text{solo}~$的总次数为$~n-k~$。所以现在对于每次操作，算出当前的$~k~$值即可。考虑区间$~[1,~2),~[2,~4),~\\dots,~[2^m,~2^{m+1}),~\\dots~$，显然每个区间至多一只肥鱼。那么用$~\\text{multiset}~$来维护每个区间的鱼，这样每次操作就能在$~O(\\log q\\log x)~$内算出$~k~$值。总时间复杂度为$~O(q\\log q\\log x)~$。 注意数据范围过大，可能需要$~\\text{fastIO}~$。 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); multiset&lt;long long&gt; seg[32]; long long sum[32] = &#123;0&#125;; int q, cnt = 0; cin &gt;&gt; q; while (q--) &#123; char op; long long x; cin &gt;&gt; op &gt;&gt; x; int idx = 0; for (int i = 1; i &lt; x; i &lt;&lt;= 1, ++idx); if (op == '+') &#123; seg[idx].insert(x); sum[idx] += x; ++cnt; &#125; else &#123; seg[idx].erase(seg[idx].find(x)); sum[idx] -= x; --cnt; &#125; int res = cnt; long long tot = 0; for (int i = 0; i ^ 32; tot += sum[i++]) if (sum[i] &amp;&amp; *(seg[i].begin()) &gt; tot &lt;&lt; 1) --res; cout &lt;&lt; res &lt;&lt; '\\n'; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round","slug":"Codeforces Round #527 (Div. 3) (TBC)","date":"2019-01-17T14:07:58.020Z","updated":"2019-01-17T14:09:10.904Z","comments":true,"path":"2019/01/17/Codeforces Round #527 (Div. 3) (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round #527 (Div. 3) (TBC)/","excerpt":"","text":"Codeforces Round #527 (Div. 3) A. Uniform String题目大意输出任意长度为$~n~$且由前$~k~$个小写字母组成的串，要求出现次数最少的尽量多。 题解水题。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; while (n--) cout &lt;&lt; char('a' + n % k); cout &lt;&lt; endl; &#125;&#125; B. Teams Forming题目大意给$~n~$个数字，每个数字可以加若干次$~1~$，求最少次数使得这$~n~$个数字可以两两配对，每对都一样大。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, a[100]; cin &gt;&gt; n; for (int i = 0; i ^ n; ++i) cin &gt;&gt; a[i]; sort(a, a + n); int res = 0; for (int i = 0; i ^ n; ++i) res += i &amp; 1 ? a[i] : -a[i]; cout &lt;&lt; res &lt;&lt; endl;&#125; C. Prefixes and Suffixes题目大意一个长度为$~n~$的串的$~n-1~$个前缀和后缀打乱顺序给出。输出任意合法的划分，使得存在一个长度为$~n~$的串，它的所有前缀和后缀均和该划分一致。 题解暴力先枚举两个给定串合成的长度为$~n~$的串然后判断。代码的时间复杂度上限是$~O(n^3)~$，但在枚举的过程中最多$~4~$次即可枚举出合法的原串，所以实际时间复杂度为$~O(n^2)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int size = n - 1 &lt;&lt; 1; vector&lt;string&gt; strs(size), fuck[n]; for (auto&amp; str : strs) &#123; cin &gt;&gt; str; fuck[(int)str.size()].push_back(str); &#125; set&lt;string&gt; ggsimida; for (int i = 1; i ^ n; ++i) for (int j = 0; j ^ 2; ++j) for (int k = 0; k ^ 2; ++k) &#123; string now = fuck[i][j] + fuck[n - i][k]; if (ggsimida.find(now) != ggsimida.end()) continue; vector&lt;bool&gt; use(size, false); string res(size, 0); int cal = 0; for (int len = 1; len ^ n; ++len) &#123; string pre(now, 0, len); for (int idx = 0; idx ^ size; ++idx) if (!use[idx] &amp;&amp; strs[idx] == pre) &#123; use[idx] = true; res[idx] = 'P'; ++cal; break; &#125; string suf(now, len, n - len); for (int idx = 0; idx ^ size; ++idx) if (!use[idx] &amp;&amp; strs[idx] == suf) &#123; use[idx] = true; res[idx] = 'S'; ++cal; break; &#125; &#125; if (cal == size) return cout &lt;&lt; res &lt;&lt; endl, 0; ggsimida.insert(now); &#125;&#125; D1. Great Vova Wall (Version 1)题目大意铺砖，宽度为$~n~$，初始每个位置已经铺了一些$~1\\times1~$的砖在最下面。问是否能继续放若干个$~2\\times1~$的砖（横竖均可），使得最后顶面是平的。 题解考虑黑白染色，可以铺平当前仅当黑白数量一致。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int cnt = 0; while (n--) &#123; int a; cin &gt;&gt; a; (n ^ a) &amp; 1 ? ++cnt : --cnt; &#125; if (abs(cnt) &lt; 2) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl;&#125; D2. Great Vova Wall (Version 2)题目大意上一题的基础上禁止竖着放砖。 题解单调栈模拟。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; stack&lt;int&gt; fuck; int shit = 0; while (n--) &#123; int a; cin &gt;&gt; a; shit = max(shit, a); if (fuck.empty()) fuck.push(a); else if (fuck.top() &lt; a) return cout &lt;&lt; \"NO\" &lt;&lt; endl, 0; else if (fuck.top() == a) fuck.pop(); else fuck.push(a); &#125; if (fuck.empty() || fuck.size() == 1 &amp;&amp; fuck.top() == shit) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl;&#125; E. Minimal Diameter ForestF. Tree with Maximum Cost题目大意给定一个大小为$~n~$的有点权树，两点之间的距离定义为最短路径上的边数。定义$~cost(u)=\\sum_{v=1}^n{dist(u,~v)\\cdot a_i}~$，求$~\\min{cost(u)}~$。 题解考虑相邻两个点$~u~$和$~v~$之间的答案转移。删去$~edge(u,~v)~$，则原树被划分为两个子树，记点集分别为$~S_u~$和$~S_v~$。则有等式 \\begin{aligned} res_u+\\sum_{i\\in S_u}{a_i} &=res_v+\\sum_{S_v}{a_i} \\\\ res_u &=res_v+\\sum_{i=1}^n{a_i}-2\\sum_{i\\in S_u}{a_i} \\\\ \\end{aligned}那么任取一点为根，第一遍$~\\text{DFS}~$找出对于所有子树上子树根的$~cost~$和子树的权值之和$~\\sum_{i\\in S_u}{a_i}~$，第二遍$~\\text{DFS}~$更新所有点的答案。时间复杂度为$~O(n)~$。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;long long a[maxn], res[maxn], ans;vector&lt;int&gt; adj[maxn];long long dfs1(int u = 1, int p = 0) &#123; for (auto v : adj[u]) if (v ^ p) res[u] += dfs1(v, u), a[u] += a[v]; return res[u] += a[u];&#125;void dfs2(int u = 1, int p = 0) &#123; ans = max(ans, res[u] = res[p] + a[1] - (a[u] &lt;&lt; 1)); for (auto v : adj[u]) if (v ^ p) dfs2(v, u);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; while (--n) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; res[0] = dfs1(); dfs2(); cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round","slug":"Codeforces Round #526 (Div. 2) (TBC)","date":"2019-01-17T14:07:58.013Z","updated":"2019-01-17T14:49:03.209Z","comments":true,"path":"2019/01/17/Codeforces Round #526 (Div. 2) (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round #526 (Div. 2) (TBC)/","excerpt":"","text":"Codeforces Round #526 (Div. 2) A. The Fair Nut and Elevator题目大意有$~N~$个楼层，第$~i~$层住着$~a_i~$个人。每天每人都要坐两次电梯，第一次从第$~i~$层坐电梯到第$~1~$层，第二次从第$~1~$层坐电梯到第$~i~$层。电梯一次只能载一个人且有一个初始位置第$~x~$层。电梯的运行每次必须先从第$~x~$层到起点层，再到终点层，再回到$~x~$层。求$~x~$的最优解使得每天电梯的运行距离最短，输出这个最短距离。 题解水题。贪心。显然$~x=1~$是最优解。输出$~4\\sum a_i(i-1)~$即可。证明略。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int res = 0; for (int i = 0; i ^ n; ++i) &#123; int a; cin &gt;&gt; a; res += a * i; &#125; cout &lt;&lt; (res &lt;&lt; 2) &lt;&lt; endl;&#125; B. Kvass and the Fair Nut题目大意给定$~n~$个数$~v_1,~v_2,~\\dots,~v_n~$，让他们一共减去$~s~$，使得最小值最大，输出这个最小值。 题解贪心。有巨坑。说多都是泪。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; long long s; cin &gt;&gt; n &gt;&gt; s; long long minn = 0x3f3f3f3f3f3f3f3f, sum = 0; for (int i = 0; i ^ n; ++i) &#123; long long v; cin &gt;&gt; v; minn = min(minn, v); sum += v; &#125; if (sum &lt; s) cout &lt;&lt; -1 &lt;&lt; endl; else if (n * minn + s &lt; sum) cout &lt;&lt; minn &lt;&lt; endl; else cout &lt;&lt; (sum - s) / n &lt;&lt; endl;&#125; C. The Fair Nut and String题目大意给定一个小写字母串，求生成的全$~a~$串数量，满足相邻的两个$~a~$在原串中必有一个$~b~$在这两个$~a~$之间。 题解水题。原串中相邻的两个$~b~$之间若有$~n~$个$~a~$，则至多在这$~n~$个$~a~$中选$~1~$个，显然有$~n+1~$种选法（包括不选）。答案则是$~{\\prod(n_i+1)}-1~$，因为要减去空串。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; const int mod = 1e9 + 7; int res = 1, cnt = 1; for (auto ch : str) &#123; if (ch == 'a') ++cnt; if (ch == 'b') res = 1LL * res * cnt % mod, cnt = 1; &#125; cout &lt;&lt; 1LL * res * cnt % mod - 1 &lt;&lt; endl;&#125; D. The Fair Nut and the Best Path题目大意给一个树，有非负整数点权$~w~$和正整数边权$~c~$，一条链的值为$~\\sum{w}-\\sum{c}~$。求出最大的链值（单个点视为退化链也算）。 题解树形$~\\text{DP}~$。任取一个点为树根，每个点记录以它为一个端点，另一个端点为它后代的最大链值$~x~$，对于叶子有$~x=c~$。那么考虑经过点$~u~$且在以$~u~$为根的子树上的链的最大值$~max_u~$，对$~u~$的所有儿子$~v~$的$~x_v~$值与连接它们的边权$~w_v~$做差，加入两个$~x=w=0~$的虚点，则可以用这些差$~x_v-w_v~$的最大值来更新$~x_u~$，最大值和次大值来更新$~max_u~$。于是可以在$~\\text{DFS}~$过程中线性地更新出答案。由于数据范围允许时间复杂度为$~O(n\\log{n})~$，于是可以用排序来简化求最大值和次大值的代码。 已更新简便线性做法。 代码（$~O(n\\log{n})~$）123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;long long c[maxn];vector&lt;pair&lt;int, long long&gt;&gt; adj[maxn];long long dfs(int u = 1, int p = 0) &#123; long long ret = 0; vector&lt;long long&gt; sons(2, 0LL); for (auto son : adj[u]) if (son.first ^ p) &#123; ret = max(ret, dfs(son.first, u)); sons.push_back(c[son.first] - son.second); &#125; sort(sons.begin(), sons.end()); reverse(sons.begin(), sons.end()); c[u] += sons[0]; return max(ret, c[u] + sons[1]);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; while (--n) &#123; int u, v; long long w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; adj[u].push_back(make_pair(v, w)); adj[v].push_back(make_pair(u, w)); &#125; cout &lt;&lt; dfs() &lt;&lt; endl;&#125; 代码（$~O(n)~$）123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;long long c[maxn], dp[maxn], res;vector&lt;pair&lt;int, long long&gt;&gt; adj[maxn];void dfs(int u = 1, int p = 0) &#123; res = max(res, dp[u] = c[u]); for (auto v : adj[u]) if (v.first ^ p) &#123; dfs(v.first, u); res = max(res, dp[u] + dp[v.first] - v.second); dp[u] = max(dp[u], c[u] + dp[v.first] - v.second); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; while (--n) &#123; int u, v; long long w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; adj[u].push_back(make_pair(v, w)); adj[v].push_back(make_pair(u, w)); &#125; dfs(); cout &lt;&lt; res &lt;&lt; endl;&#125; E. The Fair Nut and Strings题目大意找出$~k~$个长度为$~n~$且字典序在$~s~$和$~t~$之间的$~ab~$串，使得不一样的前缀的数量最多，输出最大的不同前缀数。 题解考虑所有$~ab~$串构成的$~\\text{trie}~$树，这显然是一个完全二叉树。再考虑所求的$~k~$个$~ab~$串构成的$~\\text{trie}~$树，则答案是节点数量，且第$~i~$层的节点数量至多为$~\\min{|t_i|-|s_i|,~k}~$个。其中$~|str_i|~$表示字符串$~str~$前$~i~$个字符构成的前缀所对应的二进制数值。自上而下模拟更新答案即可。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, k; string s, t; cin &gt;&gt; n &gt;&gt; k &gt;&gt; s &gt;&gt; t; long long res = 1LL * n * k; for (int i = 0, dif = 0; i ^ n &amp;&amp; (dif = (dif &lt;&lt; 1) + (t[i] == 'b') - (s[i] == 'b')) &lt; k; ++i) res -= k - dif - 1; cout &lt;&lt; res &lt;&lt; endl;&#125; F. Max Mex题目大意给一棵大小为$~n~$的树，所有节点的初始值为$~0,~1,~\\dots,~n-1~$的一个全排列。对于这棵树上的任意一条链$~l~$，$~V(l)~$表示$~l~$上所有点的集合。有$~q~$次修改或查询操作，修改为交换$~2~$个节点的值，查询为输出$~\\max{mex(V(l))}~$。 注：$~mex(S)~$表示不在集合$~S~$中的最小自然数，即$~\\min{x\\in\\Bbb{N}:x\\not\\in S}~$。 题解老子现在不会。据说是线段树维护各值所在点之间的连接关系。","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Avito Cool Challenge 2018 (TBC)","slug":"Avito Cool Challenge 2018 (TBC)","date":"2019-01-17T14:07:57.977Z","updated":"2019-01-17T14:08:58.238Z","comments":true,"path":"2019/01/17/Avito Cool Challenge 2018 (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Avito Cool Challenge 2018 (TBC)/","excerpt":"","text":"Avito Cool Challenge 2018 A. Definite Game题目大意给一个正整数$~n~$，每次减去一个互质的数，输出最小结果。 题解水题。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; (n ^ 2 ? 1 : 2) &lt;&lt; endl;&#125; B. Farewell Party题目大意原本有一个数列$~b_1,~b_2,~\\dots,~b_n~$，先已知每个数在这个数列中有多少个其他的数与它不一样的数列$~a_1,~a_2,~\\dots,~a_n~$，输出任意合法的$~{b_n}~$。 题解如果两个数字$~x~$和$~y~$在$~{b_n}~$中出现的次数一样，则对应的$~{a_n}~$也一样于是考虑$~z~$在$~{a_n}~$中出现的次数$~cnt~$，则必有$~cnt\\mid n-z~$。直接模拟即可。 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; arr(n), cnt(n); vector&lt;stack&lt;int&gt;&gt; res(n); for (auto&amp; a : arr) cin &gt;&gt; a, ++cnt[a]; for (int i = 0, now = 1; i ^ n; ++i) &#123; if (cnt[i] % (n - i)) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; for (int j = 0, tot = cnt[i] / (n - i); j ^ tot; ++j, ++now) for (int k = i; k ^ n; ++k) res[i].push(now); &#125; cout &lt;&lt; \"Possible\" &lt;&lt; endl; int last = arr.back(); arr.pop_back(); for (auto a : arr) &#123; cout &lt;&lt; res[a].top() &lt;&lt; ' '; res[a].pop(); &#125; cout &lt;&lt; res[last].top() &lt;&lt; endl;&#125; C. Colorful Bricks题目大意对连续相邻的$~n~$块砖进行$~m~$染色，使得有$~k~$块砖和左边的不一样（第一块不算），求所有染色可能数量。 题解数学推导发现答案就是$~\\binom{n-1}{k}m(m-1)^k~$。 代码1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 1 &lt;&lt; 11;int inv[maxn], fact[maxn], finv[maxn];inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int fpow(int a, int n) &#123; int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; cout &lt;&lt; mul(mul(mul(mul(fact[n - 1], finv[k]), finv[n - k - 1]), m), fpow(m - 1, k)) &lt;&lt; endl;&#125; D. Maximum Distance题目大意一个给定一个$~n~$个点$~m~$条边的联通图（可以有重边自环），有边权$~w_e~$并给定$~k~$个关键点。对于每条简单路径$~L(u,~v)~$，定义路径的花费$~cost(L(u,~v))=\\max_{e\\in L(u,~v)}{w_e}~$。定义距离$~dist(u,~v)=\\min{cost(L(u,~v))}~$。输出离每个关键点最远的关键点的距离。 题解考虑$~\\text{Kruskal}~$做法的最小生成树，那么$~dist(u,~v)~$即为$~\\text{MST}~$上两点间的路径花费。不难发现这时候关键点的最远距离都一样，为$~\\text{Kruskal}~$构造$~\\text{MST}~$过程中第一个联通所有关键点的边权。为维护关键点的连通性，在并查集的过程中不要按秩合并，而是尽量以关键点为父亲，记录合并关键点连通性的次数，到$~k-1~$次时直接输出答案即可。时间复杂度上限为$~O(n\\log n+m\\log m)~$。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int fa[maxn];int find(const int&amp; a) &#123;return fa[a] ^ a ? (fa[a] = find(fa[a])) : a;&#125;int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) fa[i] = i; vector&lt;bool&gt; vip(n + 1, false); for (int i = 0; i ^ k; ++i) &#123; int x; cin &gt;&gt; x; vip[x] = true; &#125; vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; edge(m); for (auto&amp; e : edge) cin &gt;&gt; e.second.first &gt;&gt; e.second.second &gt;&gt; e.first; sort(edge.begin(), edge.end()); int cnt = 1; for (auto e : edge) &#123; int a = find(e.second.first); int b = find(e.second.second); if (a == b) continue; if (vip[a]) fa[b] = a; else fa[a] = b; if (vip[a] &amp;&amp; vip[b]) if (++cnt == k) &#123; for (int i = 1; i ^ k; ++i) cout &lt;&lt; e.first &lt;&lt; ' '; cout &lt;&lt; e.first &lt;&lt; endl; return 0; &#125; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"区间DP与平行四边形优化","slug":"区间DP与平行四边形优化","date":"2019-01-17T13:54:41.803Z","updated":"2019-01-17T14:10:06.218Z","comments":true,"path":"2019/01/17/区间DP与平行四边形优化/","link":"","permalink":"http://yoursite.com/2019/01/17/区间DP与平行四边形优化/","excerpt":"","text":"区间DP对于询问区间最优解的问题，可以先考虑较小区间的最优解，然后通过合并小区间得到大区间最有解。动态规划状态转移式 dp[i][j]=\\min\\{dp[i][k]+dp[k+1][j]\\}+f[i][j]算法实现过程中通常要用到三层$~\\text{for}~$循环，从外到里分别维护区间宽度$~j-i~$，区间端点$~i~$和区间分割点$~k~$，复杂度为$~O(N^3)~$。 四边形不等式如果$~\\forall~a\\leq b\\leq c\\leq d~$，$~f~$满足 f(a,~c)+f(b,~d)\\leq f(a,~d)+f(b,~c)则称$~f~$满足四边形不等式。 区间包含单调性如果$~\\forall~I_1\\subseteq I_2~$，$~f~$满足f(I_1)\\leq f(I_2)则称$~f~$满足区间包含单调性。 平行四边形优化考虑状态转移过程中的最优转移点，记$~k[i][j]~$为$~dp[i][j]~$的最优转移点，即 dp[i][j]=dp[i][k[i]][j]]+dp[k[i][j]+1][j]+f[i][j]如果$~dp~$和$~f~$都满足四边形不等式和区间包含单调性，则必有 k[i][j-1]\\leq k[i][j]\\leq k[i+1][j]那么缩小状态转移点的区间范围，在更新$~dp[i][j]~$的同时更新$~k[i][j]~$，时间复杂度可以优化至$~O(n^2)~$。区间范围和时间复杂度的证明目前没看懂，先放个百度百科的链接。反正百度到的CSDN和博客园都是抄来抄去那破尿性，更加看不懂，先凑合着用。 题目HDU3506题目大意给定一个大小为$~N~$的环，每次合并相邻区间$~A~$和$~B~$的花费是$~(\\sum A+\\sum B)*(|A|+|B|)~$，求将这个环合并为一个集合的最小总花费。 题解动态规划，记$~dp[i][j]~$为将$~i,~\\dots,~j~$合并的最小花费。注意到这题是环形数组，则可以将数组扩大一倍，令$~a[n+i]=a[i],~i=1,~2,~\\dots,~n-1~$，同时用平行四边形优化。时间复杂度$~O(N^2)~$。 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 11;int dp[maxn][maxn], s[maxn][maxn], pre[maxn];int main() &#123; int n; while (cin &gt;&gt; n) &#123; memset(dp, 0x3f, sizeof (dp)); for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; pre[i], pre[i + n] = pre[i]; for (int i = 1; i ^ n &lt;&lt; 1; ++i) pre[i] += pre[i - 1], dp[i][i] = 0, s[i][i] = i; for (int len = 1; len ^ n; ++len) for (int i = 1; i + len ^ n &lt;&lt; 1; ++i) &#123; int j = i + len; for (int k = s[i][j - 1]; k &lt;= s[i + 1][j]; ++k) if (dp[i][j] &gt; dp[i][k] + dp[k + 1][j] + pre[j] - pre[i - 1]) &#123; s[i][j] = k; dp[i][j] = dp[i][k] + dp[k + 1][j] + pre[j] - pre[i - 1]; &#125; &#125; int res = 0x3f3f3f3f; for (int i = 1; i &lt;= n; ++i) res = min(res, dp[i][i + n - 1]); cout &lt;&lt; res &lt;&lt; endl; &#125;&#125; HDU4632题目大意给定一个字符串，求出所有的回文子序列个数模$~10007~$的答案，时间复杂度要求在$~O(n^2)~$以内。 题解动态规划，记$~dp[i][j]~$为区间$~[i,~j]~$内的回文子序列个数。则根据容斥原理，有状态转移式 dp[i][j]=\\begin{cases} dp[i][j-1]+dp[i+1][j]-dp[i+1][j] &str[i]\\not=str[j] \\\\ dp[i][j-1]+dp[i+1][j]+1 &str[i]=str[j] \\end{cases}代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 10007;const int maxn = 1 &lt;&lt; 10;int dp[maxn][maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;int main() &#123; for (int i = 0; i ^ maxn; ++i) dp[i][i] = 1; int t; cin &gt;&gt; t; for (int cas = 1; cas &lt;= t; ++cas) &#123; string str; cin &gt;&gt; str; int size = (int)str.size(); for (int i = 1; i ^ size; ++i) &#123; if (str[i - 1] ^ str[i]) dp[i - 1][i] = 2; else dp[i - 1][i] = 3; &#125; for (int len = 2; len &lt; size; ++len) for (int i = 0; i + len ^ size; ++i) &#123; int j = i + len; dp[i][j] = add(dp[i + 1][j], dp[i][j - 1]); if (str[i] ^ str[j]) dp[i][j] = sub(dp[i][j], dp[i + 1][j - 1]); else dp[i][j] = add(dp[i][j], 1); &#125; cout &lt;&lt; \"Case \" &lt;&lt; cas &lt;&lt; \": \" &lt;&lt; dp[0][size - 1] &lt;&lt; endl; &#125;&#125; HDU4745题目大意给一个大小为$~N~$的环形数组，要求分别顺时针逆时针一圈以内各选一个子序列，使得子序列一样，求最大的子序列长度。 题解其实差不多就是求最大的回文子序列长度，注意细节，具体看代码。 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 11;int dp[maxn][maxn], a[maxn];int main() &#123; for (int i = 0; i ^ maxn; ++i) dp[i][i] = 1; int n; while (true) &#123; cin &gt;&gt; n; if (!n) break; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i], a[n + i] = a[i]; for (int len = 1; len ^ n; ++len) for (int i = 1; i + len &lt;= n &lt;&lt; 1; ++i) &#123; int j = i + len; if (a[i] == a[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); &#125; int res = 0; for (int i = 1; i &lt;= n; ++i) res = max(res, max(dp[i][i + n - 1], dp[i][i + n - 2] + 1)); cout &lt;&lt; res &lt;&lt; endl; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[]},{"title":"斜率优化DP","slug":"斜率优化DP","date":"2019-01-17T13:54:41.798Z","updated":"2019-01-17T14:50:58.171Z","comments":true,"path":"2019/01/17/斜率优化DP/","link":"","permalink":"http://yoursite.com/2019/01/17/斜率优化DP/","excerpt":"","text":"斜率优化DP思想对于状态转移公式满足如下条件的动态规划 dp[i]=\\min_{j","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[]},{"title":"队列优化DP","slug":"队列优化DP","date":"2019-01-17T13:54:38.281Z","updated":"2019-01-17T14:10:03.617Z","comments":true,"path":"2019/01/17/队列优化DP/","link":"","permalink":"http://yoursite.com/2019/01/17/队列优化DP/","excerpt":"","text":"队列优化DP思想对于状态转移公式满足如下条件的动态规划 dp[i]=(\\min\\text{or}\\max)\\{f[j]\\}+g[i],~j\\in[\\alpha[i],\\beta[i]]其中$~f~$和$~g~$均可线性时间内求出，且$\\alpha~$和$~\\beta~$单调递增。朴素的做法是直接暴力循环计算状态转移，时间复杂度为$~O(n^2)~$。但是注意到区间$~[\\alpha,~\\beta]~$的单调递增性质，可以用一个叫做单调队列的数据结构来维护区间的最值。 单调队列的性质 可以用双端队列或者双指针数组实现，内部的任意元素$~que[i]~$表示$~f~$的角标。 角标有序储存，即$~que[i]&lt;que[j],~\\forall~i&lt;j~$。 角标对应的数组值单调，即$~f[que[i]]~$单调递增或者单调递减。 单调队列的操作（单调递减队列维护区间最大值） 每次更新区间时，从小到大考虑新加入的角标$~now~$，将所有队列$~que~$中满足$~que[cmp]&lt;que[now]~$的元素$~cmp~$从队列$~que~$中移除。由于单调队列的性质，只需要让$~now~$与队列$~que~$的尾部元素$~last~$比较即可。 将$~now~$放入队列$~que~$尾部，经过上一个操作，单调队列性质依然保持。 将队列$~que~$头部所有不在区间$~[\\alpha,~\\beta]~$的元素$~head~$从队列$~que~$中移除。由于区间$~[\\alpha,~\\beta]~$的单调递增性质，单调队列性质依然保持，且此时$~\\max{f[i]}=f[que[head]]~$。 复杂度计算每个角标$~i~$至多被放入队列$~que~$或者从队列$~que~$中移除一次，所以是线性复杂度$~O(n)~$。 题目HDU3401题目大意炒股，一共$~T~$天，第$~i~$天股票的买价是$~ap[i]~$、最多可以买$~as[i]~$股，卖价是$~bp[i]~$、最多可以卖$~bs[i]~$股，且每两次交易之间相隔必须大于$~W~$天，最大屯股量为$~maxp~$，问最后的最大收益。 题解动态规划，记$~dp[i][j]~$表示在第$~i~$天还剩下$~j~$股的最大收益，则有$~3~$种状态更新 dp[i][j]=\\max\\begin{cases} dp[i-1][j] &\\text{null} \\\\ dp[i-w-1][j-k]-ap[i]*k &\\text{$k\\leq\\min(j,~as[i])$} \\\\ dp[i-w-1][j+k]+bp[i]*k &\\text{$k\\leq\\min(maxp-j~,bs[i])$} \\\\ \\end{cases}这样的时间复杂度为$~O(T\\cdot maxp^2)~$，显然会$~\\text{TLE}~$。但观察$~dp[i][j]~$的第二种状态更新，有 \\begin{aligned} dp[i][j] &=\\max\\alpha[l]-ap[i]*j \\\\ \\alpha[l] &=dp[i-w-1][l]+ap[i]*[l] \\\\ l &\\in[\\max(0,~j-as[i]),~j] \\\\ \\end{aligned}第三种状态更新同理 \\begin{aligned} dp[i][j] &=\\max\\beta[l]-bp[i]*j \\\\ \\beta[l] &=dp[i-w-1][l]+bp[i]*[l] \\\\ l &\\in[j,~\\min(maxp,~j+bs[i])] \\\\ \\end{aligned}于是可以用单调队列来维护$~\\max(\\alpha,\\beta)~$。这样对于每个$~dp[i][j]~$状态转移的平均复杂度为$~O(1)~$，总时间复杂度为$~O(T\\cdot maxp)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1 &lt;&lt; 11;int ap[maxn], bp[maxn], as[maxn], bs[maxn], temp[maxn], dp[maxn &lt;&lt; 1][maxn];int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int n, maxp, w; cin &gt;&gt; n &gt;&gt; maxp &gt;&gt; w; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; ap[i] &gt;&gt; bp[i] &gt;&gt; as[i] &gt;&gt; bs[i]; for (int i = 0; i &lt;= w; ++i) &#123; dp[i][0] = 0; for (int j = 1; j &lt;= maxp; ++j) dp[i][j] = -inf; &#125; deque&lt;int&gt; que; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= maxp; ++j) dp[i + w][j] = dp[i + w - 1][j]; que.clear(); for (int j = 0; j &lt;= maxp; ++j) &#123; temp[j] = dp[i - 1][j] + ap[i] * j; while (!que.empty() &amp;&amp; temp[que.back()] &lt; temp[j]) que.pop_back(); que.push_back(j); while (que.front() &lt; j - as[i]) que.pop_front(); dp[i + w][j] = max(dp[i + w][j], temp[que.front()] - ap[i] * j); &#125; que.clear(); for (int j = 0; j &lt;= maxp; ++j) temp[j] = dp[i - 1][j] + bp[i] * j; for (int j = 0; j ^ bs[i]; ++j) &#123; while (!que.empty() &amp;&amp; temp[que.back()] &lt; temp[j]) que.pop_back(); que.push_back(j); &#125; for (int j = 0; j &lt;= maxp; ++j) &#123; if (j + bs[i] &lt;= maxp) &#123; while (!que.empty() &amp;&amp; temp[que.back()] &lt; temp[j + bs[i]]) que.pop_back(); que.push_back(j + bs[i]); &#125; while (que.front() &lt; j) que.pop_front(); dp[i + w][j] = max(dp[i + w][j], temp[que.front()] - bp[i] * j); &#125; &#125; cout &lt;&lt; dp[n + w][0] &lt;&lt; endl; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[]},{"title":"Good Bye 2018 (TBC)","slug":"Good Bye 2018 (TBC)","date":"2019-01-17T12:54:33.346Z","updated":"2019-01-17T14:08:29.227Z","comments":true,"path":"2019/01/17/Good Bye 2018 (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Good Bye 2018 (TBC)/","excerpt":"","text":"Good Bye 2018 A. New Year and the Christmas Ornament题目大意给$~3~$个数$~y,~b,~r~$，求最大的$~sum=a+(a+1)+(a+2)~$，满足$~a\\leq y,~a+1\\leq b,~a+2\\leq r$。 题解水题。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; 3 * min(a + 1, min(b, c - 1)) &lt;&lt; endl;&#125; B. New Year and the Treasure Geolocation题目大意给定$~n~$个坐标和$~n~$个向量，存在一种坐标和向量一一配对的方式，使得$~n~$个坐标为起点经向量所指向的终点一样，输出这个终点。 题解平均坐标即是答案，注意数据范围会爆$~\\text{int}~$。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; long long x = 0, y = 0, a, b; for (int i = 0; i ^ n &lt;&lt; 1; ++i) &#123; cin &gt;&gt; a &gt;&gt; b; x += a; y += b; &#125; cout &lt;&lt; x / n &lt;&lt; ' ' &lt;&lt; y / n &lt;&lt; endl;&#125; C. New Year and the Sphere Transmission题目大意数字$~1,~2,~\\dots,~n~$逆时针排成一圈，起点在$~1~$。逆时针每$~k~$个数取一个，直到恰好回到$~1~$处，所有取的数得到一个总和$~sum(k)~$。将所有可能的$~sum(k)~$从小到达输出。 题解不难发现每$~k~$个数去一个与每$~\\gcd(k,~n)~$个数去一个所得到的总和一样。那么只考虑$~k\\mid n~$的情况。此时 sum(k)=\\sum_{i=0}^{\\frac{n}{k}-1}ik+1=\\frac{1}{2}\\left(\\frac{n(n+2)}{k}-n\\right)枚举$~n~$的因子$~k~$即可，时间复杂度为$~O(\\sqrt{n})~$。对于有序输出答案以及去重，由于数据范围不大，可以用$~\\text{set}~$维护，时间复杂度为$~O(\\sqrt{n}\\log n)~$。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; long long n; cin &gt;&gt; n; set&lt;long long&gt; res; int sqr = sqrt(n + 1); for (int i = 1; i &lt;= sqr; ++i) if (!(n % i)) &#123; res.insert((n + 2) * i - n &gt;&gt; 1); res.insert((n + 2) * n / i - n &gt;&gt; 1); &#125; cout &lt;&lt; 1; res.erase(res.find(1)); for (auto out : res) cout &lt;&lt; ' ' &lt;&lt; out; cout &lt;&lt; endl;&#125; D. New Year and the Permutation Concatenation题目大意序列$~p~$由$~1,~2,~\\dots,~n~$的所有全排列按字典序连在一起，长度为$~n\\cdot n!~$。输出$~p~$中有多少长度为$~n~$的连续子序列满足总和为$~\\frac{n(n+1)}{2}~$。 题解首先每一个原生的全排列一定满足总和为$~\\frac{n(n+1)}{2}~$。接下来不难发现所有符合条件的长度为$~n~$的连续子序列也必定是一个全排，于是答案变成了$~p~$中有多少个全排列。对于非原生的全排列，它必定由一个原生全排列的后缀接上下一个原生全排列的前缀。再注意到原生全排列按字典序排列，于是一对原生全排列要通过前面的后缀加后面的前缀生成新的全排列，必须满足两者的前缀一样。于是对于公共前缀长度不小于$~k~$的相邻原生全排列对，均可通过取前者长度为$~n-k~$的后缀和后者长度为$~k~$的前缀，构造出新的全排列，共计$~\\frac{n!}{(n-k)!}((n-k)!-1)~$个。枚举$~1\\leq k\\leq n-2~$，答案为 n!+\\sum_{k=1}^{n-2}\\frac{n!}{(n-k)!}((n-k)!-1)=n!(n-\\sum_{i=1}^{n-1}\\frac{1}{k!})代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 1 &lt;&lt; 20;int inv[maxn], fact[maxn], finv[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline void init() &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125;&#125;int main() &#123; init(); int n; cin &gt;&gt; n; int res = 0; for (int i = 1; i ^ n; ++i) res = add(res, finv[i]); cout &lt;&lt; mul(fact[n], sub(n, res)) &lt;&lt; endl;&#125; E. New Year and the Acquaintance Estimation题目大意给定$~n~$个点的度数，问是否可以加一个新的度数，使得这$~n+1~$个点能构成一个简单无向图。将所有可能的度数升序输出。 题解题目里已经给出了相关理论的$~\\text{wiki}~$链接。根据$~\\text{Erdo2s-Gallai}~$定理，以$~d_1\\geq d_2\\geq\\dots\\geq d_n~$为度数可以构成简单图的充要条件是$~2\\mid\\sum_{i=1}^{n}d_i~$，且 \\sum_{i=1}^{k}d_i\\leq k(k-1)+\\sum_{i=k+1}^{n}\\min(d_i,~k),~\\forall~1\\leq k\\leq n将$~d~$改为升序，用$~n-k~$代替$~k~$，则不等式变为 \\sum_{i=k+1}^{n}d_i\\leq (n-k)(n-k-1)+\\sum_{i=1}^{k}\\min(d_i,~n-k),~\\forall~0\\leq k< n不难发现答案必为连续的一段且奇偶性相同。先不考虑奇偶性，如果新加的度数$~deg~$不合法，则考虑上式不成立时$~deg~$在上式的左边还是右边。如果在左边，说明$~deg~$过大，反之如果在右边，则$~deg~$过小。左右都出现的话则说明无解。二分$~deg~$即可。时间复杂度$~O(n\\log n)~$或$~O(n\\log^2n)~$均可接受。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 19;long long vec[maxn], deg[maxn], pre[maxn];int size;inline int cal(const long long&amp; rem) &#123; memcpy(deg, vec, size * sizeof (long long)); deg[size - 1] = rem; for (int i = size - 1; i &amp;&amp; deg[i - 1] &gt; deg[i]; --i) swap(deg[i - 1], deg[i]); int pos1 = lower_bound(deg, deg + size, rem) - deg; int pos2 = upper_bound(deg, deg + size, rem) - deg; for (int i = 0; i ^ size; ++i) pre[i + 1] = pre[i] + deg[i]; int pos = 0; bool flag1 = false, flag2 = false; for (int k = size - 1; ~k; --k) &#123; while (pos ^ size &amp;&amp; deg[pos] &lt; size - k) ++pos; if (pre[size] - pre[k] &gt; (size - k) * (size - min(k, pos) - 1LL) + pre[min(k, pos)]) &#123; flag1 |= k &gt; pos1; flag2 |= k &lt; pos2; &#125; &#125; if (flag1 &amp;&amp; flag2) exit((cout &lt;&lt; -1 &lt;&lt; endl, 0) ); return flag1 ? -1 : flag2;&#125;int main() &#123; int n; cin &gt;&gt; n; size = n + 1; int parity = 0; for (int i = 0; i ^ n; ++i) cin &gt;&gt; vec[i], parity ^= vec[i] &amp; 1; sort(vec, vec + n); int left, right; if (!cal(0)) &#123; left = 0; &#125; else &#123; int l = 0, r = n; while (r - l ^ 1) &#123; int mid = l + r &gt;&gt; 1; if (~cal(mid)) r = mid; else l = mid; &#125; left = r; &#125; if (!cal(n)) &#123; right = n; &#125; else &#123; int l = left, r = n; while (r - l ^ 1) &#123; int mid = l + r &gt;&gt; 1; if (cal(mid) ^ 1) l = mid; else r = mid; &#125; right = l; &#125; cout &lt;&lt; (left &amp; 1 ^ parity ? left + 1 : left); for (int i = left + 2; i &lt;= right; ++i) if (!(i &amp; 1 ^ parity)) cout &lt;&lt; ' ' &lt;&lt; i; cout &lt;&lt; endl; return 0;&#125; F. New Year and the Mallard Expedition题目大意有$~3~$种地形和行动方式，分别是草地、水、火山和走、游泳、飞，行动的耗时分别为$~1~$米$~5~$秒、$~1~$米$~3~$秒、$~1~$米$~1~$秒。可以反向行动且随时可以无花费地切换行动方式。走和游泳分别只能在草地和水上使用，飞行可以在任何地形使用，但是飞行需要能量。能量一开始为$~0~$，每走或者游$~x~$米均可获得$~x~$能量，每飞$~x~$米则会消耗$~x~$能量。全路程共计$~n~$段，给出的地形和长度，问最短耗时。 题解现根据各种地形对应的行动方式模拟一遍，算出答案的上界并记录到每一段时能量还剩余多少（有可能需要为了补充能量需而原地打转）。然后从终点向起点模拟，在保证每处剩余能量非负的情况下，先尽量在草地上飞，如果还有能量剩余则在水上飞。需要注意细节。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;long long&gt; len(n + 1, 0), rem(n + 1, 0); for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; len[i]; string str; cin &gt;&gt; str; str = 'A' + str; long long res = 0; bool flag = false; for (int i = 1; i &lt;= n; ++i) &#123; if (str[i] ^ 'L') &#123; rem[i] = rem[i - 1] + len[i]; flag |= str[i] == 'W'; res += len[i] * (str[i] == 'W' ? 3 : 5); &#125; else &#123; if (rem[i - 1] &lt; len[i]) &#123; rem[i] = 0; res += (len[i] - rem[i - 1]) * (flag ? 4 : 6) + rem[i - 1]; &#125; else &#123; rem[i] = rem[i - 1] - len[i]; res += len[i]; &#125; &#125; &#125; long long cnt = 0, minn = 0x3f3f3f3f3f3f3f3f; for (int i = n; i; --i) &#123; minn = min(minn, rem[i]); if (str[i] == 'G') &#123; auto sub = min(minn, len[i] &lt;&lt; 1); res -= sub &lt;&lt; 1; minn -= sub; cnt += sub; &#125; &#125; cout &lt;&lt; res + cnt - rem[n] &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"线性基","slug":"线性基","date":"2019-01-17T07:46:42.873Z","updated":"2019-01-17T14:10:11.978Z","comments":true,"path":"2019/01/17/线性基/","link":"","permalink":"http://yoursite.com/2019/01/17/线性基/","excerpt":"","text":"线性基问题对于非负整数区间$~[0,~2^n)~$，可以按二进制$~01~$表示映射到域$~\\Bbb{Z}_2~$上的$~n~$维向量空间$~\\Bbb{Z}_2^n~$。记上述的映射为$~f:[0,~2^n)\\to\\Bbb{Z}_2^n,~x\\mapsto v~$，这里$~v~$是$~x~$在二进制下的$~01~$表示，显然$~f~$是双射。之后的内容中，对于向量$~v\\in\\Bbb{Z}_2^n~$，都用$~f^{-1}(v)\\in[0,~2^n)~$来表示。那么对于若干整数的$~\\text{xor}~$运算问题，则转化为向量空间$~\\Bbb{Z}_2^n~$上的加法运算问题，通常称为线性基问题。 线性基向量空间$~\\Bbb{Z}_2^n~$上任意$~n~$个线性无关的向量，称作该向量空间上的一组线性基。显然$~1,~2,~\\dots,~2^{n-1}~$是$~\\Bbb{Z}_2^n~$的一组线性基，称作标准线性基。且向量空间$~\\Bbb{Z}_2^n~$的任意一个子空间$~V~$必同构于向量空间$~\\Bbb{Z}_2^m,~0\\leq m\\leq n~$，于是$~{\\mid V\\mid}=2^m~$。 最小生成子空间对于向量空间$~\\Bbb{Z}_2^n~$的一个子集$~A={a_1,~a_2,~\\dots,~a_m}~$，子空间$~V~$称作$~A~$在$~\\Bbb{Z}_2^n~$上的最小生成子空间，当且仅当$~A\\subseteq V\\subseteq~\\Bbb{Z}_2^n~$，且对于$~\\Bbb{Z}_2^n~$的所有子空间$~W~$满足：如果$~A\\subseteq W~$，则必有$~V\\subseteq W~$。如果$~a_1,~a_2,~\\dots,~a_m~$线性无关，则它们构成$~V~$的一组线性基。于是有推论：对于$~A~$的最小生成子空间$~V~$，满足$~\\dim V\\leq{\\mid A\\mid}~$。 空间的扩张对于向量空间$~\\Bbb{Z}_2^n~$的子空间$~V~$和向量$~a~$，定义$~V(a)={a+b:b\\in V}\\cup V~$。显然$~V(a)~$是包含$~V~$和$~a~$的最小空间，称$~V(a)~$是$~V~$的扩张。如果$~a\\in V~$，则显然$~V(a)=V~$，称作平凡扩张；否则称作不平凡扩张，且$~\\dim V(a)=\\dim V+1~$。对于不平凡扩张，设$~b_1,~b_2,~\\dots,~b_{\\dim V}~$是$~V~$的一组线性基，因为$~a\\notin V~$，$~a~$无法被$~b_1,~b_2,~\\dots,~b_{\\dim V}~$线性表出，所以$~b_1,~b_2,~\\dots,~b_{\\dim V},~a~$线性无关，它们是$~V(a)~$的一组线性基。 代码实现存储对于任意线性无关组，显然它的最小生成子空间是唯一的。所以可以用$~\\text{vector}~$来储存这个线性无关组来表示一个线性空间。 12345678template &lt;typename T&gt;struct Vec &#123; vector&lt;T&gt; base; Vec() &#123;&#125;; Vec(const vector&lt;T&gt;&amp; vec): base(vec) &#123;&#125; void clear() &#123;base.clear();&#125; int size() &#123;return base.size();&#125;&#125;; 扩张自行理解。 1234567891011bool push(T e) &#123; for (auto v : base) e = std::min(e, e ^ v); if (e) base.push_back(e); return e;&#125;void join(const Vec&amp; vec) &#123;for (auto v : vec.base) push(v);&#125;Vec operator + (const Vec&amp; vec) const &#123; Vec ret(base); ret.join(vec); return ret;&#125; 最值最小值为非$~0~$最小值，其余自行理解。 12345678910T min() &#123; T ret = base.front(); for (auto v : base) ret = std::min(ret, v); return ret;&#125;T max() &#123; T ret = 0; for (auto v : base) ret = std::max(ret, ret ^ v); return ret;&#125; 标准化自行理解。 123456void sort() &#123; std::sort(base.begin(), base.end()); for (int i = 1; i ^ base.size(); ++i) for (int j = i - 1; ~j; --j) base[i] = std::min(base[i], base[i] ^ base[j]);&#125; 有序查找从$~0~$开始，需要标准化，其余自行理解。 12345T find_by_order(T k) &#123; T ret = 0; for (int i = 0; i &amp; base.size(); ++i) if (k &amp; T(1) &lt;&lt; i) ret ^= base[i]; return ret;&#125; 模板12345678910111213141516171819202122232425262728293031323334353637383940template &lt;typename T&gt;struct Vec &#123; vector&lt;T&gt; base; Vec() &#123;&#125;; Vec(const vector&lt;T&gt;&amp; vec): base(vec) &#123;&#125; void clear() &#123;base.clear();&#125; int size() &#123;return base.size();&#125; bool push(T e) &#123; for (auto v : base) e = std::min(e, e ^ v); if (e) base.push_back(e); return e; &#125; void join(const Vec&amp; vec) &#123;for (auto v : vec.base) push(v);&#125; Vec operator + (const Vec&amp; vec) const &#123; Vec ret(base); ret.join(vec); return ret; &#125; T min() &#123; T ret = base.front(); for (auto v : base) ret = std::min(ret, v); return ret; &#125; T max() &#123; T ret = 0; for (auto v : base) ret = std::max(ret, ret ^ v); return ret; &#125; void sort() &#123; std::sort(base.begin(), base.end()); for (int i = 1; i ^ base.size(); ++i) for (int j = i - 1; ~j; --j) base[i] = std::min(base[i], base[i] ^ base[j]); &#125; T find_by_order(T k) &#123; T ret = 0; for (int i = 0; i &amp; base.size(); ++i) if (k &amp; T(1) &lt;&lt; i) ret ^= base[i]; return ret; &#125;&#125;; 题目CF1101G代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 19;int c[maxn];pair&lt;int, int&gt; seg[maxn];struct Vec &#123; vector&lt;int&gt; base; Vec() &#123;base.clear();&#125; Vec(const vector&lt;int&gt;&amp; vec) &#123;base = vec;&#125; bool push(int e) &#123; for (auto v : base) e = min(e, e ^ v); if (e) base.push_back(e); return e; &#125; int max() &#123; int ret = 0; for (auto v : base) ret = std::max(ret, ret ^ v); return ret; &#125; void join(const Vec&amp; vec) &#123;for (auto v : vec.base) push(v);&#125; Vec operator + (const Vec&amp; vec) const &#123; Vec ret(base); ret.join(vec); return ret; &#125; void clear() &#123;base.clear();&#125;&#125;res[maxn], vec[maxn], tmp;void cdq(auto&amp; que,int l, int r) &#123; if (l == r) &#123; for (auto i : que) res[i].push(c[l]); return; &#125; int m = l + r &gt;&gt; 1; tmp.clear(); for (int i = m; i &gt;= l; --i) &#123; tmp.push(c[i]); vec[i] = tmp; &#125; tmp.clear(); for (int i = m + 1; i &lt;= r; ++i) &#123; tmp.push(c[i]); vec[i] = tmp; &#125; vector&lt;int&gt; left, right; for (auto i : que) &#123; if (seg[i].second &lt;= m) left.push_back(i); else if (seg[i].first &gt; m) right.push_back(i); else res[i] = vec[seg[i].first] + vec[seg[i].second]; &#125; que.clear(); cdq(left, l, m); cdq(right, m + 1, r);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; int q; cin &gt;&gt; q; vector&lt;int&gt; que(q); iota(que.begin(), que.end(), 0); for (int i = 0; i ^ q; ++i) cin &gt;&gt; seg[i].first &gt;&gt; seg[i].second; cdq(que, 1, n); for (int i = 0; i ^ q; ++i) cout &lt;&lt; res[i].max() &lt;&lt; '\\n';&#125; CF1100F代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), base; cin &gt;&gt; a.front(); for (int i = 1; i ^ n; ++i) cin &gt;&gt; a[i], a[i] ^= a[i - 1]; if (!a.back()) return cout &lt;&lt; -1 &lt;&lt; endl, 0; for (auto e : a) &#123; for (auto v : base) e = min(e, e ^ v); if (e) base.push_back(e); &#125; cout &lt;&lt; base.size() &lt;&lt; endl;&#125; HDU3949代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define all(o) o.begin(), o.end()template &lt;typename T&gt;struct Vec &#123; vector&lt;T&gt; base; Vec() &#123;&#125; int size() &#123;return base.size();&#125; bool push(T e) &#123; for (auto v : base) e = std::min(e, e ^ v); if (e) base.pb(e); return e; &#125; void sort() &#123; std::sort(all(base)); for (int i = 1; i ^ base.size(); ++i) for (int j = i - 1; ~j; --j) base[i] = std::min(base[i], base[i] ^ base[j]); &#125; T find_by_rank(T k) &#123; if (k &gt;= T(1) &lt;&lt; base.size()) return -1; T ret = 0; for (int i = 0; i ^ base.size(); ++i) if (k &amp; T(1) &lt;&lt; i) ret ^= base[i]; return ret; &#125;&#125;;int main() &#123; int t; cin &gt;&gt; t; for (int cas = 1; cas &lt;= t; ++cas) &#123; int n; cin &gt;&gt; n; Vec&lt;ll&gt; vec; for (int i = 0; i ^ n; ++i) &#123; ll a; cin &gt;&gt; a; vec.push(a); &#125; int q; cin &gt;&gt; q; vec.sort(); ll flag = (n == vec.size()) - 1; cout &lt;&lt; \"Case #\" &lt;&lt; cas &lt;&lt; \":\\n\"; while (q--) &#123; ll k; cin &gt;&gt; k; cout &lt;&lt; vec.find_by_rank(k + flag) &lt;&lt; '\\n'; &#125; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[]}]}
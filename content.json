{"meta":{"title":"MAOoo","subtitle":null,"description":null,"author":"MAOoo","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-01-17T12:42:26.595Z","updated":"2019-01-17T12:42:26.595Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-01-17T12:48:12.233Z","updated":"2019-01-17T12:48:12.233Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Codeforces Round 589 (Div. 2)","slug":"Codeforces Round 589 (Div. 2)","date":"2019-09-30T14:19:50.446Z","updated":"2019-09-30T16:07:28.448Z","comments":true,"path":"2019/09/30/Codeforces Round 589 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/09/30/Codeforces Round 589 (Div. 2)/","excerpt":"","text":"Codeforces Round #589 (Div. 2) A. Distinct Digits题目大意水题。 题解水题。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; for (int x = l; x &lt;= r; ++x) &#123; string s = to_string(x); set&lt;char&gt; ss; for (char c : s) ss.insert(c); if (s.size() == ss.size()) return cout &lt;&lt; x &lt;&lt; endl, 0; &#125; cout &lt;&lt; -1 &lt;&lt; endl;&#125; B. Filling the Grid题目大意在$~h\\times w~$的黑白网格图上给定如下限制：每行贴着左方的连续黑色长度为$~r_1,r_2,\\dots,r_h\\in[0,w]$，每列贴着上方的连续黑色长度为$~c_1,c_2,\\dots,c_w\\in[0,h]$。计算有多少方案满足这些限制。数据范围$~1\\leq h,w\\leq10^3~$。 题解对所有的限制硬模拟，计算每个格子的颜色是黑色还是白色或者是两种均可，出现冲突答案为$~0~$，否则答案为$~2^n~$，其中$~n~$为两种均可的格子数量。时间复杂度为$~O(hw)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int mod = 1000000007;constexpr const int maxn = 1024;int grid[maxn][maxn], r[maxn], c[maxn];int main() &#123; memset(grid, -1, sizeof (grid)); int h, w; cin &gt;&gt; h &gt;&gt; w; int res = h * w; for (int i = 0; i != h; ++i) cin &gt;&gt; r[i]; for (int j = 0; j != w; ++j) cin &gt;&gt; c[j]; for (int i = 0; i != h; ++i) &#123; res -= r[i]; for (int j = 0; j != r[i]; ++j) grid[i][j] = 1; if (r[i] != w) &#123; --res; grid[i][r[i]] = 0; &#125; &#125; for (int j = 0; j != w; ++j) &#123; int check = 1; for (int i = 0; i != c[j]; ++i) &#123; check &amp;= grid[i][j] != 0; res -= grid[i][j] == -1; &#125; if (c[j] != h) check &amp;= grid[c[j]][j] != 1; if (!check) return cout &lt;&lt; 0 &lt;&lt; endl, 0; if (c[j] != h) res -= grid[c[j]][j] == -1; &#125; int ans = 1; while (res--) &#123; ans &lt;&lt;= 1; ans &lt; mod ? 0 : ans -= mod; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; C. Primes and Multiplication题目大意定义 prime(x)=\\lbrace\\,p\\,|\\,x:\\text{$p$ is a prime}\\,\\rbraceg(x,p)=\\max\\lbrace\\,p^k\\,|\\,x:k\\in\\Bbb N\\,\\rbracef(x,y)=\\prod_{p\\in prime(x)}f(y,p)计算$~\\prod_{i=1}^{n}f(x,i)~$。数据范围$~2\\leq x\\leq10^9,~1\\leq n\\leq10^{18}~$。 题解求出$~prime(x)~$后对于所有的$~p\\in prime(x)~$，计算$~p~$在$~\\prod_{i=1}^{n}n!~$的指数即可，总时间复杂度为$~O(\\sqrt x+\\log\\log x\\log n)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int mod = 1000000007;constexpr int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;constexpr int sub(int a, int b) &#123; return a &lt; b ? a - b + mod : a - b; &#125;constexpr int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;int fpow(int a, int b) &#123; int c = 1; while (b) &#123; if (b &amp; 1) c = mul(c, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return c;&#125;constexpr const int maxn = 1 &lt;&lt; 20;int vis[maxn];int solve(long long n, int p) &#123; long long m = -n; while (n) &#123; m += n; n /= p; &#125; return fpow(p, m % (mod - 1));&#125;int main() &#123; vector&lt;int&gt; prime; for (int i = 2; i != maxn; ++i) if (!vis[i]) &#123; prime.push_back(i); for (int j = i + i; j &lt; maxn; j += i) vis[j] = 1; &#125; int x; long long n; cin &gt;&gt; x &gt;&gt; n; int res = 1; for (int p : prime) if (x % p == 0) &#123; res = mul(res, solve(n, p)); for (x /= p; x % p == 0; x /= p); &#125; if (x != 1) res = mul(res, solve(n, x)); cout &lt;&lt; res &lt;&lt; endl;&#125; D. Complete Tripartite题目大意给定一个简单无向图，要求将点划分为恰好$~3~$个非空集合，要求同一集合内的点没有边，不同集合间的点有边。数据范围$~3\\leq n\\leq10^5,~0\\leq m\\leq\\min(3\\cdot10^5,\\frac{n(n-1)}{2})~$。 题解暴力，如果合法的划分（或染色）方案存在，那么与点$~1~$同色的点必然不与$~1~$相邻，而且它们的相邻的点与$~1~$是一样的，把它们染成$~1~$。用std::vector存每个点的邻接表并升序，然后直接暴力判断它们是否一样。可以这样在出现非法之间的复杂度上限是$~O(n+m)~$的。接着考虑未染色的点，再任选一个点染成$~2~$，重复上述操作。同理接着$~3~$。这样的时间复杂度为$~O((n+m)\\log n)~$。这题也可以哈希实现，将每个点的邻接表哈希过后判断是否只有$~3~$个哈希值即可，注意不能有空邻接表。这样的时间复杂度为$~O(n+m)~$。 代码（非哈希）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int maxn = 1 &lt;&lt; 17;vector&lt;int&gt; adj[maxn];int col[maxn], adj1[maxn], adjr[maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; for (int u = 1; u &lt;= n; ++u) sort(adj[u].begin(), adj[u].end()); for (int u : adj[1]) adj1[u] = 1; col[1] = 1; vector&lt;int&gt; node1; for (int u = 2; u &lt;= n; ++u) &#123; if (adj1[u]) &#123; node1.push_back(u); &#125; else &#123; col[u] = 1; if (adj[1] != adj[u]) return cout &lt;&lt; -1 &lt;&lt; endl, 0; &#125; &#125; if (int(node1.size()) &lt; 2) return cout &lt;&lt; -1 &lt;&lt; endl, 0; int r = node1[0]; for (int u : adj[r]) adjr[u] = 1; col[r] = 2; vector&lt;int&gt; node2; for (int i = 1; i != int(node1.size()); ++i) &#123; int u = node1[i]; if (adjr[u]) &#123; node2.push_back(u); &#125; else &#123; col[u] = 2; if (adj[r] != adj[u]) return cout &lt;&lt; -1 &lt;&lt; endl, 0; &#125; &#125; if (node2.empty()) return cout &lt;&lt; -1 &lt;&lt; endl, 0; for (int i = 1; i != int(node2.size()); ++i) if (adj[node2[0]] != adj[node2[i]]) return cout &lt;&lt; -1 &lt;&lt; endl, 0; for (int u : node2) col[u] = 3; for (int u = 1; u &lt;= n; ++u) cout &lt;&lt; col[u] &lt;&lt; (u == n ? '\\n' : ' ');&#125; 代码（哈希）1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long u64;mt19937_64 rng64(time(nullptr));constexpr const int maxn = 1 &lt;&lt; 17;u64 val[maxn], adj[maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); for (int i = 0; i != maxn; ++i) val[i] = rng64(); int n, m; cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u] ^= val[v]; adj[v] ^= val[u]; &#125; vector&lt;u64&gt; hashes; for (int u = 1; u &lt;= n; ++u) hashes.push_back(adj[u]); sort(hashes.begin(), hashes.end()); hashes.resize(unique(hashes.begin(), hashes.end()) - hashes.begin()); if (int(hashes.size()) != 3 || !hashes.front()) return cout &lt;&lt; -1 &lt;&lt; endl, 0; map&lt;u64, int&gt; name; for (int i = 0; i != 3; ++i) name[hashes[i]] = i + 1; for (int u = 1; u &lt;= n; ++u) cout &lt;&lt; name[adj[u]] &lt;&lt; \" \\n\"[u == n];&#125; E. Another Filling the Grid题目大意在$~n\\times n~$的表格上填$~1~$到$~k~$的整数使得每行每列的最小值都是$~1~$，计算有多少方案。数据范围$~1\\leq n\\leq250,~1\\leq k\\leq10^9~$。 题解考虑动态规划。记$~dp(m,i)~$表示已经考虑了前$~m~$行，每行的最小值都是$~1~$，且恰好已有$~i~$列的最小值都是$~1~$。于是答案为$~dp(n,n)~$，且$~dp(1,i)=\\binom{n}{i}\\cdot(k-1)^{n-i}~$。枚举之前所有行中已经有$~j\\in[1,i]~$列的最小值已经是$~1~$，注意到当$~i=j~$时还需要保证本行要出现一次$~1~$，于是有状态转移式 dp(m,i)=dp(m-1,i)\\cdot(k^i-(k-1)^i)\\cdot(k-1)^{n-i}+\\sum_{j=1}^{i-1}dp(m-1,j)\\cdot\\binom{n-j}{i-j}\\cdot k^j\\cdot(k-1)^{n-i}时间复杂度为$~O(n^3)~$。事实上，考虑容斥，可以得出答案式为 \\sum_{i=0}^{n}\\sum_{j=0}^{n}(-1)^{i+j}\\binom{n}{i}\\binom{n}{j}k^{n^2-n(i+j)+ij}(k-1)^{n(i+j)-ij}预处理幂指数的话，这个式子的复杂度可以优化至$~O(n^2)~$。更进一步，考虑二项式展开，有 \\begin{aligned}&(k^{n-i}-(k-1)^{n-i})^nk^{-n(n-i)}\\\\ =&\\left(1-\\left(\\frac{k-1}{k}\\right)^{n-i}\\right)^n\\\\ =&\\sum_{j=0}^{n}\\binom{n}{j}\\left(-\\left(\\frac{k-1}{k}\\right)^{n-i}\\right)^j\\\\ =&\\sum_{j=0}^{n}(-1)^j\\binom{n}{j}k^{-nj+ij}(k-1)^{nj-ij}\\\\ \\end{aligned}于是答案式化简为 \\sum_{i=0}^{n}(-1)^i\\binom{n}{i}(k^{n-i}(k-1)^i-(k-1)^n)^n这样总时间复杂度为$~O(n\\log n)~$。 代码（$~O(n^3)~$）123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int mod = 1000000007;constexpr int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;constexpr int sub(int a, int b) &#123; return a &lt; b ? a - b + mod : a - b; &#125;constexpr int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;template&lt;typename... T&gt; int mul(int a, int b, T... c) &#123; return mul(mul(a, b), c...); &#125;constexpr const int maxn = 256;int dp[maxn][maxn], C[maxn][maxn], ap[maxn], bp[maxn];int main() &#123; for (int i = 0; i != maxn; ++i) C[i][0] = C[0][i] = 1; for (int i = 1; i != maxn; ++i) for (int j = 1; j != maxn; ++j) C[i][j] = add(C[i - 1][j], C[i][j - 1]); int n, a; cin &gt;&gt; n &gt;&gt; a; ap[0] = bp[0] = 1; for (int i = 1; i != maxn; ++i) ap[i] = mul(ap[i - 1], a), bp[i] = mul(bp[i - 1], a - 1); for (int i = 1; i &lt;= n; ++i) dp[1][i] = mul(C[n - i][i], bp[n - i]); for (int i = 2; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int k = 1; k &lt;= j; ++k) dp[i][j] = add(dp[i][j], mul(dp[i - 1][k], C[n - j][j - k], sub(ap[k], j == k ? bp[j] : 0), bp[n - j])); cout &lt;&lt; dp[n][n] &lt;&lt; endl;&#125; 代码（$~O(n\\log n)~$）123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int mod = 1000000007;constexpr int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;constexpr int sub(int a, int b) &#123; return a &lt; b ? a - b + mod : a - b; &#125;constexpr int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;template&lt;typename... T&gt; int mul(int a, int b, T... c) &#123; return mul(mul(a, b), c...); &#125;int fpow(int a, int b) &#123; int c = 1; while (b) &#123; if (b &amp; 1) c = mul(c, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return c;&#125;constexpr const int maxn = 256;int C[maxn][maxn];int main() &#123; for (int i = 0; i != maxn; ++i) C[i][0] = C[0][i] = 1; for (int i = 1; i != maxn; ++i) for (int j = 1; j != maxn; ++j) C[i][j] = add(C[i - 1][j], C[i][j - 1]); int n, k; cin &gt;&gt; n &gt;&gt; k; int res = 0; for (int i = 0; i &lt;= n; ++i) res = add(res, mul(i &amp; 1 ? mod - 1 : 1, C[n - i][i], fpow(sub(mul(fpow(k, n - i), fpow(k - 1, i)), fpow(k - 1, n)), n))); cout &lt;&lt; res &lt;&lt; endl;&#125; F. One Node is Gone题目大意给定一棵$~2^n-2~$个节点的树，判断它是否由一棵完全二叉树扣去一个非根节点$~u~$后，将$~u~$的儿子（如果有）接在$~u~$的父亲形成。输出所有可能的扣点方案里$~u~$的父亲编号。数据范围$~2\\leq n\\leq17~$。 题解首先抠出原完全二叉树的直径。方法是两遍$~\\rm DFS~$，第一遍任选根节点然后找出最深叶节点，第二遍以第一遍的最远叶节点为根，通向最深叶节点的路径就是直径。分类讨论。如果直径有奇数个点，那么如果方案存在，直径长度必为$~2n-1~$，且中点就是根，答案最多为$~1~$。此时对于所有非叶节点，如果儿子数不为$~2~$，那么儿子数必为$~1~$或$~3~$，且这样的点有且仅有$~1~$个，它就是答案。这样可以确定这棵树可以由一棵二叉树形成，要确定是棵完全二叉树，只需要判断对于答案点到根的路径上的所有节点对应子树的大小是否形如$~2^k-2~$，且其它节点对应子树的大小形如$~2^k-1~$。如果直径有偶数个点，那么中间两个点就是答案（如果合法）。合法性等价与就是这两个点分别对应的两个子图是否都是以它们为根的完全二叉树，判断过程与前面同理。 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int maxn = 1 &lt;&lt; 17;vector&lt;int&gt; adj[maxn], son[maxn];int dep[maxn], par[maxn], siz[maxn], tor[maxn];void game_over() &#123; cout &lt;&lt; 0 &lt;&lt; endl; exit(0); &#125;bool full(int x) &#123; return x + 1 == (x + 1 &amp; ~x); &#125;int dfs(int u, int p) &#123; dep[u] = dep[p] + 1; par[u] = p; int ret = u; for (int v : adj[u]) if (v != p) &#123; int tmp = dfs(v, u); if (dep[tmp] &gt; dep[ret]) ret = tmp; &#125; return ret;&#125;int odd(int u, int p) &#123; par[u] = p; for (int v : adj[u]) if (v != p) son[u].push_back(v); for (int v : son[u]) siz[u] += odd(v, u); return ++siz[u];&#125;int even(int u, int p) &#123; int son = 0; siz[u] = 0; for (int v : adj[u]) if (v != p) &#123; ++son; siz[u] += even(v, u); &#125; ++siz[u]; if (son &amp;&amp; son != 2 || !full(siz[u])) game_over(); return siz[u];&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int m = (1 &lt;&lt; n) - 3; m; --m) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; adj[a].push_back(b); adj[b].push_back(a); &#125; int nn = (1 &lt;&lt; n) - 2; for (int u = 1; u &lt;= nn; ++u) if (int(adj[u].size()) &gt; 4) game_over(); int l = dfs(1, 0); int r = dfs(l, 0); vector&lt;int&gt; diam; for (int u = r; u; u = par[u]) diam.push_back(u); int k = diam.size(); vector&lt;int&gt; res; if (k &amp; 1) &#123; if (k != n + n - 1) game_over(); int r = diam[k / 2]; odd(r, 0); vector&lt;int&gt; res; for (int u = 1; u &lt;= nn; ++u) if (!son[u].empty() &amp;&amp; int(son[u].size()) != 2) res.push_back(u); if (int(res.size()) != 1) game_over(); int x = res[0]; if (int(son[x].size()) != 1 &amp;&amp; int(son[x].size()) != 3) game_over(); for (int u = x; u; u = par[u]) tor[u] = 1; for (int u = 1; u &lt;= nn; ++u) if (tor[u] &amp;&amp; !full(siz[u] + 1) || !tor[u] &amp;&amp; !full(siz[u])) game_over(); cout &lt;&lt; \"1\\n\" &lt;&lt; x &lt;&lt; endl; &#125; else &#123; int x = diam[k / 2]; int y = diam[k / 2 - 1]; even(x, y); even(y, x); if (x &gt; y) swap(x, y); cout &lt;&lt; \"2\\n\" &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 583 (based on Olympiad of Metropolises) (div. 1 + div. 2)","slug":"Codeforces Round 583 (based on Olympiad of Metropolises) (div. 1 + div. 2)","date":"2019-09-05T12:12:19.156Z","updated":"2019-09-05T12:23:20.018Z","comments":true,"path":"2019/09/05/Codeforces Round 583 (based on Olympiad of Metropolises) (div. 1 + div. 2)/","link":"","permalink":"http://yoursite.com/2019/09/05/Codeforces Round 583 (based on Olympiad of Metropolises) (div. 1 + div. 2)/","excerpt":"","text":"Codeforces Round #583 (Div. 1 + Div. 2, based on Olympiad of Metropolises) A. Optimal Currency Exchange题目大意水题。 题解水题。 代码1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, d, e; cin &gt;&gt; n &gt;&gt; d &gt;&gt; e; e *= 5; int res = n; for (int x = 0; x &lt;= n; x += e) res = min(res, (n - x) % d); cout &lt;&lt; res &lt;&lt; endl;&#125; B. Badges题目大意水题。 题解水题。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int b, g, n; cin &gt;&gt; b &gt;&gt; g &gt;&gt; n; cout &lt;&lt; min(b, n) + min(g, n) - n + 1 &lt;&lt; endl;&#125; C. Bad Sequence题目大意给定一个括号序列，问是否能至多移动一个括号使得序列合法。 题解合法当且仅当左括号数量等于右括号数量，且前缀和的最小值大于等于$~-1~$。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; string s; cin &gt;&gt; n &gt;&gt; s; if (count(s.begin(), s.end(), '(') != count(s.begin(), s.end(), ')')) return cout &lt;&lt; \"No\" &lt;&lt; endl, 0; int low = 0, pre = 0; for (char ch : s) low = min(low, ch == '(' ? ++pre : --pre); cout &lt;&lt; (low &lt; -1 ? \"No\" : \"Yes\") &lt;&lt; endl;&#125; D. Treasure Island题目大意一个$~n\\times m~$的网格图，要从$~(1,1)~$走到$~(n,m)~$，且只能从$~(x,y)~$走向$~(x+1,y)~$或者$~(x,y+1)~$。已经有若干方格不能经过，问最多还需要让多少个方格禁止使得不能从$~(1,1)~$走到$~(n,m)~$，起点和终点不能被禁止。数据范围$~3\\leq n\\cdot m\\leq1000000~$。 题解不难发现如果$~(1,2)~$和$~(2,1)~$都被禁止的话即可达到要求，所以答案只能是$~0,1,2~$。假设$~(x,y)~$是某条合法路径上的点，那么由规则，他必须处于第$~x+y-1~$步。于是只要判断第$~1,2,\\dots,n+m-2~$步上分别有多少个合法点，然后取最小值即可。一个点是合法点当且仅当它能从某个合法点转移得到。总时间复杂度为$~O(nm)~$。 代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;string&gt; maze(n); for (auto&amp; row : maze) cin &gt;&gt; row; vector&lt;int&gt; cnt(n + m - 1); for (int i = n - 1; ~i; --i) for (int j = m - 1; ~j; --j) if ((i != n - 1 || j != m - 1) &amp;&amp; maze[i][j] == '.') &#123; maze[i][j] = '#'; if (i != n - 1 &amp;&amp; maze[i + 1][j] == '.') maze[i][j] = '.'; if (j != m - 1 &amp;&amp; maze[i][j + 1] == '.') maze[i][j] = '.'; &#125; for (int i = 0; i != n; ++i) for (int j = !i; j != m; ++j) if (maze[i][j] == '.') &#123; maze[i][j] = '#'; if (i &amp;&amp; maze[i - 1][j] == '.') maze[i][j] = '.'; if (j &amp;&amp; maze[i][j - 1] == '.') maze[i][j] = '.'; if (maze[i][j] == '.') ++cnt[i + j]; &#125; cnt.front() = cnt.back() = 2; cout &lt;&lt; *min_element(cnt.begin(), cnt.end()) &lt;&lt; endl;&#125; E. Petya and Construction Set题目大意给定$~n~$个整数$~d_1,d_2,\\dots,d_n~$，要求构造出一棵大小为$~2n~$的树使得对于$~i=1,2,\\dots,n~$，节点$~2i-1~$和$~2i~$的距离为$~d_i~$。数据范围$~1\\leq n\\leq100000,~1\\leq d\\leq n~$。 题解先将所有的偶数点连成一条链，最左边的点对应的$~d~$为最大值，最右边的点对应的$~d~$为次大值，次左边的点对应的$~d~$为第$~3~$大值……。然后再根据$~d~$从大到小把奇数点接在链上，左边的偶数点对应的奇数点接在右边，右边的偶数点对应的奇数点接在左边。如果当前的奇数点接在链的左端点，则它变成新的左端点，右端点同理。由于$~d\\leq n~$，这样的合法构造是一定存在的。 代码123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int maxn = 1 &lt;&lt; 17;int d[maxn], p[maxn], chain[maxn &lt;&lt; 2], pos[maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; d[i]; iota(p + 1, p + n + 1, 1); sort(p + 1, p + n + 1, [] (int x, int y) -&gt; bool &#123; return d[x] &gt; d[y]; &#125;); vector&lt;pair&lt;int, int&gt;&gt; res; for (int i = 1; i &lt;= n; ++i) pos[i] = i &amp; 1 ? i + 1 &gt;&gt; 1 : n + 1 - (i &gt;&gt; 1); for (int i = 1; i &lt;= n; ++i) chain[n + pos[i]] = p[i] &lt;&lt; 1; for (int i = 1; i != n; ++i) res.emplace_back(chain[n + i], chain[n + i + 1]); for (int i = 1, l = n + 1, r = n + n; i &lt;= n; ++i) &#123; int j = pos[i], k = chain[n + j] &gt;&gt; 1, cur = i &amp; 1 ? n + j + d[k] - 1 : n + j - d[k] + 1; res.emplace_back(chain[n + j] - 1, chain[cur]); if (cur == l) chain[--l] = chain[n + j] - 1; if (cur == r) chain[++r] = chain[n + j] - 1; &#125; for (const auto&amp; ans : res) cout &lt;&lt; ans.first &lt;&lt; ' ' &lt;&lt; ans.second &lt;&lt; endl;&#125; F. Employment题目大意在长度为$~m~$的环上有$~n~$个$~x~$点$~x_1,x_2,\\dots,x_n~$和$~n~$个$~y~$点$~y_1,y_2,\\dots,y_n~$。要求算出一个一一对应关系$~p_1,p_2,\\dots,p_n~$使得$~x_i~$对应$~y_{p_i}~$，这$~n~$对$~(x_i,y_{p_i})~$之间的距离之和最小。输出距离之和的最小值和$~p_1,p_2,\\dots,p_n~$。数据范围$~1\\leq m\\leq10^9,~1\\leq n\\leq200000~$。 题解先对$~x_1,x_2,\\dots,x_n~$和$~y_1,y_2,\\dots,y_n~$升序，不难发现此时最优的对应关系可以由将$~y_1,y_2,\\dots,y_n~$循环平移后再与$~x_1,x_2,\\dots,x_n~$一一对应得到。如果暴力的计算每一种循环平移距离对应的答案值，复杂度是$~O(n^2)~$的，下面考虑优化。记$~f(x,y)~$表示$~x~$与$~y~$的距离，则$~f~$的取值只可能是$~x-y,~y-x,~m+x-y,~m-x+y~$之一。对于一个固定的$~x_i~$，由于$~y_1,y_2,\\dots,y_n~$已经升序，则上述$~4~$种取值恰好对应$~y~$序列的$~4~$个不交区间，即对应$~4~$个不交的循环平移量区间。对于每个$~y_i~$也同理，然后将$~m~$的情况交给$~x~$，这样就只用做$~8n~$次区间修改即可处理好每种平移距离量对应的答案值。总时间复杂度为$~O(n\\log n)~$，当然也可以通过基数排序和$~4~$指针等优化使时间复杂度降为$~O(n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int maxn = 1 &lt;&lt; 18;pair&lt;int, int&gt; a[maxn], b[maxn];long long c[maxn];int res[maxn];void modify(const pair&lt;int, int&gt;* arr, int i, int l, int r, int x, int n, int op) &#123; l = lower_bound(arr, arr + n, pair&lt;int, int&gt;(l, 0)) - arr; r = lower_bound(arr, arr + n, pair&lt;int, int&gt;(r, 0)) - arr - 1; if (l &gt; r) return; if (op) &#123; swap(l, r); l = i - l; r = i - r; &#125; else &#123; l -= i; r -= i; &#125; if (l &lt; 0 &amp;&amp; r &lt; 0) &#123; c[n + l] += x; c[n + r + 1] -= x; &#125; else if (l &gt;= 0 &amp;&amp; r &gt;= 0) &#123; c[l] += x; c[r + 1] -= x; &#125; else &#123; c[n + l] += x; c[0] += x; c[r + 1] -= x; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int m, n; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i != n; ++i) cin &gt;&gt; a[i].first, a[i].second = i; for (int i = 0; i != n; ++i) cin &gt;&gt; b[i].first, b[i].second = i; sort(a, a + n); sort(b, b + n); int k = m &gt;&gt; 1; for (int i = 0; i != n; ++i) &#123; modify(b, i, 0, a[i].first - (m - 1 &gt;&gt; 1), -a[i].first + m, n, 0); modify(b, i, a[i].first - (m - 1 &gt;&gt; 1), a[i].first, a[i].first, n, 0); modify(b, i, a[i].first, a[i].first + (m + 1 &gt;&gt; 1), -a[i].first, n, 0); modify(b, i, a[i].first + (m + 1 &gt;&gt; 1), INT_MAX, a[i].first + m, n, 0); &#125; for (int i = 0; i != n; ++i) &#123; modify(a, i, 0, b[i].first - (m - 1 &gt;&gt; 1), -b[i].first, n, 1); modify(a, i, b[i].first - (m - 1 &gt;&gt; 1), b[i].first + 1, b[i].first, n, 1); modify(a, i, b[i].first + 1, b[i].first + (m + 1 &gt;&gt; 1), -b[i].first, n, 1); modify(a, i, b[i].first + (m + 1 &gt;&gt; 1), INT_MAX, b[i].first, n, 1); &#125; for (int i = 1; i != n; ++i) c[i] += c[i - 1]; int p = min_element(c, c + n) - c; for (int i = 0; i != n; ++i) res[a[i].second] = b[(i + p) % n].second + 1; cout &lt;&lt; c[p] &lt;&lt; endl &lt;&lt; res[0]; for (int i = 1; i != n; ++i) cout &lt;&lt; ' ' &lt;&lt; res[i]; cout &lt;&lt; endl;&#125; G. Feeling Good题目大意有个$~n\\times m~$的$~01~$矩阵，初始全为$~0~$。每次操作将第$~a~$行的第$~l~$至$~r~$列翻转，并计算是否存在$~1\\leq x_1&lt; x_2\\leq n,~1\\leq y_1&lt; y_2\\leq m~$，使得$~(x_1,y_1)~$与$~(x_2,y_2)~$一样，$(x_1,y_2)~$与$~(x_2,y_1)~$一样，但这$~4~$个不完全一样。输出坐标或者不存在。数据范围$~1\\leq n,m\\leq2000,~1\\leq q\\leq500000~$。 题解用std::bitset&lt;2048&gt;来储存每行的信息，这样单次修改操作的时间复杂度为$~O(\\frac{m}{64})~$。对于答案的存在性，考虑任意两行的$~1~$所构成的集合$~A_i~$和$~A_j~$，如果$~A_i\\not\\subset A_j~$且$~A_j\\not\\subset A_i~$，则第$~i~$行和第$~j~$行存在答案，反之若对于任意$~i\\not=j~$，必有$~A_i\\subset A_j~$或$~A_j\\subset A_i~$，则答案不存在。考虑将这些$~A~$根据集合大小排序，则答案不存在当且仅当对任意相邻的$~A_i~$和$~A_j~$，必有$~A_i\\subset A_j~$或$~A_j\\subset A_i~$。由于每次修改只会修改一个$~A~$，那么用std::set来维护这些$~A~$，每次修改只考虑修改前的前驱和后继，以及修改后的前驱和后继。对于答案坐标的计算，可以使用bitset::_Find_first函数，最后总时间复杂度为$~O(q(\\log n+\\frac{m}{64}))~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int maxn = 2048;typedef bitset&lt;maxn&gt; bit2048;typedef pair&lt;int, int&gt; pii;bit2048 mask[maxn], row[maxn];int cnt[maxn];pii res[maxn][maxn];bool check(int a, int b) &#123; if (!~a || !~b) return false; bit2048 cap = row[a] &amp; row[b]; cap[maxn - 1] = 1; res[a][b] = pii((row[a] ^ cap)._Find_first(), (row[b] ^ cap)._Find_first()); return res[a][b].first != maxn - 1;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); for (int i = 1; i != maxn; ++i) &#123; mask[i] = mask[i - 1]; mask[i][i - 1] = 1; &#125; int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; set&lt;pii&gt; rows, good; for (int i = 1; i &lt;= n; ++i) rows.emplace(0, i); rows.emplace(-1, -1); rows.emplace(m + 1, -1); while (q--) &#123; int a, l, r; cin &gt;&gt; a &gt;&gt; l &gt;&gt; r; set&lt;pii&gt;::iterator ite, lef, rig; ite = rows.find(pii(cnt[a], a)); lef = prev(ite); rig = next(ite); good.erase(pii(lef-&gt;second, ite-&gt;second)); good.erase(pii(ite-&gt;second, rig-&gt;second)); if (check(lef-&gt;second, rig-&gt;second)) good.emplace(lef-&gt;second, rig-&gt;second); rows.erase(ite); row[a] ^= mask[r + 1]; row[a] ^= mask[l]; cnt[a] = row[a].count(); rows.emplace(cnt[a], a); ite = rows.find(pii(cnt[a], a)); lef = prev(ite); rig = next(ite); good.erase(pii(lef-&gt;second, rig-&gt;second)); if (check(lef-&gt;second, ite-&gt;second)) good.emplace(lef-&gt;second, ite-&gt;second); if (check(ite-&gt;second, rig-&gt;second)) good.emplace(ite-&gt;second, rig-&gt;second); if (good.empty()) &#123; cout &lt;&lt; \"-1\\n\"; &#125; else &#123; int a = good.begin()-&gt;first, b = good.begin()-&gt;second; int c = res[a][b].first, d = res[a][b].second; if (a &gt; b) swap(a, b); if (c &gt; d) swap(c, d); cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; c &lt;&lt; ' ' &lt;&lt; b &lt;&lt; ' ' &lt;&lt; d &lt;&lt; '\\n'; &#125; &#125;&#125; H. Tiles Placement题目大意给定一棵树，要求对所有节点$~k~$染色，使得任意一条长度为$~k~$的路径异色，输出任意染色方案或者不存在。数据范围$~2\\leq k\\leq n\\leq200000~$。 题解对于$~k=2~$的情况，染色方法是显然的。下面只考虑$~k\\geq3~$的情况。考虑$~3~$条长度为$~k~$的不同路径，如果它们是由一个节点引出的$~3~$条不同的链分别两两组合而成的，则显然不存在合法的$~k~$染色，同时记这个点为非法点。考虑这棵树的直径$~u_1,u_2,\\dots,u_d~$，其中$~d~$为这棵树的直径长度。先对它们依次染色为$~1,2,\\dots,k,1,2,\\dots,k,1,2,\\dots~$。将链扣去后会剩下一棵森林，下面对森林的每棵子树染色。假设当前子树的根节点$~r~$接在直径的$~u_i~$节点上，且它的深度为$~l~$，接下来判断$~u_i~$是否为非法点。注意到树直径的性质，必有$~l\\leq i-1,~l\\leq n-i~$，此时合法性等价于$~l+\\min(i-1,n-i)&lt; k~$。且由直径的这个性质，如果$~u_i~$合法，则$~u_i~$所接上的以$~r~$为根的子树上的所有节点也是合法的，直接对这个子树染色即可，染色方向由$~i-1~$和$~n-i~$的大小关系决定。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;constexpr const int maxn = 1 &lt;&lt; 18;int par[maxn], diam[maxn], len, vis[maxn], col[maxn], k;vector&lt;int&gt; adj[maxn];pii DFS1(int u, int p) &#123; pii ret; for (int v : adj[u]) if (v != p) ret = max(ret, DFS1(v, u)); if (!ret.second) return pii(1, u); ++ret.first; return ret;&#125;void DFS2(int u, int p) &#123; par[u] = p; for (int v : adj[u]) if (v != p) DFS2(v, u);&#125;void draw1(int u, int p) &#123; col[u] = col[p] ^ 1; for (int v : adj[u]) if (v != p) draw1(v, u);&#125;int draw2(int u, int p, int e) &#123; vis[u] = 1; col[u] = col[p] + e; if (col[u] &gt; k) col[u] = 1; if (col[u] &lt; 1) col[u] = k; int ret = 0; for (int v : adj[u]) if (!vis[v]) ret = max(ret, draw2(v, u, e)); return ret + 1;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i != n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; if (k == 2) &#123; draw1(1, 0); cout &lt;&lt; \"Yes\" &lt;&lt; endl; for (int u = 1; u != n; ++u) cout &lt;&lt; col[u] + 1 &lt;&lt; endl; cout &lt;&lt; col[n] + 1 &lt;&lt; endl; return 0; &#125; int L = DFS1(1, 0).second; int R = DFS1(L, 0).second; DFS2(R, R); for (int u = L; par[u] != u; u = par[u]) vis[diam[++len] = u] = 1; vis[diam[++len] = R] = 1; for (int i = 1; i &lt;= len; ++i) &#123; int u = diam[i]; col[u] = (i - 1) % k + 1; for (int v : adj[u]) if (!vis[v]) &#123; int l = draw2(v, u, i + i &gt; len ? 1 : -1); if (l + min(i, len - i + 1) &gt;= k) return cout &lt;&lt; \"No\" &lt;&lt; endl, 0; &#125; &#125; cout &lt;&lt; \"Yes\" &lt;&lt; endl; for (int u = 1; u != n; ++u) cout &lt;&lt; col[u] &lt;&lt; ' '; cout &lt;&lt; col[n] &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"2019暑假牛客多校八","slug":"2019暑假牛客多校八","date":"2019-08-12T12:48:02.654Z","updated":"2019-08-12T12:48:15.033Z","comments":true,"path":"2019/08/12/2019暑假牛客多校八/","link":"","permalink":"http://yoursite.com/2019/08/12/2019暑假牛客多校八/","excerpt":"","text":"2019牛客暑期多校训练营（第八场） A. All-one Matrices题目大意给定一个$~01~$矩阵，计算极大全$~1~$子矩阵数量。数据范围$~1\\leq n,m\\leq3000~$。 题解枚举下边界，考虑只留下上半部分的且下方为下边界的极全$~1~$大子矩阵。由于此时考虑的极大全$~1~$子矩阵下方已经确定，因此只需要再确定左右端点，就能确定最上方的位置，所以每个当前子问题下的极大全$~1~$子矩阵等价于一个区间。注意到这些区间之间的关系要么相离，要么包含，因此可以用一个单调栈来维护，入栈相当于左端点，出栈相当于右端点。然后考虑当前子问题下找出的极大全$~1~$子矩阵是否在全局也是极大的。若不是极大的，那么等价于下方以下至少还有一层$~1~$，因此只需要对于相邻两层的区间计算，上层的区间如果也在下层出现，则筛去即可。总时间复杂度为$~O(nm)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int maxn = 3072;char matrix[maxn][maxn];int h[maxn];vector&lt;int&gt; r[maxn][maxn];int same(const vector&lt;int&gt;&amp; v1, const vector&lt;int&gt;&amp; v2) &#123; int ret = 0; auto ite1 = v1.begin(), ite2 = v2.begin(); while (ite1 != v1.end() &amp;&amp; ite2 != v2.end()) &#123; int mi = min(*ite1, *ite2); if (*ite1 == *ite2) ++ret; if (*ite1 == mi) ++ite1; if (*ite2 == mi) ++ite2; &#125; return ret;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; int res = 0; for (int i = 0; i != n; ++i) &#123; cin &gt;&gt; matrix[i]; vector&lt;pair&lt;int, int&gt;&gt; stack; for (int j = 0; j &lt;= m; ++j) &#123; h[j] = matrix[i][j] == '1' ? h[j] + 1 : 0; int k = j; while (!stack.empty() &amp;&amp; stack.back().first &gt; h[j]) &#123; r[i][k = stack.back().second].push_back(j); ++res; stack.pop_back(); &#125; if (h[j] &amp;&amp; (stack.empty() || stack.back().first != h[j])) stack.emplace_back(h[j], k); &#125; if (i) &#123; for (int j = 0; j != m; ++j) res -= same(r[i - 1][j], r[i][j]); &#125; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; B. Beauty Values题目大意水题。 题解水题。 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int maxn = 1 &lt;&lt; 17;vector&lt;int&gt; pos[maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; int a; cin &gt;&gt; a; pos[a].push_back(i); &#125; long long res = 0; for (int i = 1; i &lt;= n; ++i) if (!pos[i].empty()) &#123; res += 1LL * pos[i][0] * (n - pos[i][0] + 1); for (int j = 1; j != int(pos[i].size()); ++j) res += 1LL * (pos[i][j] - pos[i][j - 1]) * (n - pos[i][j] + 1); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; C. CDMA题目大意水题。 题解水题。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int a[1024][1024];int main() &#123; a[0][0] = a[0][1] = a[1][0] = 1; a[1][1] = -1; for (int n = 2; n != 1024; n &lt;&lt;= 1) &#123; for (int i = 0; i != n; ++i) for (int j = 0; j != n; ++j) &#123; a[i ][j + n] = a[i][j]; a[i + n][j ] = a[i][j]; a[i + n][j + n] = -a[i][j]; &#125; &#125; int m; cin &gt;&gt; m; for (int i = 0; i != m; ++i) for (int j = 0; j != m; ++j) cout &lt;&lt; a[i][j] &lt;&lt; (j == m - 1 ? '\\n' : ' ');&#125; D. Distance题目大意在$~n\\times m\\times h~$的空间内支持两种操作：添加一个点$~(x,y,z)~$或计算与以有点与点$~(x,y,z)~$最小曼哈顿距离。数据范围$~1\\leq n\\times m\\times h,q\\leq10^5~$。 题解考虑以每次查询的点为中心将大空间划分为$~8~$个部分，那么每个部分里的点到查询点的曼哈顿距离的表达式可以拆去绝对值符号。于是原问题可以拆分为$~8~$个在$~3~$维空间下支持单点插入和前缀或后缀查询最值操作的子问题。注意到空间总大小的数据范围，可以直接建$~8~$棵树状数组维护。总时间复杂度为$~O(q\\log n\\log m\\log h)~$级别的。注意到树状数组的每次操作与$~2~$进制表示下的$~01~$数量有关，以及当$~n=m=q~$时$~\\log n\\log m\\log q~$取最大，所以最坏复杂的不会超过$~O((\\frac{5}{3}\\log_210)^3q)~$，约等于$~O(170q)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int maxn = 1 &lt;&lt; 17;int n, m, h, mh, mh_h;#define lowbit(x) ((x) &amp; -(x))#define pos(x, y, z) (x * mh + y * h + z - mh_h)int bit0[maxn];int bit1[maxn];int bit2[maxn];int bit3[maxn];int bit4[maxn];int bit5[maxn];int bit6[maxn];int bit7[maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(bit0, 0xc0, maxn &lt;&lt; 2); memset(bit1, 0xc0, maxn &lt;&lt; 2); memset(bit2, 0xc0, maxn &lt;&lt; 2); memset(bit3, 0xc0, maxn &lt;&lt; 2); memset(bit4, 0xc0, maxn &lt;&lt; 2); memset(bit5, 0xc0, maxn &lt;&lt; 2); memset(bit6, 0xc0, maxn &lt;&lt; 2); memset(bit7, 0xc0, maxn &lt;&lt; 2); int q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; h &gt;&gt; q; mh = m * h; mh_h = mh + h; while (q--) &#123; int op, x, y, z, w, u; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y &gt;&gt; z; if (op == 1) &#123; w = 0 + x + y + z; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j &lt;= m; j += lowbit(j)) for (int k = z; k &lt;= h; k += lowbit(k)) &#123; int p = pos(i, j, k); bit0[p] = max(bit0[p], w); &#125; w = 0 + x + y - z; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j &lt;= m; j += lowbit(j)) for (int k = z; k; k ^= lowbit(k)) &#123; int p = pos(i, j, k); bit1[p] = max(bit1[p], w); &#125; w = 0 + x - y + z; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j; j ^= lowbit(j)) for (int k = z; k &lt;= h; k += lowbit(k)) &#123; int p = pos(i, j, k); bit2[p] = max(bit2[p], w); &#125; w = 0 + x - y - z; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j; j ^= lowbit(j)) for (int k = z; k; k ^= lowbit(k)) &#123; int p = pos(i, j, k); bit3[p] = max(bit3[p], w); &#125; w = 0 - x + y + z; for (int i = x; i; i ^= lowbit(i)) for (int j = y; j &lt;= m; j += lowbit(j)) for (int k = z; k &lt;= h; k += lowbit(k)) &#123; int p = pos(i, j, k); bit4[p] = max(bit4[p], w); &#125; w = 0 - x + y - z; for (int i = x; i; i ^= lowbit(i)) for (int j = y; j &lt;= m; j += lowbit(j)) for (int k = z; k; k ^= lowbit(k)) &#123; int p = pos(i, j, k); bit5[p] = max(bit5[p], w); &#125; w = 0 - x - y + z; for (int i = x; i; i ^= lowbit(i)) for (int j = y; j; j ^= lowbit(j)) for (int k = z; k &lt;= h; k += lowbit(k)) &#123; int p = pos(i, j, k); bit6[p] = max(bit6[p], w); &#125; w = 0 - x - y - z; for (int i = x; i; i ^= lowbit(i)) for (int j = y; j; j ^= lowbit(j)) for (int k = z; k; k ^= lowbit(k)) &#123; int p = pos(i, j, k); bit7[p] = max(bit7[p], w); &#125; &#125; else &#123; int res = 0x3f3f3f3f; w = 0 + x + y + z; u = 0xc0c0c0c0; for (int i = x; i; i ^= lowbit(i)) for (int j = y; j; j ^= lowbit(j)) for (int k = z; k; k ^= lowbit(k)) &#123; int p = pos(i, j, k); u = max(u, bit0[p]); &#125; res = min(res, w - u); w = 0 + x + y - z; u = 0xc0c0c0c0; for (int i = x; i; i ^= lowbit(i)) for (int j = y; j; j ^= lowbit(j)) for (int k = z; k &lt;= h; k += lowbit(k)) &#123; int p = pos(i, j, k); u = max(u, bit1[p]); &#125; res = min(res, w - u); w = 0 + x - y + z; u = 0xc0c0c0c0; for (int i = x; i; i ^= lowbit(i)) for (int j = y; j &lt;= m; j += lowbit(j)) for (int k = z; k; k ^= lowbit(k)) &#123; int p = pos(i, j, k); u = max(u, bit2[p]); &#125; res = min(res, w - u); w = 0 + x - y - z; u = 0xc0c0c0c0; for (int i = x; i; i ^= lowbit(i)) for (int j = y; j &lt;= m; j += lowbit(j)) for (int k = z; k &lt;= h; k += lowbit(k)) &#123; int p = pos(i, j, k); u = max(u, bit3[p]); &#125; res = min(res, w - u); w = 0 - x + y + z; u = 0xc0c0c0c0; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j; j ^= lowbit(j)) for (int k = z; k; k ^= lowbit(k)) &#123; int p = pos(i, j, k); u = max(u, bit4[p]); &#125; res = min(res, w - u); w = 0 - x + y - z; u = 0xc0c0c0c0; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j; j ^= lowbit(j)) for (int k = z; k &lt;= h; k += lowbit(k)) &#123; int p = pos(i, j, k); u = max(u, bit5[p]); &#125; res = min(res, w - u); w = 0 - x - y + z; u = 0xc0c0c0c0; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j &lt;= m; j += lowbit(j)) for (int k = z; k; k ^= lowbit(k)) &#123; int p = pos(i, j, k); u = max(u, bit6[p]); &#125; res = min(res, w - u); w = 0 - x - y - z; u = 0xc0c0c0c0; for (int i = x; i &lt;= n; i += lowbit(i)) for (int j = y; j &lt;= m; j += lowbit(j)) for (int k = z; k &lt;= h; k += lowbit(k)) &#123; int p = pos(i, j, k); u = max(u, bit7[p]); &#125; res = min(res, w - u); cout &lt;&lt; res &lt;&lt; '\\n'; &#125; &#125;&#125; E. Explorer题目大意给定一个简单无向图，每条边给定一个区间$~[\\,l,r\\,]~$，对于每个当前值$~x~$，当且仅当$~x\\in[\\,l,r\\,]~$这条边才为实边，否则为虚边。问有多少个$~x~$使得点$~1~$与点$~n~$连通。数据范围$~1\\leq n,m\\leq10^5,~1\\leq l\\leq r\\leq10^9~$ 题解先对所有的$~l,r~$离散化，那么离散化后的每个区间里$~x~$的取值不会对图造成变化。如果暴力的维护每个$~x~$在每个区间里点$~1~$和点$~n~$的连通性，时间复杂度为$~O(nm)~$。考虑单个区间下，连通性可以用并查集维护，那么对离散化后的区间建立线段树，每个节点储存在这个区间下需要将多少虚边变为实边。根据线段树的性质，每条边只会放入$~O(\\log m)~$个节点，那么对于每个节点上的边集用std::vector储存，空间复杂度为$~O(m\\log m)~$。在遍历线段树的时候用带撤销并查集维护图的连通块，这样复杂度为$~O(m\\log m\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int maxn = 1 &lt;&lt; 17;int n, m, u[maxn], v[maxn], l[maxn], r[maxn], fa[maxn], rk[maxn], res;vector&lt;int&gt; num, edge[maxn &lt;&lt; 2];vector&lt;pair&lt;int, int&gt;&gt; seg[maxn &lt;&lt; 2];int find(int u) &#123; while (fa[u] != u) u = fa[u]; return u; &#125;void merge(int u, int v, int index) &#123; u = find(u), v = find(v); if (u == v) return; if (rk[u] &lt; rk[v]) swap(u, v); fa[v] = u; if (rk[u] == rk[v]) ++rk[u]; edge[index].push_back(v);&#125;void undo(const vector&lt;int&gt;&amp; vec) &#123; for (int u : vec) fa[u] = u; &#125;#define mid ((begin + end) &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (lson ^ 1)#define LLL begin, mid, lson#define RRR mid, end, rson#define SEG left, rightvoid insert(int begin, int end, int index, int left, int right, int u, int v) &#123; if (begin &gt;= right || end &lt;= left) return; if (begin &gt;= left &amp;&amp; end &lt;= right) &#123; seg[index].emplace_back(u, v); return; &#125; insert(LLL, SEG, u, v); insert(RRR, SEG, u, v);&#125;void dfs(int begin, int end, int index) &#123; for (const auto&amp; e : seg[index]) merge(e.first, e.second, index); if (begin + 1 == end) &#123; if (find(1) == find(n)) res += num[end] - num[begin]; &#125; else &#123; dfs(LLL); dfs(RRR); &#125; undo(edge[index]);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i != m; ++i) &#123; cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; l[i] &gt;&gt; r[i]; num.push_back(l[i]); num.push_back(++r[i]); &#125; sort(num.begin(), num.end()); num.resize(unique(num.begin(), num.end()) - num.begin()); auto pos = [&amp;] (int x) &#123; return lower_bound(num.begin(), num.end(), x) - num.begin(); &#125;; for (int i = 0; i != m; ++i) insert(0, num.size(), 1, pos(l[i]), pos(r[i]), u[i], v[i]); iota(fa, fa + maxn, 0); dfs(0, num.size(), 1); cout &lt;&lt; res &lt;&lt; endl;&#125; F. Flower Dance题目大意给定二维空间下$~n~$个点，问有多少$~4~$元组使得$~1~$个点被另外$~3~$个点构成的非退化三角形完全包含。数据范围$~4\\leq n\\leq1000~$。 题解先枚举中心点，那么剩下的$~3~$元组总量为$~\\binom{n-1}{3}~$。考虑用总量减去非法$~3~$元组数量。对于非法$~3~$元组，那么必存在一条经过中心的的直线使得这$~3~$个点在同一侧。那么以中心点为中心极角排序然后双指针计算非法$~3~$元组即可。注意细节。总时间复杂度为$~O(n^2\\log n)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long i64;struct point &#123; i64 x, y; point(i64 _x = 0, i64 _y = 0): x(_x), y(_y) &#123;&#125; point unit() const &#123; i64 d = __gcd(abs(x), abs(y)); return point(x / d, y / d); &#125; point rev() const &#123; return point(-x, -y); &#125; int quad() const &#123; if (x &gt; 0 &amp;&amp; y &gt;= 0) return 1; if (x &lt;= 0 &amp;&amp; y &gt; 0) return 2; if (x &lt; 0 &amp;&amp; y &lt;= 0) return 3; if (x &gt;= 0 &amp;&amp; y &lt; 0) return 4; return 0; &#125; point operator- (const point&amp; p) const &#123; return point(x - p.x, y - p.y); &#125; i64 operator^ (const point&amp; p) const &#123; return x * p.y - y * p.x; &#125; bool operator&lt; (const point&amp; p) const &#123; return quad() == p.quad() ? (*this ^ p) &gt; 0 : quad() &lt; p.quad(); &#125; bool operator== (const point&amp; p) const &#123; return x == p.x &amp;&amp; y == p.y; &#125;&#125;;istream&amp; operator&gt;&gt; (istream&amp; is, point&amp; p) &#123; return is &gt;&gt; p.x &gt;&gt; p.y; &#125;constexpr int C2(int x) &#123; return x * (x - 1) / 2; &#125;constexpr int C3(int x) &#123; return x * (x - 1) * (x - 2) / 6; &#125;constexpr int maxn = 1 &lt;&lt; 10;point p[maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; const int m = n - 1; for (int i = 0; i != n; ++i) cin &gt;&gt; p[i]; i64 res = 0; for (int i = 0; i != n; ++i) &#123; vector&lt;point&gt; ps; for (int j = 0; j != n; ++j) if (i != j) ps.push_back((p[j] - p[i]).unit()); sort(ps.begin(), ps.end()); res += C3(m); map&lt;point, int&gt; cnt; for (auto&amp; p : ps) ++cnt[p]; for (int i = 0; i != m; ++i) if (!(i &amp;&amp; ps[i] == ps[i - 1])) res += cnt[ps[i]] * C2(cnt[ps[i].rev()]); ps.resize(m &lt;&lt; 1); for (int j = 0; j != m; ++j) ps[j + m] = ps[j]; for (int j = 0, k = 0; j != m; ++j) &#123; while (true) &#123; if (k == j + m) break; if ((ps[j] ^ ps[k]) == 0 &amp;&amp; ps[j] == ps[k] &amp;&amp; k &gt;= m) break; if ((ps[j] ^ ps[k]) &lt; 0) break; ++k; &#125; res -= C2(k - j - 1); &#125; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; G. Gemstones题目大意水题。 题解水题。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); string str; cin &gt;&gt; str; vector&lt;char&gt; stack(str.size()); int size = 0, res = 0; for (char ch : str) &#123; stack[size++] = ch; if (size &gt;= 3 &amp;&amp; stack[size - 1] == stack[size - 2] &amp;&amp; stack[size - 2] == stack[size - 3]) size -= 3, ++res; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; H. How Many Schemes题目大意给定一棵树，每条边上有一个字符集，并给出一些模式串$~t~$。每次查询一对点$~(u,v)~$，在从$~u~$到$~v~$的路径上依顺序在每条边的字符集里选一个字符组成字符串，计算有多少种选择方式使得组成的字符串至少包含$~1~$个模式串。数据范围$~1\\leq n\\leq2500,~1\\leq q\\leq5000,~1\\leq\\sum|\\,t\\,|\\leq40~$。 题解考虑$~\\rm AC~$自动机上$~\\rm DP~$。先对模式串建立$~\\rm AC~$自动机，让终止节点的$~\\rm fail~$和$~\\rm next~$均指向自己。查询时对于树上每个节点，可以看作是一个$~\\sum|\\,t\\,|~$维的向量，第$~i~$维的值表示从点$~u~$到当前点到达$~\\rm AC~$自动机上$~i~$节点的方案数，那么答案就是$~v~$节点对应向量上终止节点维度的值之和。此时每条边，也是就是每个点集，可以看作是一个$~\\sum|\\,t\\,|\\times\\sum|\\,t\\,|~$的转移矩阵，那么询问的答案就是从$~u~$到$~v~$的矩阵乘积再乘上向量$~(1,0,0,\\dots)~$。预处理$~\\rm AC~$自动机和转移矩阵的时间复杂度为$~O(26(\\sum|\\,t\\,|)n)~$。注意到转移矩阵不是对角阵，不满足乘法交换律，所以要分清楚左乘与右乘。如果单纯用倍增维护路径上的矩阵乘积来支持询问操作的话那么预处理和查询的时间复杂度为$~O((\\sum|\\,t\\,|)^3n\\log n)~$和$~O((\\sum|\\,t\\,|)^3q\\log n)~$，会$~\\rm TLE~$。先考虑优化查询，由于是静态查询，因此可以不做矩阵乘矩阵，之作矩阵乘向量，这样时间复杂度降为$~O((\\sum|\\,t\\,|)^2q\\log n)~$。对于预处理，记$~f(u)~$表示点$~u~$的深度在$~2~$进制表示下末尾$~0~$的数量那么只预处理每个节点向上走$~2^0,2^1,\\dots,2^{f(u)}~$步也是足够的，只需要适当调整查询的方式。此时需要预处理的倍增矩阵数量为$~O(\\sum f)~$。然而如果有很多深度为$~1024~$的节点的话这种优化无法降低时间复杂度。考虑先固定一个根节点，然后在根接上一条链，链的另一端为新的根节点。通过$~2~$进制枚举，可以使得对于所有的深度值，模$~2~$余$~1~$的节点数量不少于模$~2~$余$~0~$的节点数量，模$~4~$余$~2~$的节点数量不少于模$~4~$余$~0~$的节点数量，……，模$~2^k~$余$~2^{k-1}~$的节点数量不少于模$~2^k~$余$~0~$的节点数量。此时需要预处理的矩阵数量不超过$~\\sum_{i=1}^{\\infty}\\frac{in}{2^i}=O(n)~$。此时总时间复杂度为$~O(26(\\sum|\\,t\\,|)n+(\\sum|\\,t\\,|)^3n+(\\sum|\\,t\\,|)^2q\\log n)~$。另一种调整根节的的方式就是随机选一个根节点，这样需要预处理的矩阵数量的期望应该还是$~O(n)~$的（猜的，不会证）。不过这样波动会比较大，最后$~10~$次提交只有$~7~$发通过，最快$~\\rm 1726\\,ms~$，限时$~\\rm 3000\\,ms~$。 代码（概率算法）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int mod = 998244353;constexpr int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;constexpr int sub(int a, int b) &#123; return a &lt; b ? a - b + mod : a - b; &#125;constexpr int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;constexpr const int maxt = 41;int mask[maxt];struct tensor &#123; int val[maxt]; tensor(int x = 0) &#123; memset(val, 0, maxt &lt;&lt; 2); for (int i = 0; i != maxt; ++i) val[i] = x; &#125; const int&amp; operator[] (int i) const &#123; return val[i]; &#125; int&amp; operator[] (int i) &#123; return val[i]; &#125; int count() const &#123; int ret = 0; for (int i = 0; i != maxt; ++i) if (mask[i]) ret = add(ret, val[i]); return ret; &#125;&#125;;struct matrix &#123; int val[maxt][maxt]; matrix(int x = 0) &#123; memset(val, 0, maxt * maxt &lt;&lt; 2); for (int i = 0; i != maxt; ++i) val[i][i] = x; &#125; const int* operator[] (int i) const &#123; return val[i]; &#125; int* operator[] (int i) &#123; return val[i]; &#125; matrix operator* (const matrix&amp; mat) const &#123; matrix ret; for (int i = 0; i != maxt; ++i) for (int j = 0; j != maxt; ++j) for (int k = 0; k != maxt; ++k) ret[i][j] = add(ret[i][j], mul(val[i][k], mat[k][j])); return ret; &#125;&#125;;tensor operator* (const matrix&amp; mat, const tensor&amp; vec) &#123; tensor ret; for (int i = 0; i != maxt; ++i) for (int j = 0; j != maxt; ++j) ret[i] = add(ret[i], mul(mat[i][j], vec[j])); return ret;&#125;struct ACAM &#123; constexpr static const int ch_size = 26; int next[maxt][ch_size], end[maxt], fail[maxt], size = 1; void insert(const char* str, int n) &#123; int cur = 0; for (int i = 0; i != n; ++i) &#123; int j = str[i] - 'a'; if (!next[cur][j]) next[cur][j] = size++; cur = next[cur][j]; if (end[cur]) break; &#125; end[cur] = 1; &#125; void build() &#123; queue&lt;int&gt; bfs; for (int i = 0; i != ch_size; ++i) if (next[0][i]) bfs.push(next[0][i]); while (!bfs.empty()) &#123; int cur = bfs.front(); bfs.pop(); if (end[cur] |= end[fail[cur]]) &#123; fill_n(next[cur], ch_size, cur); &#125; else &#123; for (int i = 0; i != ch_size; ++i) &#123; if (next[cur][i]) &#123; fail[next[cur][i]] = next[fail[cur]][i]; bfs.push(next[cur][i]); &#125; else &#123; next[cur][i] = next[fail[cur]][i]; &#125; &#125; &#125; &#125; &#125;&#125;;constexpr const int maxn = 2560;int edge[maxn], dep[maxn], pa[maxn][12], low[maxn];string str[maxn];matrix mat[maxn], dp0[maxn][12], dp1[maxn][12];vector&lt;int&gt; adj[maxn];ACAM acam;void dfs(int u, int p) &#123; if (u != p) &#123; pa[u][0] = p; for (int i = 1; i != 12; ++i) pa[u][i] = pa[pa[u][i - 1]][i - 1]; low[u] = __builtin_ctz(dep[u] = dep[p] + 1); for (int i = 1; i &lt;= low[u]; ++i) &#123; dp0[u][i] = dp0[u][i - 1] * dp0[pa[u][i - 1]][i - 1]; dp1[u][i] = dp1[pa[u][i - 1]][i - 1] * dp1[u][i - 1]; &#125; &#125; else &#123; fill_n(pa[u], 12, u); &#125; for (int e : adj[u]) &#123; int v = edge[e] ^ u; if (v != p) &#123; dp0[v][0] = dp1[v][0] = mat[e]; dfs(v, u); &#125; &#125;&#125;int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); for (int i = 11; ~i; --i) if (dep[pa[u][i]] &gt;= dep[v]) u = pa[u][i]; if (u == v) return u; for (int i = 11; ~i; --i) if (pa[u][i] != pa[v][i]) &#123; u = pa[u][i]; v = pa[v][i]; &#125; return pa[u][0];&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); srand(time(nullptr)); int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i != n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v &gt;&gt; str[i]; edge[i] = u ^ v; adj[u].push_back(i); adj[v].push_back(i); &#125; while (m--) &#123; string pat; cin &gt;&gt; pat; acam.insert(pat.data(), pat.size()); &#125; acam.build(); memcpy(mask, acam.end, maxt &lt;&lt; 2); for (int i = 1; i != n; ++i) for (char ch : str[i]) for (int j = 0; j != maxt; ++j) ++mat[i][acam.next[j][ch - 'a']][j]; int r = rand() % n + 1; dfs(r, r); while (q--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; tensor vec; vec[0] = 1; int f = lca(u, v), df = dep[f]; while (dep[u] != df) for (int i = low[u]; ~i; --i) if (dep[u] - (1 &lt;&lt; i) &gt;= dep[f]) &#123; vec = dp1[u][i] * vec; u = pa[u][i]; break; &#125; vector&lt;matrix *&gt; tmp; while (dep[v] != df) for (int i = low[v]; ~i; --i) if (dep[v] - (1 &lt;&lt; i) &gt;= dep[f]) &#123; tmp.push_back(&amp;dp0[v][i]); v = pa[v][i]; break; &#125; while (!tmp.empty()) &#123; vec = *tmp.back() * vec; tmp.pop_back(); &#125; cout &lt;&lt; vec.count() &lt;&lt; '\\n'; &#125;&#125; I. Inner World题目大意有$~n~$棵树，每棵树初始只有编号为$~1~$的叶子。每次操作将区间$~[\\,l,r\\,]~$树上编号为$~u~$的节点添加一个编号为$~v~$的节点。保证每次操作的$~v~$不相同且一定合法。然后每次询问区间$~[\\,l,r\\,]~$树上编号为$~x~$的节点的子树大小之和，如果没有编号为$~x~$的节点则子树大小记为$~0~$。数据范围$~1\\leq n,m,q\\leq300000~$。 题解由于操作的合法性和所有的$~v~$都不一样，那么可以先根据所有的操作建一棵大树，此时所有位置上的树都是大树的一个子图。对于大树的每个节点，都记录一个区间，就是操作对应的树的区间。将$~\\rm DFS~$序视为一个维度，树的编号视为另一个维度，则询问可以视为在一个$~n\\times m~$的$~01~$矩阵上询问子矩阵之和，且大矩阵满足每行有且仅有连续的一段$~1~$。询问离线然后扫描线加线段树或支持区间修改区间查询的树状数组维护即可。总时间复杂度为$~O((m+q)\\log n)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long i64;constexpr const int maxn = 1 &lt;&lt; 19;vector&lt;int&gt; son[maxn];int dfl[maxn], dfr[maxn], dfs_clock, nod[maxn];void dfs(int u) &#123; dfl[u] = ++dfs_clock; nod[dfs_clock] = u; for (int v : son[u]) dfs(v); dfr[u] = dfs_clock;&#125;struct BIT &#123;#define lowbit(x) ((x) &amp; -(x)) i64 dif[maxn], dii[maxn]; void add_suffix(int p) &#123; for (int i = p; i &lt; maxn; i += lowbit(i)) ++dif[i], dii[i] += p; &#125; void sub_suffix(int p) &#123; for (int i = p; i &lt; maxn; i += lowbit(i)) --dif[i], dii[i] -= p; &#125; void add_segment(int l, int r) &#123; add_suffix(l); sub_suffix(r + 1); &#125; i64 sum_prefix(int p) &#123; i64 ret = 0; for (int i = p; i; i ^= lowbit(i)) ret += dif[i] * p + dif[i] - dii[i]; return ret; &#125; i64 sum_segment(int l, int r) &#123; return sum_prefix(r) - sum_prefix(l - 1); &#125;&#125;;int l[maxn], r[maxn];i64 res[maxn];vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; query[maxn];BIT bit;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; l[1] = 1; r[1] = n; for (int i = 0; i != m; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; son[u].push_back(v); cin &gt;&gt; l[v] &gt;&gt; r[v]; &#125; dfs(1); int q; cin &gt;&gt; q; for (int i = 1; i &lt;= q; ++i) &#123; int x, l, r; cin &gt;&gt; x &gt;&gt; l &gt;&gt; r; query[dfl[x] - 1].emplace_back(-i, make_pair(l, r)); query[dfr[x] ].emplace_back( i, make_pair(l, r)); &#125; for (int i = 1; i &lt;= m + 1; ++i) &#123; bit.add_segment(l[nod[i]], r[nod[i]]); for (const auto&amp; que : query[i]) &#123; i64 temp = bit.sum_segment(que.second.first, que.second.second); que.first &lt; 0 ? res[-que.first] -= temp : res[que.first] += temp; &#125; &#125; for (int i = 1; i &lt;= q; ++i) cout &lt;&lt; res[i] &lt;&lt; '\\n';&#125; J. Just Jump题目大意初始在位置$~0~$，需要跳到位置$~L~$，且每步跳的距离至少为$~d~$。同时有$~m~$个限制，要求第$~t~$步不能跳到位置$~p~$上。计算方案数。数据范围$~1\\leq d\\leq L\\leq10^7,~1\\leq m\\leq3000~$。 题解先考虑没有限制条件的子问题。记$~f(x)~$表示跳到$~x~$的方案数。那么有$~f(x)=\\sum_{i=0}^{x-d}f(i)~$，前缀和优化可以在$~O(L)~$内处理处所有的$~f(0),f(1),\\dots,f(L)~$。考虑限制减去的方案数。对于每对限制$~(t,p)~$，从起点到$~(t,p)~$的方案数为$~\\binom{p-dt+t-1}{t-1}~$，从$~(t,p)~$到终点的方案数为$~f(L-p)~$，根据乘法原理，答案需要减去$~\\binom{p-dt+t-1}{t-1}\\times f(L-p)~$。再根据奇偶容斥，需要加回经过两次限制的方案，再减去经过三次限制的方案，……。对于所有的限制按$~t~$升序，那么对于每个限制，暴力枚举上一个经过的限制，以及已经经过限制的奇偶性，就能得到经过当前限制且已经经过奇数或偶数次限制的方案数。最后对于$~f(L)~$奇偶容斥后即为答案，总时间复杂度为$~O(L+m^2)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int mod = 998244353;constexpr int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;constexpr int sub(int a, int b) &#123; return a &lt; b ? a - b + mod : a - b; &#125;constexpr int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;constexpr int mul(int a, int b, int c) &#123; return mul(a, mul(b, c)); &#125;constexpr const int maxn = 10 &lt;&lt; 20;int inv[maxn], fac[maxn], fiv[maxn];constexpr int C(long long n, int k) &#123; return k &lt; 0 || k &gt; n ? 0 : mul(fac[n], fiv[k], fiv[n - k]); &#125;constexpr const int maxm = 3072;int f[maxn], g[maxn], h[maxm][2], t[maxm], p[maxm];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); inv[0] = inv[1] = fac[0] = fac[1] = fiv[0] = fiv[1] = 1; for (int i = 2; i != maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fac[i] = mul(fac[i - 1], i); fiv[i] = mul(fiv[i - 1], inv[i]); &#125; int L, d, m; cin &gt;&gt; L &gt;&gt; d &gt;&gt; m; f[0] = 1; fill_n(g, d, 1); for (int i = d; i &lt;= L; ++i) g[i] = add(g[i - 1], f[i] = g[i - d]); int res = f[L]; vector&lt;pair&lt;int, int&gt;&gt; attack(m); for (auto&amp; tp : attack) cin &gt;&gt; tp.first &gt;&gt; tp.second; sort(attack.begin(), attack.end()); for (int i = 0; i != m; ++i) t[i] = attack[i].first, p[i] = attack[i].second; for (int i = 0; i != m; ++i) &#123; h[i][0] = C(p[i] - 1LL * d * t[i] + t[i] - 1, t[i] - 1); for (int j = 0; j != i; ++j) if (p[j] &lt; p[i]) &#123; int tt = t[i] - t[j], pp = p[i] - p[j], c = C(pp - 1LL * d * tt + tt - 1, tt - 1); for (int k : &#123; 0, 1 &#125;) h[i][k] = add(h[i][k], mul(h[j][k ^ 1], c)); &#125; res = add(res, mul(sub(h[i][1], h[i][0]), f[L - p[i]])); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[{"name":"多校","slug":"多校","permalink":"http://yoursite.com/tags/多校/"}]},{"title":"2019暑假牛客多校五","slug":"2019暑假牛客多校五","date":"2019-08-06T10:39:50.118Z","updated":"2019-08-06T11:13:06.522Z","comments":true,"path":"2019/08/06/2019暑假牛客多校五/","link":"","permalink":"http://yoursite.com/2019/08/06/2019暑假牛客多校五/","excerpt":"","text":"2019牛客暑期多校训练营（第五场） A. digits 2题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int T; cin &gt;&gt; T; while (T--) &#123; int n; cin &gt;&gt; n; for (int i = 0; i != n; ++i) cout &lt;&lt; n; cout &lt;&lt; endl; &#125;&#125; B. generator 1题目大意求二阶线性递推第$~n~$项。数据范围$~1\\leq n&lt; 10^{10^6}~$。 题解矩阵快速幂。注意到$~n~$是个大整数，因此在$~2~$进制下分解$~n~$做快速幂会$~\\rm TLE~$，考虑$~10~$进制下分解的快速幂，优化做法的时间复杂度为$~O(40\\log n)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned int u32;typedef unsigned long long u64;u32 mod;u32 add(u32 a, u32 b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;u32 sub(u32 a, u32 b) &#123; return a &lt; b ? a - b + mod : a - b; &#125;u32 mul(u32 a, u32 b) &#123; return 1ULL * a * b % mod; &#125;#define loop(i) for (int i : &#123; 0, 1 &#125;)struct matrix &#123; u32 val[2][2]; matrix(u32 x = 0) &#123; memset(val, 0, 16); loop(i) val[i][i] = x; &#125; const u32* operator[] (size_t i) const &#123; return val[i]; &#125; u32* operator[] (size_t i) &#123; return val[i]; &#125; matrix operator* (const matrix&amp; m) const &#123; matrix ret; loop(i) loop(j) loop(k) ret[i][j] = add(ret[i][j], mul(val[i][k], m[k][j])); return ret; &#125; matrix operator^ (int n) const &#123; matrix ret(1), tmp(*this); while (n) &#123; if (n &amp; 1) ret = ret * tmp; tmp = tmp * tmp; n &gt;&gt;= 1; &#125; return ret; &#125;&#125;;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); u32 x0, x1, a, b; string n; cin &gt;&gt; x0 &gt;&gt; x1 &gt;&gt; a &gt;&gt; b &gt;&gt; n &gt;&gt; mod; matrix bas[10], res(1); bas[0] = matrix(1); bas[1][0][0] = a; bas[1][0][1] = b; bas[1][1][0] = 1; for (int i = 2; i != 10; ++i) bas[i] = bas[i - 1] * bas[1]; for (char ch : n) res = (res ^ 10) * bas[ch - '0']; cout &lt;&lt; add(mul(res[1][0], x1), mul(res[1][1], x0)) &lt;&lt; endl;&#125; C. generator 2题目大意给定$~n,x_0,a,b,p~$，序列$~x_0,x_1,\\dots,x_{n-1}~$由$~x_i=(a\\cdot x_{i-1}+b)\\mod p~$生成。询问$~v~$在序列中第一次出现的位置或不存在。数据范围$~T\\leq4,~1\\leq n\\leq10^{18},~0\\leq x_0,a,b&lt; p\\leq10^9+9,~Q\\leq1000~$，且$~p~$是质数。 题解先对平凡情况分类讨论。对于非平凡情况，可以求出$~\\lbrace\\,x\\,\\rbrace~$的通项公式 x_t=(x_0+\\frac{b}{a-1})a^t-\\frac{b}{a-1}由于$~p~$是质数，每次询问就是在域$~\\Bbb Z_{p}~$的乘法群上询问方程 a^t=\\frac{v+\\frac{b}{a-1}}{x_0+\\frac{b}{a-1}}中$~t~$的最小解。对于形如$~a^x=b\\mod p~$的数论方程，朴素的解法是用$~\\rm BSGS~$算法，解当个方程的复杂度为$~O(\\sqrt p\\log p)~$。直接强解$~Q~$个方程显然会$~\\rm TLE~$。考虑到$~\\rm BSGS~$的复杂度组成为$~O((b+g)\\cdot\\log b)~$，其中$~b~$和$~g~$是$~\\text{baby step}~$和$~\\text{giant step}~$的大小，满足$~O(b\\times g)=O(p)~$。且此时需要求解的$~Q~$个方程中$~a~$和$~p~$是不变的，因此可以预处理$~\\sqrt{pQ}~$个$~\\text{baby step}~$，这样总时间复杂度变为$~O(T\\sqrt{pQ}\\log(p+Q))~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long i64;int p;int add(int a, int b) &#123; return a + b &lt; p ? a + b : a + b - p; &#125;int sub(int a, int b) &#123; return a &lt; b ? a - b + p : a - b; &#125;int mul(int a, int b) &#123; return 1LL * a * b % p; &#125;int fpow(int a, int n) &#123; int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int T; cin &gt;&gt; T; while (T--) &#123; i64 n; int x0, a, b, Q; cin &gt;&gt; n &gt;&gt; x0 &gt;&gt; a &gt;&gt; b &gt;&gt; p &gt;&gt; Q; if (a == 0) &#123; while (Q--) &#123; int v, res; cin &gt;&gt; v; if (x0 == v) res = 0; else if (n != 1 &amp;&amp; b == v) res = 1; else res = -1; cout &lt;&lt; res &lt;&lt; '\\n'; &#125; &#125; else if (a == 1) &#123; if (b) &#123; while (Q--) &#123; int v, res; cin &gt;&gt; v; res = mul(sub(v, x0), fpow(b, p - 2)); if (res &gt;= n) res = -1; cout &lt;&lt; res &lt;&lt; '\\n'; &#125; &#125; else &#123; while (Q--) &#123; int v; cin &gt;&gt; v; cout &lt;&lt; (x0 == v ? \"0\\n\" : \"-1\\n\"); &#125; &#125; &#125; else &#123; int y = mul(b, fpow(sub(a, 1), p - 2)), z = add(x0, y); if (z) &#123; int size = min(int(sqrt(p)) &lt;&lt; 5, p - 1), giant = 1; vector&lt;pair&lt;int, int&gt;&gt; baby(size); for (int i = 0; i != size; ++i) &#123; baby[i] = make_pair(giant, i); giant = mul(giant, a); &#125; sort(baby.begin(), baby.end()); giant = fpow(giant, p - 2); while (Q--) &#123; int v, res = -1; cin &gt;&gt; v; v = mul(add(v, y), fpow(z, p - 2)); for (int gs = 0; gs &lt; p; gs += size) &#123; auto ite = lower_bound(baby.begin(), baby.end(), make_pair(v, 0)); if (ite != baby.end() &amp;&amp; ite-&gt;first == v) &#123; res = gs + ite-&gt;second; break; &#125; v = mul(v, giant); &#125; if (res &gt;= n) res = -1; cout &lt;&lt; res &lt;&lt; '\\n'; &#125; &#125; else &#123; while (Q--) &#123; int v; cin &gt;&gt; v; cout &lt;&lt; (x0 == v ? \"0\\n\" : \"-1\\n\"); &#125; &#125; &#125; &#125;&#125; D. generator 3题目大意序列$~x_0,x_1,\\dots,x_{n-1}~$和$~y_0,y_1,\\dots,y_{n-1}~$由$~x_i=(a_x\\cdot x_{i-1}+b_x)\\mod p_x~$和$~y_i=(a_y\\cdot y_{i-1}+b_y)\\mod p_y~$生成。计算点集$~(x_0,y_0),(x_1,y_1),\\dots,(x_{n-1},y_{n-1})~$的凸包的面积。数据范围$~0\\leq a,b&lt; p\\leq2\\times10^5~$。 题解找出两个序列的循环节，显然循环节的长度不会超过$~p~$。然后根据$~y~$循环节的长度对$~x~$的一个循环节重排列，这样每个$~y_i~$对应的$~x~$取值必然为这个重排列的连续一段，对$~x~$建立$~\\rm ST~$表即可。这样就能在$~O(p\\log p)~$的时间内求出$~O(p)~$个对凸包有影响的点，且其余点均对凸包没有影响。总是复杂度为$~O(p\\log p)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long i64;struct point &#123; i64 x, y; point(i64 _x = 0, i64 _y = 0): x(_x), y(_y) &#123;&#125; point operator- (const point&amp; p) const &#123; return point(x - p.x, y - p.y); &#125; i64 operator^ (const point&amp; p) const &#123; return x * p.y - y * p.x; &#125; bool operator&lt; (const point&amp; p) const &#123; return x == p.x ? y &lt; p.y : x &lt; p.x; &#125;&#125;;int convex_hull(point p[], int n, point con[]) &#123; sort(p, p + n); int m = 0; for (int i = 0; i != n; ++i) &#123; while (m &gt; 1 &amp;&amp; ((con[m - 1] - con[m - 2]) ^ (p[i] - con[m - 2])) &lt;= 0) --m; con[m++] = p[i]; &#125; int k = m; for (int i = n - 2; ~i; --i) &#123; while (m &gt; k &amp;&amp; ((con[m - 1] - con[m - 2]) ^ (p[i] - con[m - 2])) &lt;= 0) --m; con[m++] = p[i]; &#125; if (n &gt; 1) --m; return m;&#125;i64 area(point p[], int n) &#123; if (n &lt; 3) return 0; i64 ret = p[n - 1] ^ p[0]; for (int i = 1; i != n; ++i) ret += p[i - 1] ^ p[i]; return ret;&#125;const int maxn = 1 &lt;&lt; 20;point p[maxn], con[maxn];int x[maxn], y[maxn], lastx[maxn], lasty[maxn], tmp[maxn], mi[maxn][20], mx[maxn][20];int st_min(int l, int r) &#123; int k = 31 - __builtin_clz(r - l); return min(mi[l][k], mi[r - (1 &lt;&lt; k)][k]);&#125;int st_max(int l, int r) &#123; int k = 31 - __builtin_clz(r - l); return max(mx[l][k], mx[r - (1 &lt;&lt; k)][k]);&#125;void exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (b) &#123; exgcd(b, a % b, y, x); y -= a / b * x; &#125; else &#123; x = 1; y = 0; &#125;&#125;int main() &#123; int ax, ay, bx, by, px, py; i64 n; cin &gt;&gt; x[0] &gt;&gt; y[0] &gt;&gt; ax &gt;&gt; ay &gt;&gt; bx &gt;&gt; by &gt;&gt; px &gt;&gt; py &gt;&gt; n; p[0] = point(x[0], y[0]); for (int i = 1; i != maxn; ++i) &#123; x[i] = (1LL * ax * x[i - 1] + bx) % px; y[i] = (1LL * ay * y[i - 1] + by) % py; p[i] = point(x[i], y[i]); &#125; if (n &gt;&gt; 20) &#123; memset(lastx, -1, maxn &lt;&lt; 2); memset(lasty, -1, maxn &lt;&lt; 2); int firstx = -1, firsty = -1, loopx = -1, loopy = -1; for (int i = 0; i != maxn; ++i) &#123; if (~lastx[x[i]]) &#123; firstx = lastx[x[i]]; loopx = i - firstx; break; &#125; lastx[x[i]] = i; &#125; for (int i = 0; i != maxn; ++i) &#123; if (~lasty[y[i]]) &#123; firsty = lasty[y[i]]; loopy = i - firsty; break; &#125; lasty[y[i]] = i; &#125; int size = max(firstx, firsty), *xx = x + size, *yy = y + size; n -= size; int gcd = __gcd(loopx, loopy), stepx = loopx / gcd, stepy = loopy / gcd, invx, invy; exgcd(stepx, stepy, invx, invy); invy = (invy % stepx + stepx) % stepx; for (int i = 0; i != gcd; ++i) &#123; for (int j = 0; j != stepx; ++j) mi[j][0] = mi[j + stepx][0] = mx[j][0] = mx[j + stepx][0] = xx[(1LL * j * loopy + i) % loopx]; for (int k = 1; k != 20; ++k) for (int j = 0; j + (1 &lt;&lt; k) &lt;= (stepx &lt;&lt; 1); ++j) &#123; mi[j][k] = min(mi[j][k - 1], mi[j + (1 &lt;&lt; (k - 1))][k - 1]); mx[j][k] = max(mx[j][k - 1], mx[j + (1 &lt;&lt; (k - 1))][k - 1]); &#125; for (int j = 0; j != stepy; ++j) &#123; int l = 1LL * j * invy % stepx, r = l + min&lt;i64&gt;(stepx, (n - j * gcd - i - 1) / loopy + 1); p[size++] = point(st_min(l, r), yy[j * gcd + i]); p[size++] = point(st_max(l, r), yy[j * gcd + i]); &#125; &#125; n = size; &#125; cout &lt;&lt; area(con, convex_hull(p, n, con)) &lt;&lt; endl;&#125; E. independent set 1题目大意给定一个$~n~$个点的简单图，计算所有子图的最大独立集大小之和。数据范围$~2\\leq n\\leq26~$。 题解状压$~\\rm DP~$，转移式为 f(S)=\\max(f(S\\,\\backslash\\lbrace\\,\\min S\\,\\rbrace),f((S\\,\\backslash\\lbrace\\,\\min S\\,\\rbrace)\\cap A(\\min S)^\\complement)+1)其中$~A(u)~$表示与$~u~$相邻的点集。这样总时间复杂度和空间复杂度均为$~O(2^n)~$。注意$~\\rm DP~$数组要用8bit数据类型。 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned char u08;u08 dp[1 &lt;&lt; 26];int adj[26];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u] ^= 1 &lt;&lt; v; adj[v] ^= 1 &lt;&lt; u; &#125; for (int i = 1; i != (1 &lt;&lt; n); ++i) &#123; int j = __builtin_ctz(i); dp[i] = max&lt;u08&gt;(dp[i ^ 1 &lt;&lt; j], dp[(i ^ 1 &lt;&lt; j) &amp; ~adj[j]] + 1); &#125; cout &lt;&lt; accumulate(dp, dp + (1 &lt;&lt; n), 0) &lt;&lt; endl;&#125; F. maximum clique 1题目大意给定一个集合$~\\lbrace\\,a_1,a_2,\\dots,a_N\\,\\rbrace~$，找出一个最大的子集满足任意两个数在$~2~$进制表示下至少要有$~2~$个位置不一样。数据范围$~1\\leq N\\leq5000~$。 题解先去重，那么异或之后为$~2~$的幂的一对数不能同时在答案之中。对于每个数字，把它和与它异或之后为$~2~$的幂的数字相连。显然每个点至多连$~32~$条边，且这是个二分图，因为每条边只能连接$~2~$进制下有奇数个$~1~$的数和有偶数个$~1~$的数。那就是一个二分图最大独立集问题。先找出最大匹配，然后找出最小点覆盖，补集就是最大独立集。总时间复杂度为$~O(N^2)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 13;vector&lt;int&gt; side[2], adj[maxn];int size0, size1, link[maxn], vis[maxn], match[maxn], sav[maxn], ban[maxn];int DFS(int u) &#123; for (int v : adj[u]) if (!vis[v]) &#123; vis[v] = 1; if (!~link[v] || DFS(link[v])) &#123; link[v] = u; return 1; &#125; &#125; return 0;&#125;int hungary() &#123; int ret = 0; memset(link, -1, maxn &lt;&lt; 2); for (int u = 0; u != size0; ++u) &#123; memset(vis, 0, maxn &lt;&lt; 2); ret += DFS(u); &#125; return ret;&#125;void dfs(int u) &#123; sav[u] = 1; for (int v : adj[u]) if (!ban[v]) &#123; ban[v] = 1; dfs(link[v]); &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; set&lt;int&gt; a; while (n--) &#123; int aa; cin &gt;&gt; aa; a.insert(aa); &#125; for (int aa : a) side[__builtin_parity(aa)].push_back(aa); size0 = side[0].size(); size1 = side[1].size(); for (int i = 0; i != size0; ++i) for (int j = 0; j != size1; ++j) if (__builtin_popcount(side[0][i] ^ side[1][j]) == 1) adj[i].push_back(j); hungary(); for (int i = 0; i != size1; ++i) if (~link[i]) match[link[i]] = 1; for (int i = 0; i != size0; ++i) if (!match[i]) dfs(i); vector&lt;int&gt; res; for (int i = 0; i != size0; ++i) if (sav[i]) res.push_back(side[0][i]); for (int i = 0; i != size1; ++i) if (!ban[i]) res.push_back(side[1][i]); cout &lt;&lt; res.size() &lt;&lt; endl &lt;&lt; res.front(); for (int i = 1; i != int(res.size()); ++i) cout &lt;&lt; ' ' &lt;&lt; res[i]; cout &lt;&lt; endl;&#125; G. subsequence 1题目大意给定两个数字串$~s~$和$~t~$，计算$~s~$由多少个子序列在数字表示下比$~t~$大，子序列不能有前导$~0~$。数据范围$~1\\leq m\\leq n\\leq3000,~\\sum n\\leq3000~$。 题解对于$~s~$长度大于$~m~$的子序列，显然大于$~t~$，组合数枚举即可。下面计算长度等于$~m~$且大于$~t~$的子序列。记$~f(i,j)~$表示$~s~$长度为$~i~$的后缀中有多少长度为$~j~$的子序列大于$~t~$长度为$~j~$的后缀。直接$~\\rm DP~$，最后$~f(n,m)~$就是答案。总时间复杂度为$~O(nm)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int mod = 998244353;constexpr int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;constexpr int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;constexpr const int maxn = 1 &lt;&lt; 12;int inv[maxn], fac[maxn], fiv[maxn];constexpr int C(int n, int m) &#123; return n &lt; m ? 0 : mul(fac[n], mul(fiv[m], fiv[n - m])); &#125;int dp[2][maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); inv[0] = inv[1] = fac[0] = fac[1] = fiv[0] = fiv[1] = 1; for (int i = 2; i != maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fac[i] = mul(fac[i - 1], i); fiv[i] = mul(fiv[i - 1], inv[i]); &#125; dp[0][0] = 1; int T; cin &gt;&gt; T; while (T--) &#123; int n, m; string s, t; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; s &gt;&gt; t; int res = 0; for (int i = 0; i != n; ++i) if (s[i] != '0') for (int j = m; i + j &lt; n; ++j) res = add(res, C(n - i - 1, j)); int *dp0 = dp[0], *dp1 = dp[1]; size_t size = (m + 1) &lt;&lt; 2; memset(dp0, 0, size); for (int i = 1; i &lt;= n; ++i) &#123; memcpy(dp1, dp0, size); for (int j = 1; j &lt;= m; ++j) &#123; if (s[n - i] &gt; t[m - j]) dp1[j] = add(dp1[j], C(i - 1, j - 1)); if (s[n - i] == t[m - j]) dp1[j] = add(dp1[j], dp0[j - 1]); &#125; swap(dp0, dp1); &#125; cout &lt;&lt; add(res, dp0[m]) &lt;&lt; endl; &#125;&#125; H. subsequence 2题目大意有一个隐藏的由前$~m~$个小写字母组成的字符串，给出$~\\binom{m}{2}~$种字母对，在保留该对字母对情况下的剩余字符串。构造出合法原串或者不存在。数据范围$~1\\leq n\\leq10^4,~2\\leq m\\leq10~$。 题解先判断每个字母出现次数的合法性，然后根据给出的字符串建图，拓扑排序即可。时间复杂度为$~O(nm+m^2)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000;const int maxc = 100000;vector&lt;int&gt; drct[maxc], from[maxc], cnt[10];int deg[maxc];void link(int u, int v) &#123; drct[u].push_back(v); from[v].push_back(u); &#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i != m * (m - 1) / 2; ++i) &#123; string ch, str; int l, tot[2] = &#123; 0 &#125;; cin &gt;&gt; ch &gt;&gt; l; if (l) cin &gt;&gt; str; vector&lt;int&gt; id(l), num(l); for (auto j : &#123; 0, 1 &#125;) cnt[ch[j] - 'a'].push_back(count(str.begin(), str.end(), ch[j])); for (int i = 0; i != l; ++i) &#123; id[i] = str[i] == ch[1]; num[i] = tot[id[i]]++; &#125; for (int i = 1; i &lt; l; ++i) link((ch[id[i - 1]] - 'a') * maxn + num[i - 1], (ch[id[i]] - 'a') * maxn + num[i]); &#125; for (int i = 0; i != m; ++i) if (*min_element(cnt[i].begin(), cnt[i].end()) != *max_element(cnt[i].begin(), cnt[i].end())) return cout &lt;&lt; -1 &lt;&lt; endl, 0; vector&lt;int&gt; topo; string res; for (int i = 0; i != m; ++i) for (int j = 0; j != cnt[i][0]; ++j) &#123; if (drct[i * maxn + j].empty()) &#123; topo.push_back(i * maxn + j); res.push_back(char(i + 'a')); &#125; deg[i * maxn + j] = drct[i * maxn + j].size(); &#125; for (int i = 0; i != int(topo.size()); ++i) &#123; int u = topo[i]; for (auto v : from[u]) if (!--deg[v]) &#123; topo.push_back(v); res.push_back(char(v / maxn + 'a')); &#125; &#125; if (int(res.size()) != n) return cout &lt;&lt; -1 &lt;&lt; endl, 0; reverse(res.begin(), res.end()); cout &lt;&lt; res &lt;&lt; endl;&#125; I. three points 1题目大意在$~[0,w]\\times[0,h]~$上选$~3~$个点，满足两两距离分别为$~a,b,c~$，保证有解。 题解计算几何。一定存在一合法解满足一个点在原点，还有一个点在矩形边缘，暴力枚举即可. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt; constexpr T regular(T x) &#123; return min&lt;T&gt;(1, max&lt;T&gt;(-1, x)); &#125;constexpr const double eps = 1e-8;struct point &#123; double x, y; point(double _x = 0, double _y = 0): x(_x), y(_y) &#123;&#125; point operator* (const double k) const &#123; return point(x * k, y * k); &#125; point operator/ (const double k) const &#123; return point(x / k, y / k); &#125; double len() const &#123; return hypot(x, y); &#125; point unit() const &#123; return *this / len(); &#125; point rotate(const point&amp; ang) const &#123; return point(x * ang.x - y * ang.y, x * ang.y + y * ang.x); &#125;&#125;;ostream&amp; operator&lt;&lt; (ostream&amp; os, const point&amp; p) &#123; return os &lt;&lt; p.x &lt;&lt; ' ' &lt;&lt; p.y; &#125;double w, h, w2, h2;bool check(const point&amp; p) &#123; return p.x + eps &gt; 0 &amp;&amp; p.x &lt; w + eps &amp;&amp; p.y + eps &gt; 0 &amp;&amp; p.y &lt; h + eps; &#125;void ctrl(point&amp; p) &#123; p.x = min(w, max&lt;double&gt;(0, p.x)); p.y = min(h, max&lt;double&gt;(0, p.y)); &#125;bool solve(double a, double b, double c, point&amp; A, point&amp; B, point&amp; C) &#123; double a2 = a * a, b2 = b * b, c2 = c * c; double cosA = regular((b2 + c2 - a2) / 2 / b / c), sinA = regular(sqrt(1 - cosA * cosA)); point angA(cosA, sinA), revA(cosA, -sinA); if (cosA + eps &gt; 0) &#123; A = point(); if (cosA &lt; eps) &#123; if (w + eps &gt; b &amp;&amp; h + eps &gt; c) &#123; B = point(0, c); C = point(b, 0); return true; &#125; if (w + eps &gt; c &amp;&amp; h + eps &gt; b) &#123; B = point(c, 0); C = point(0, b); return true; &#125; &#125; else &#123; B = h + eps &gt; c ? point(0, c) : point(sqrt(c2 - h2), h); C = B.unit().rotate(angA) * b; if (check(C)) return true; C = B.unit().rotate(revA) * b; if (check(C)) return true; B = w + eps &gt; c ? point(c, 0) : point(w, sqrt(c2 - w2)); C = B.unit().rotate(angA) * b; if (check(C)) return true; C = B.unit().rotate(revA) * b; if (check(C)) return true; &#125; &#125; return false;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int T; cin &gt;&gt; T; cout &lt;&lt; fixed &lt;&lt; setprecision(10); while (T--) &#123; double l[3]; cin &gt;&gt; w &gt;&gt; h &gt;&gt; l[2] &gt;&gt; l[1] &gt;&gt; l[0]; w2 = w * w, h2 = h * h; point res[3]; int per[3] = &#123; 0, 1, 2 &#125;; do &#123; if (solve(l[per[0]], l[per[1]], l[per[2]], res[per[0]], res[per[1]], res[per[2]])) break; &#125; while (next_permutation(per, per + 3)); for (int i = 0; i != 3; ++i) ctrl(res[i]); cout &lt;&lt; res[0] &lt;&lt; ' ' &lt;&lt; res[1] &lt;&lt; ' ' &lt;&lt; res[2] &lt;&lt; '\\n'; &#125;&#125; J. three points 2题目大意给定一棵树，每次询问$~a,b,c~$，找出$~3~$个点$~X,Y,Z~$满足$~XY,XZ,YZ~$的距离分别是$~a,b,c~$或不存在。数据范围$~3\\leq n,Q\\leq2\\times10^5~$。 题解先考虑单组询问。设$~XY,XZ,YZ~$的交点为$~O~$，则有$~OX=\\frac{a+b-c}{2},OY=\\frac{c+a-b}{2},OZ=\\frac{b+c-a}{2}~$，这$~3~$个值按升序记为$~\\alpha,\\beta,\\gamma~$。根据三角不等式和奇偶性排除显然无解的询问，然后设法寻找$~O~$点。记$~A(u)~$为与$~u~$相邻的点集，记$~f(u,v)~$为以$~u~$为起点，必经$~v~$的简单路径的最长长度。对于每个点$~u~$，考虑可重集$~\\lbrace\\,f(u,v):v\\in A(u)\\,\\rbrace~$的最大的$~3~$个元素，按升序记为$~p_u,q_u,r_u~$。则此时点$~u~$可以作为交点的充要条件是$~p_u\\geq\\alpha,q_u\\geq\\beta,r_u\\geq\\gamma~$。对于所有$~p,q,r~$的处理可以通过两次$~\\rm DFS~$结合树形$~\\rm DP~$在$~O(n)~$内完成。对于多组询问，先考虑寻找$~O~$点。每个$~(p_u,q_u,r_u)~$可以看作是在$~(p_u,q_u)~$处有一个权值为$~r_u~$的点，那么每个$~(\\alpha,\\beta,\\gamma)~$的询问等价于点$~(\\alpha,\\beta)~$的右上方是否存在权值不小于$~\\gamma~$的点。对询问先离线，然后扫描线加树状数组即可解决。在找到$~O~$点之后，考虑在之前$~\\rm DP~$的过程中不仅记录路径的最大值，同时记录最远的点是什么。那么$~X,Y,Z~$的查询等价于在$~OA,OB,OC~$上查询到$~O~$距离为$~\\alpha,\\beta,\\gamma~$的点。用类似倍增$~\\rm LCA~$的方法即可解决。总时间复杂度为$~O((n+Q)\\cdot\\log n)~$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;using namespace std;constexpr const int maxn = 1 &lt;&lt; 18;int pa[maxn][18], dep[maxn];pair&lt;int, int&gt; dp[maxn][3];vector&lt;int&gt; adj[maxn];int find(int u, int k) &#123; for (int i = 0; i != 18; ++i) if (k &amp; 1 &lt;&lt; i) u = pa[u][i]; return u;&#125;int lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); u = find(u, dep[u] - dep[v]); if (u == v) return u; for (int i = 17; ~i; --i) if (pa[u][i] != pa[v][i]) &#123; u = pa[u][i]; v = pa[v][i]; &#125; return pa[u][0];&#125;int find(int u, int v, int d) &#123; int f = lca(u, v); return dep[u] - dep[f] &lt; d ? find(v, dep[u] + dep[v] - dep[f] - dep[f] - d) : find(u, d);&#125;void dfs0(int u, int p) &#123; for (int i : &#123; 0, 1, 2 &#125;) dp[u][i] = make_pair(0, u); for (int v : adj[u]) if (v != p) &#123; dfs0(v, u); dp[u][2] = max(dp[u][2], make_pair(dp[v][0].first + 1, dp[v][0].second)); for (int i : &#123; 1, 0 &#125;) if (dp[u][i] &lt; dp[u][i + 1]) swap(dp[u][i], dp[u][i + 1]); &#125;&#125;void dfs1(int u, int p) &#123; dep[u] = dep[p] + 1; pa[u][0] = p; for (int i = 1; i != 18; ++i) pa[u][i] = pa[pa[u][i - 1]][i - 1]; auto from = &amp;dp[p][dp[p][0].second == dp[u][0].second]; dp[u][2] = max(dp[u][2], make_pair(from-&gt;first + 1, from-&gt;second)); for (int i : &#123; 1, 0 &#125;) if (dp[u][i] &lt; dp[u][i + 1]) swap(dp[u][i], dp[u][i + 1]); for (int v : adj[u]) if (v != p) dfs1(v, u);&#125;int query[maxn][3];struct node &#123; int x, y, z; &#125; tree[maxn], fake[maxn];vector&lt;int&gt; Y0[maxn], Y1[maxn];node *bit[maxn], *res[maxn];#define lowbit(x) ((x) &amp; -(x))node* better(node* ptr1, node* ptr2) &#123; if (ptr1 == nullptr) return ptr2; if (ptr2 == nullptr) return ptr1; return ptr1-&gt;z &lt; ptr2-&gt;z ? ptr2 : ptr1;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i != n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; dfs0(0, -1); for (int u : adj[0]) dfs1(u, 0); for (int i = 0; i != n; ++i) &#123; tree[i] = &#123; dp[i][2].first + 1, dp[i][1].first + 1, dp[i][0].first + 1&#125;; Y0[tree[i].y].push_back(i); &#125; int Q; cin &gt;&gt; Q; for (int i = 0; i != Q; ++i) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if ((a ^ b ^ c) &amp; 1) continue; int d[3] = &#123; (a + b - c) &gt;&gt; 1, (c + a - b) &gt;&gt; 1, (b + c - a) &gt;&gt; 1 &#125;; memcpy(query[i], d, 12); sort(d, d + 3); if (d[0] &lt; 0) continue; fake[i] = &#123; d[0] + 1, d[1] + 1, d[2] + 1 &#125;; Y1[fake[i].y].push_back(i); &#125; fill_n(bit, n, nullptr); fill_n(res, n, nullptr); for (int y = n; y; --y) &#123; for (int i : Y0[y]) for (int j = tree[i].x; j ; j ^= lowbit(j)) bit[j] = better(bit[j], tree + i); for (int i : Y1[y]) for (int j = fake[i].x; j &lt; maxn; j += lowbit(j)) res[i] = better(res[i], bit[j] ); &#125; for (int i = 0; i != Q; ++i) &#123; if (res[i] == nullptr || res[i]-&gt;z &lt; fake[i].z) &#123; cout &lt;&lt; \"-1\\n\"; &#125; else &#123; int center = res[i] - tree; int p[3] = &#123; 0, 1, 2 &#125;, ans[3]; sort(p, p + 3, [&amp;] (int j, int k) &#123; return query[i][j] &lt; query[i][k]; &#125;); for (int j = 0; j != 3; ++j) ans[p[j]] = find(center, dp[center][2 - j].second, query[i][p[j]]); for (int j : &#123; 0, 1, 2 &#125;) cout &lt;&lt; ans[j] &lt;&lt; (j == 2 ? '\\n' : ' '); &#125; &#125;&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[{"name":"多校","slug":"多校","permalink":"http://yoursite.com/tags/多校/"}]},{"title":"2019暑假牛客多校四 (TBC)","slug":"2019暑假牛客多校四 (TBC)","date":"2019-08-01T11:53:47.961Z","updated":"2019-08-01T11:54:14.818Z","comments":true,"path":"2019/08/01/2019暑假牛客多校四 (TBC)/","link":"","permalink":"http://yoursite.com/2019/08/01/2019暑假牛客多校四 (TBC)/","excerpt":"","text":"2019牛客暑期多校训练营（第四场） A. meeting题目大意水题。 题解水题。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 17;int vip[maxn], vis[maxn];vector&lt;int&gt; adj[maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i != n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; int x; while (k--) &#123; cin &gt;&gt; x; vip[x] = 1; &#125; vector&lt;int&gt; bfs0(1, x); vis[x] = 1; for (int i = 0; i != int(bfs0.size()); ++i) &#123; int u = bfs0[i]; if (vip[u]) x = u; for (const auto&amp; v : adj[u]) if (!vis[v]) &#123; bfs0.push_back(v); vis[v] = 1; &#125; &#125; vector&lt;pair&lt;int, int&gt;&gt; bfs1(1, pair&lt;int, int&gt;(x, 0)); memset(vis, 0, maxn &lt;&lt; 2); vis[x] = 1; int res = 0; for (int i = 0; i != int(bfs1.size()); ++i) &#123; int u = bfs1[i].first, d = bfs1[i].second; if (vip[u]) res = d; for (const auto&amp; v : adj[u]) if (!vis[v]) &#123; bfs1.emplace_back(v, d + 1); vis[v] = 1; &#125; &#125; cout &lt;&lt; ((res + 1) &gt;&gt; 1) &lt;&lt; endl;&#125; B. xor题目大意给定$~n~$个集合序列，每次询问区间$~[l,r]~$的集合是否存在一个子集使得异或值为$~x~$。数据范围$~1\\leq n,m\\leq50000,~0\\leq x&lt; 2^{32}~$。 题解每个集合可以看作一个线性空间，于是询问等价于问$~x~$是否属于一个区间的交。线性基求交等价于原空间的解空间求并。将原空间的基以上三角形式维护，则解空间可以在$~O(32^2)~$内求得。以解空间建立一棵线段树，对于查询，不要合并，直接在每个线段树节点上判断$~x~$是否与当前这个解空间正交即可。总时间复杂度为$~O(32^2n+32m\\log n)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define parity __builtin_parity#define up0 __builtin_clztypedef unsigned int u32;template&lt;typename T&gt; struct linear_space : vector&lt;T&gt; &#123; void push(T x) &#123; for (const auto&amp; e : *this) x = min(x, x ^ e); if (x) this-&gt;push_back(x); &#125; void sort() &#123; std::sort(this-&gt;begin(), this-&gt;end()); &#125; bool check(T x) &#123; for (const auto&amp; e : *this) if (parity(x &amp; e)) return false; return true; &#125;&#125;;template&lt;typename T&gt; linear_space&lt;T&gt; solve(const linear_space&lt;T&gt;&amp; s) &#123; linear_space&lt;T&gt; ker; for (u32 i = 0; i != 32U; ++i) &#123; u32 x = 1U &lt;&lt; i; bool flag = true; for (const auto&amp; e : s) &#123; if (up0(x) == up0(e)) &#123; flag = false; break; &#125; if (parity(x &amp; e)) x ^= 1U &lt;&lt; (31U - up0(e)); &#125; if (flag) ker.push(x); &#125; return ker;&#125;template&lt;typename T&gt;linear_space&lt;T&gt; merge(const linear_space&lt;T&gt;&amp; s1, const linear_space&lt;T&gt;&amp; s2) &#123; linear_space&lt;T&gt; ret(s1); for (const auto&amp; e : s2) ret.push(e); return ret;&#125;const u32 maxn = 1 &lt;&lt; 16;linear_space&lt;u32&gt; seg[maxn &lt;&lt; 1];#define mid ((begin + end) &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (lson ^ 1)#define lll begin, mid, lson#define rrr mid, end, rsonvoid build(u32 begin, u32 end, u32 index) &#123; if (begin + 1 == end) &#123; u32 sz; cin &gt;&gt; sz; while (sz--) &#123; u32 x; cin &gt;&gt; x; seg[index].push(x); &#125; seg[index].sort(); seg[index] = solve(seg[index]); return; &#125; build(lll); build(rrr); seg[index] = merge(seg[lson], seg[rson]);&#125;bool query(u32 begin, u32 end, u32 index, u32 l, u32 r, u32 x) &#123; if (begin &gt;= r || end &lt;= l) return true; if (begin &gt;= l &amp;&amp; end &lt;= r) return seg[index].check(x); return query(lll, l, r, x) &amp;&amp; query(rrr, l, r, x);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); u32 n, m; cin &gt;&gt; n &gt;&gt; m; build(0, n, 1); while (m--) &#123; u32 l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; cout &lt;&lt; (query(0, n, 1, l - 1, r, x) ? \"YES\\n\" : \"NO\\n\"); &#125;&#125; C. sequence题目大意给定序列$~a_1,a_2,\\dots,a_n~$和$~b_1,b_2,\\dots,b_n~$，计算$~\\max_{1\\leq l\\leq r\\leq n}((\\min_{i=l}^{r}a_i)\\times(\\sum_{i=l}^{r}b_i))~$。数据范围$~1\\leq n\\leq3\\times10^6,~-10^6\\leq a,b\\leq10^6~$。 题解通过单调栈可以线性求出对于每个$~a_i~$，当$~a_i=\\min_{j=l}^{r}a_j~$时$~l~$和$~r~$的取值范围。于是问题转化为对于$~b~$序列询问区间内的最大子段和。以$~b~$的前缀和建立最大最小值线段树即可。总时间复杂度为$~O(n\\log n)~$，需要注意常数优化。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 22;int a[maxn], b[maxn], ll[maxn], rr[maxn];int64_t pre[maxn], mi[maxn &lt;&lt; 1], mx[maxn &lt;&lt; 1];#define mid ((begin + end) &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (lson ^ 1)#define lll begin, mid, lson#define rrr mid, end, rsonvoid build(int begin, int end, int index) &#123; if (begin + 1 == end) &#123; mi[index] = mx[index] = pre[begin]; return; &#125; build(lll); build(rrr); mi[index] = min(mi[lson], mi[rson]); mx[index] = max(mx[lson], mx[rson]);&#125;int64_t min(int begin, int end, int index, int l, int r) &#123; if (begin &gt;= r || end &lt;= l) return LLONG_MAX; if (begin &gt;= l &amp;&amp; end &lt;= r) return mi[index]; return min(min(lll, l, r), min(rrr, l, r));&#125;int64_t max(int begin, int end, int index, int l, int r) &#123; if (begin &gt;= r || end &lt;= l) return LLONG_MIN; if (begin &gt;= l &amp;&amp; end &lt;= r) return mx[index]; return max(max(lll, l, r), max(rrr, l, r));&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; a[0] = a[n + 1] = INT_MIN; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; b[i]; for (int i = 1; i &lt;= n; ++i) pre[i] = pre[i - 1] + b[i]; build(0, n + 1, 1); stack&lt;int&gt; left, right; left.push(0); for (int i = 1; i &lt;= n; ++i) &#123; while (a[left.top()] &gt;= a[i]) left.pop(); ll[i] = left.top(); left.push(i); &#125; right.push(n + 1); for (int i = n; i; --i) &#123; while (a[right.top()] &gt;= a[i]) right.pop(); rr[i] = right.top(); right.push(i); &#125; int64_t res = LLONG_MIN; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] &gt; 0) res = max(res, a[i] * (max(0, n + 1, 1, i, rr[i]) - min(0, n + 1, 1, ll[i], i))); if (a[i] &lt; 0) res = max(res, a[i] * (min(0, n + 1, 1, i, rr[i]) - max(0, n + 1, 1, ll[i], i))); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. triples I题目大意水题。 题解水题。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long i64;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int T; cin &gt;&gt; T; while (T--) &#123; i64 a; cin &gt;&gt; a; if (a % 3 == 0) &#123; cout &lt;&lt; \"1 \" &lt;&lt; a &lt;&lt; '\\n'; continue; &#125; cout &lt;&lt; \"2 \"; vector&lt;i64&gt; one[2]; for (int i = 0; i != 60; ++i) if (a &amp; 1LL &lt;&lt; i) one[i &amp; 1].push_back(1LL &lt;&lt; i); if (one[0].empty()) &#123; cout &lt;&lt; (one[1][0] ^ one[1][1] ^ one[1][2]) &lt;&lt; ' '; i64 temp = 0; for (int i = one[1].size() % 3; i != int(one[1].size()); ++i) temp ^= one[1][i]; cout &lt;&lt; temp; &#125; else if (one[1].empty()) &#123; cout &lt;&lt; (one[0][0] ^ one[0][1] ^ one[0][2]) &lt;&lt; ' '; i64 temp = 0; for (int i = one[0].size() % 3; i != int(one[0].size()); ++i) temp ^= one[0][i]; cout &lt;&lt; temp; &#125; else &#123; cout &lt;&lt; (one[0][0] ^ one[1][0]) &lt;&lt; ' '; i64 temp = 0; for (auto i : &#123; 0, 1 &#125;) for (int j = 1; j != int(one[i].size()); ++j) temp ^= one[i][j]; for (auto i : &#123; 0, 1 &#125;) if ((temp ^ one[i][0]) % 3 == 0) &#123; temp ^= one[i][0]; break; &#125; cout &lt;&lt; temp; &#125; cout &lt;&lt; '\\n'; &#125;&#125; E. triples II题目大意计算有多少个长度为$~n~$且均为$~3~$的倍数的序列满足按位或的值为$~a~$。数据范围$~1\\leq n\\leq10^{18},~0\\leq a\\leq10^{18}~$ 题解预处理$~f(x,y)~$表示，对于一个由$~x~$个模$~3~$余$~1~$和$~y~$个模$~3~$于$~2~$的数构成的集合，有多少个子集满足总和模$~3~$余$~0~$。那么对于每次询问快速幂加容斥即可。总时间复杂度为$~O(\\log^4a+T\\log^2a\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long i64;const int mod = 998244353;int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;int fpow(int a, i64 n) &#123; int ret = 1; for (n = (n % (mod - 1) + mod - 1) % (mod - 1); n; n &gt;&gt;= 1) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); &#125; return ret;&#125;int inv[31], fac[31], fiv[31];int bino(int n, int k) &#123; return mul(fac[n], mul(fiv[k], fiv[n - k])); &#125;int pmt[31][31];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); inv[0] = inv[1] = fac[0] = fac[1] = fiv[0] = fiv[1] = 1; for (int i = 2; i &lt;= 30; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fac[i] = mul(fac[i - 1], i); fiv[i] = mul(fiv[i - 1], inv[i]); &#125; for (int i = 0; i &lt;= 30; ++i) for (int j = 0; j &lt;= 30; ++j) if ((i + j + j) % 3 == 0) for (int ii = i; ii &lt;= 30; ++ii) for (int jj = j; jj &lt;= 30; ++jj) pmt[ii][jj] = add(pmt[ii][jj], mul(bino(ii, i), bino(jj, j))); int T; cin &gt;&gt; T; while (T--) &#123; i64 n, a; cin &gt;&gt; n &gt;&gt; a; int cnt[2] = &#123; 0 &#125;; for (int i = 0; i != 60; ++i) if (a &amp; 1LL &lt;&lt; i) ++cnt[i &amp; 1]; int res = 0; for (int i = 0; i &lt;= cnt[0]; ++i) for (int j = 0; j &lt;= cnt[1]; ++j) res = add(res, mul(fpow(pmt[i][j], n), mul(fpow(mod - 1, cnt[0] + cnt[1] - i - j), mul(bino(cnt[0], i), bino(cnt[1], j))))); cout &lt;&lt; res &lt;&lt; '\\n'; &#125;&#125; F. merge题目大意暂略。 题解平衡树等。暂略。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 19;struct node &#123; int size, key, x, max, son[2]; &#125; a[maxn];int root;void update(int x) &#123; a[x].size = a[a[x].son[0]].size + a[a[x].son[1]].size + 1; a[x].max = max(a[x].x, max(a[a[x].son[0]].max, a[a[x].son[1]].max));&#125;int merge(int x, int y) &#123; if (!x || !y) return x + y; if (a[x].key &gt; a[y].key) &#123; a[x].son[1] = merge(a[x].son[1], y); update(x); return x; &#125; else &#123; a[y].son[0] = merge(x, a[y].son[0]); update(y); return y; &#125;&#125;void split(int t, int k, int&amp; x, int&amp; y) &#123; if (t == 0) &#123; x = y = 0; return; &#125; if (a[a[t].son[0]].size + 1 &lt;= k) &#123; x = t; split(a[t].son[1], k - a[a[t].son[0]].size - 1, a[t].son[1], y); &#125; else &#123; y = t; split(a[t].son[0], k, x, a[t].son[0]); &#125; if (x) update(x); if (y) update(y);&#125;int get(int p, int k) &#123; if (a[a[p].son[0]].size &gt;= k) return get(a[p].son[0], k); else if (a[a[p].son[0]].size + 1 == k)return a[p].x; else return get(a[p].son[1], k - a[a[p].son[0]].size - 1);&#125;int get_len(int p, int x) &#123; if (!p) return 0; else if (a[a[p].son[0]].max &gt; x) return get_len(a[p].son[0], x); else if (a[p].x &gt; x) return a[a[p].son[0]].size; else return get_len(a[p].son[1], x) + a[a[p].son[0]].size + 1;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); srand(time(nullptr)); int n, q; cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i].x; a[i].max = a[i].x; a[i].size = 1; a[i].key = rand(); root = merge(root, i); &#125; int x, l, m, r, cnt = 0; while(q--) &#123; cin &gt;&gt; x; if (x == 1) &#123; cin &gt;&gt; l &gt;&gt; m &gt;&gt; r; int tmp; split(root, r, root, tmp); int x, y, z; split(root, m, x, y); root = 0; while(x &amp;&amp; y) &#123; ++cnt; int p = get(x, 1), q = get(y, 1); if (p &gt; q) &#123; swap(p, q); swap(x, y); &#125; int num = get_len(x, q); split(x, num, z, x); root = merge(root, z); &#125; if (x) root = merge(root, x); if (y) root = merge(root, y); root = merge(root, tmp); &#125; else &#123; cin &gt;&gt; x; cout &lt;&lt; get(root, x) &lt;&lt; '\\n'; &#125; &#125;&#125; G. tree题目大意给定一棵大小为$~n~$的无根树$~A~$，每次询问有多少个$~A~$的子图于大小为$~m~$的无根树$~B~$同构。数据范围$~n\\leq2000,~t\\leq10000,~m\\leq12~$。 题解树$~\\rm hash~$。预处理出大小不超过$~12~$的有根树，总量为$~7813~$。考虑从小到大枚举，对于当前的树枚举一个节点然后扩张出一个叶节点，整个过程类似于$~\\rm BFS~$。然后再考虑将树$~B~$的根连接到树$~A~$的根后得到一棵大小不超过$~12~$的大树的转移方案数，总量为$~13689~$。然后树形$~\\rm DP~$，记$~dp(i,j)~$表示再$~A~$中以$~i~$为根的子树中有多少子图在以$~i~$为根时，与第$~j~$棵有根树同构。对于每次询问的树$~B~$，枚举出本质不同的根然后对于预处理的$~dp~$值求和即可。总时间复杂度为$~O(13689n+tm^2\\log m)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long u64;const u64 a = 314159265359ULL;const u64 b = 271828182845ULL;const u64 p = 201907281725ULL;u64 vec_hash(const vector&lt;u64&gt;&amp; vec) &#123; u64 ret = a; for (const auto&amp; x : vec) ret = ret * p ^ x; return ret * b;&#125;struct tree &#123; int adj[12], n; tree(int _n = 0): n(_n) &#123; memset(adj, 0, 48); &#125; void link(int u, int v) &#123; adj[u] ^= 1 &lt;&lt; v, adj[v] ^= 1 &lt;&lt; u; &#125; tree grow(int u) &#123; tree ret(*this); ret.link(u, n); ++ret.n; return ret; &#125; tree merge(const tree&amp; t) &#123; tree ret(*this); for (int u = 0; u != t.n; ++u) ret.adj[n + u] = t.adj[u] &lt;&lt; n; ret.link(0, n); ret.n += t.n; return ret; &#125; u64 dfs(int u, int p) &#123; vector&lt;u64&gt; tmp; for (int v = 0; v != n; ++v) if (v != p &amp;&amp; (adj[u] &amp; 1 &lt;&lt; v)) tmp.push_back(dfs(v, u)); sort(tmp.begin(), tmp.end()); return vec_hash(tmp); &#125;&#125;;const int mod = 1000000007;constexpr int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;constexpr int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;const int maxn = 1 &lt;&lt; 11;const int maxt = 1 &lt;&lt; 13;tree bfs[maxt];int bfs_size, dp[maxn][maxt], sum[maxt];vector&lt;int&gt; adj[maxn];vector&lt;pair&lt;int, int&gt;&gt; from[maxt];void dfs(int u, int p) &#123; dp[u][0] = 1; for (const auto&amp; v : adj[u]) if (v != p) &#123; dfs(v, u); for (int i = bfs_size - 1; ~i; --i) for (const auto&amp; e : from[i]) dp[u][i] = add(dp[u][i], mul(dp[u][e.first], dp[v][e.second])); &#125; for (int i = 0; i != bfs_size; ++i) sum[i] = add(sum[i], dp[u][i]);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); map&lt;u64, int&gt; pmt; bfs[0] = tree(1); pmt[bfs[0].dfs(0, 0)] = 0; bfs_size = 1; for (int i = 0; i != bfs_size; ++i) if (bfs[i].n != 12) for (int u = 0; u != bfs[i].n; ++u) &#123; u64 hash = (bfs[bfs_size] = bfs[i].grow(u)).dfs(0, 0); if (pmt.find(hash) == pmt.end()) pmt[hash] = bfs_size++; &#125; for (int i = 0; bfs[i].n != 12; ++i) for (int j = 0; bfs[i].n + bfs[j].n &lt;= 12; ++j) from[pmt[bfs[i].merge(bfs[j]).dfs(0, 0)]].emplace_back(i, j); int n; cin &gt;&gt; n; for (int i = 1; i != n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; --u, --v; adj[u].push_back(v); adj[v].push_back(u); &#125; dfs(0, 0); int t; cin &gt;&gt; t; while (t--) &#123; int m; cin &gt;&gt; m; tree B(m); for (int i = 1; i != m; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; B.link(u - 1, v - 1); &#125; set&lt;int&gt; root; for (int r = 0; r != m; ++r) root.insert(pmt[B.dfs(r, r)]); int res = 0; for (const auto&amp; r : root) res = add(res, sum[r]); cout &lt;&lt; res &lt;&lt; '\\n'; &#125;&#125; H. RNGs题目大意暂略。 题解暂略。 代码暂略。 I. string题目大意定义字符串$~a~$与$~b~$本质不同当且仅当$~a\\neq b~$且$~a\\neq rev(b)~$。问给定字符串$~s~$有多少种本质不同子串。数据范围$~1\\leq|s|\\leq2\\times10^5~$。 题解将$~s~$与$~rev(s)~$用特殊字符连接后，原本意义上的本质不同子串的统计会包括$~s~$的所有子串$~t~$和$~rev(t)~$，然后再对$~t=rev(t)~$即$~t~$是回文的情况去重即可。用后缀自动机和回文自动机处理即可，总时间复杂度为$~O(|s|\\log26)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;bits/stdc++.h&gt;using ul = std::uint32_t;using li = std::int32_t;using ull = std::uint64_t;using ll = std::int64_t;namespace sam &#123; class node; ul las = 1; ul tot = 1; void add(ul c);&#125;class sam::node &#123;public: ul ch[27]; ul len = 0; ul fa = 0; node() &#123; std::memset(ch, 0, sizeof(ch)); &#125;&#125;;sam::node samnodes[1 &lt;&lt; 20];void sam::add(ul c)&#123; ul p = las; ul np = las = ++tot; auto* nodes = samnodes; nodes[np].len = nodes[p].len + 1; for ( ; p &amp;&amp; !nodes[p].ch[c]; p = nodes[p].fa) &#123; nodes[p].ch[c] = np; &#125; if (!p) &#123; nodes[np].fa = 1; &#125; else &#123; ul q = nodes[p].ch[c]; if (nodes[q].len == nodes[p].len + 1) &#123; nodes[np].fa = q; &#125; else &#123; ul nq = ++tot; nodes[nq] = nodes[q]; nodes[nq].len = nodes[p].len + 1; nodes[q].fa = nodes[np].fa = nq; for ( ; p &amp;&amp; nodes[p].ch[c] == q; p = nodes[p].fa) &#123; nodes[p].ch[c] = nq; &#125; &#125; &#125;&#125;std::string str;std::string rstr;const int MAXN = 2e5 + 10;const int N = 26;struct Palindromic_Tree &#123; int nxt[MAXN][N]; int fail[MAXN]; int cnt[MAXN]; int num[MAXN]; int len[MAXN]; int S[MAXN]; int last; int n; int p; int newnode(int l) &#123; for(int i = 0;i &lt; N;++i) nxt[p][i] =0; cnt[p] = 0; num[p] = 0; len[p] = l; return p++; &#125; void init() &#123; p = 0; newnode(0); newnode(-1); last = 0; n = 0; S[n] = -1; fail[0] = 1; &#125; int get_fail(int x) &#123; while(S[n - len[x] - 1] != S[n]) &#123; x = fail[x]; &#125; return x; &#125; void add(int c,int pos) &#123; c -= 'a'; S[++n] = c; int cur = get_fail(last); if(!nxt[cur][c]) &#123; int now = newnode(len[cur] + 2); fail[now] = nxt[get_fail(fail[cur])][c]; nxt[cur][c] = now; num[now] = num[fail[now]] + 1; &#125; last = nxt[cur][c]; cnt[last]++; &#125;&#125; run;int main()&#123; std::cin.tie(0); std::ios::sync_with_stdio(false); std::cin &gt;&gt; str; for (ul i = 0; i != str.size(); ++i) &#123; sam::add(str[i] - 'a'); &#125; sam::add(26); for (ul i = str.size() - 1; ~i; --i) &#123; sam::add(str[i] - 'a'); &#125; ull ans2 = 0; for (ul i = 2; i &lt;= sam::tot; ++i) &#123; ans2 += samnodes[i].len - samnodes[samnodes[i].fa].len; &#125; ans2 -= ull(str.size() + 1) * ull(str.size() + 1); run.init(); for(int i = 0;i &lt; str.size();++i) run.add(str[i],i); ull ans3 = run.p - 2; std::printf(\"%llu\\n\", (ans2 + ans3) / 2);&#125; J. free题目大意在正边权图上给定两点，问最多使$~k~$条边边权为$~0~$的条件下的最短路。数据范围$~1\\leq n,m\\leq10^3,~0\\leq k\\leq m~$。 题解跑$~k+1~$次单源最短路或者建$~k+1~$层的大图跑一遍单源最短路。总时间复杂度为$~O(km\\log n)~$。注意大图做法需要注意常数。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 10;const int maxx = 1 &lt;&lt; 20;vector&lt;pair&lt;int, int&gt;&gt; adj[maxn], graph[maxx];int_fast8_t vis[maxx];int dis[maxx];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m, s, t, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t &gt;&gt; k; --s, --t; while (m--) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; --u, --v; adj[u].emplace_back(v, w); adj[v].emplace_back(u, w); &#125; for (int u = 0; u != n; ++u) graph[u] = adj[u]; for (int i = 0; i != k; ++i) for (int u = 0; u != n; ++u) &#123; for (const auto&amp; e : adj[u]) &#123; graph[i * n + u].emplace_back(i * n + n + e.first, 0); graph[i * n + n + u].emplace_back(i * n + n + e.first, e.second); &#125; &#125; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; heap; heap.emplace(0, s); while (!heap.empty()) &#123; auto top = heap.top(); heap.pop(); if (vis[top.second]) continue; vis[top.second] = 1; dis[top.second] = top.first; for (const auto&amp; e : graph[top.second]) if (!vis[e.first]) heap.emplace(top.first + e.second, e.first); &#125; int res = INT_MAX; for (int i = 0; i &lt;= k; ++i) res = min(res, dis[i * n + t]); cout &lt;&lt; res &lt;&lt; endl;&#125; K. number题目大意水题。 题解水题。 代码123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); string str; cin &gt;&gt; str; str.push_back(1); int cnt[3] = &#123; 0 &#125;; cnt[0] = 1; int last = 0, zero = 0; int64_t res = count(str.begin(), str.end(), '0'); for (const auto&amp; ch : str) &#123; int x = ch - '0'; if (x) &#123; ++cnt[last = (last + x) % 3]; zero = 0; &#125; else &#123; if (zero) res += cnt[last] - 1; ++cnt[last]; ++zero; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[{"name":"多校","slug":"多校","permalink":"http://yoursite.com/tags/多校/"}]},{"title":"2019暑假杭电多校三 (TBC)","slug":"2019暑假杭电多校三 (TBC)","date":"2019-08-01T11:53:47.957Z","updated":"2019-08-01T11:54:09.441Z","comments":true,"path":"2019/08/01/2019暑假杭电多校三 (TBC)/","link":"","permalink":"http://yoursite.com/2019/08/01/2019暑假杭电多校三 (TBC)/","excerpt":"","text":"2019 Multi-University Training Contest 3 B. Blow up the city题目大意给定一个$~\\rm DAG~$，每次询问两点，问有多少个点满足扣去之后给定点中至少有一个点无法到达原图的无出度点。数据范围$~1\\leq T\\leq10,~1\\leq n\\leq100000,~1\\leq m\\leq200000,~1\\leq q\\leq100000~$。 题解支配树上$~\\rm LCA~$。可以根据拓扑序维护倍增$~\\rm LCA~$。总时间复杂度为$~O(T\\cdot(m+q)\\cdot\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 17;vector&lt;int&gt; drct[maxn], from[maxn];int deg[maxn], dep[maxn], pa[maxn][18];int LCA(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); for (int i = 17; ~i; --i) if (dep[pa[u][i]] &gt;= dep[v]) u = pa[u][i]; if (u == v) return u; for (int i = 17; ~i; --i) if (pa[u][i] != pa[v][i]) &#123; u = pa[u][i]; v = pa[v][i]; &#125; return pa[u][0];&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int T; cin &gt;&gt; T; while (T--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int u = 0; u &lt;= n; ++u) &#123; drct[u].clear(); from[u].clear(); &#125; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; drct[u].push_back(v); from[v].push_back(u); &#125; for (int u = 1; u &lt;= n; ++u) &#123; if (drct[u].empty()) &#123; drct[u].push_back(0); from[0].push_back(u); &#125; deg[u] = drct[u].size(); &#125; vector&lt;int&gt; topo(1); for (int i = 0; i &lt;= n; ++i) &#123; int u = topo[i]; if (u) &#123; auto ite = drct[u].begin(); int p = *ite++; while (ite != drct[u].end()) p = LCA(p, *ite++); dep[u] = dep[p] + 1; pa[u][0] = p; for (int j = 1; j != 18; ++j) pa[u][j] = pa[pa[u][j - 1]][j - 1]; &#125; for (const auto&amp; v : from[u]) if (!--deg[v]) topo.push_back(v); &#125; int q; cin &gt;&gt; q; while (q--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; dep[u] + dep[v] - dep[LCA(u, v)] &lt;&lt; '\\n'; &#125; &#125;&#125; F. Fansblog题目大意给定一个质数$~P~$，找出最大的质数$~Q&lt; P~$，计算$~Q!\\mod P~$。数据范围$~1\\leq T\\leq10,~10^9\\leq P\\leq10^{14}~$。 题解相邻的质数肯定不会太远，不会超过$~1000~$，可以暴力求出$~Q~$，然后利用威尔逊定理即可求出答案。总时间复杂度为$~O(1000T)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long i64;bool check(i64 x) &#123; for (i64 p = 2; p * p &lt; x; ++p) if (x % p == 0) return false; return true;&#125;i64 mul(i64 a, i64 b, i64 p) &#123; return __int128(a) * b % p; &#125;i64 fpow(i64 a, i64 n, i64 p) &#123; i64 ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a, p); a = mul(a, a, p); n &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int T; cin &gt;&gt; T; while (T--) &#123; i64 P; cin &gt;&gt; P; i64 Q = P - 1, res = 1; while (!check(Q)) res = mul(res, Q--, P); cout &lt;&lt; mul(fpow(res, P - 2, P), P - 1, P) &lt;&lt; endl; &#125;&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[{"name":"多校","slug":"多校","permalink":"http://yoursite.com/tags/多校/"}]},{"title":"Codeforces Round 576 (Div. 1) (TBC)","slug":"Codeforces Round 576 (Div. 1) (TBC)","date":"2019-08-01T10:50:33.931Z","updated":"2019-08-01T10:50:39.577Z","comments":true,"path":"2019/08/01/Codeforces Round 576 (Div. 1) (TBC)/","link":"","permalink":"http://yoursite.com/2019/08/01/Codeforces Round 576 (Div. 1) (TBC)/","excerpt":"","text":"Codeforces Round #576 (Div. 1) A. MP3题目大意水题。 题解水题。 代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, I; cin &gt;&gt; n &gt;&gt; I; map&lt;int, int&gt; cnt; for (int i = 0; i != n; ++i) &#123; int a; cin &gt;&gt; a; ++cnt[a]; &#125; int k = (I &lt;&lt; 3) / n; if (k &gt; 30) return cout &lt;&lt; 0 &lt;&lt; endl, 0; int size = 1 &lt;&lt; k; vector&lt;int&gt; tot; for (const auto&amp; p : cnt) tot.push_back(p.second); int res = 0; for (int i = 0, j = 0, s = 0; i != int(tot.size()); ++i) &#123; s += tot[i]; if (i - j == size) s -= tot[j++]; res = max(res, s); &#125; cout &lt;&lt; n - res &lt;&lt; endl;&#125; B. Welfare State题目大意要求对一个序列支持两种操作：单点修改或全局取$~\\max~$。数据范围$~1\\leq n\\leq2\\cdot10^5,~1\\leq n\\leq2\\cdot10^5~$。 题解最普遍的方法是线段树，全局取$~\\max~$时更新根节点的标记，单点修改时对路径上的节点下放标记即可。总时间复杂度为$~O(n+q\\log n)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 18;int val[maxn &lt;&lt; 1], tag[maxn &lt;&lt; 1], pos[maxn];#define mid ((begin + end) &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (lson ^ 1)#define lll begin, mid, lson#define rrr mid, end, rsonvoid build(int begin, int end, int index) &#123; if (begin + 1 == end) &#123; cin &gt;&gt; val[index]; pos[end] = index; return; &#125; build(lll); build(rrr);&#125;void push_down(int index) &#123; tag[lson] = max(tag[lson], tag[index]); tag[rson] = max(tag[rson], tag[index]); tag[index] = 0;&#125;void modify(int begin, int end, int index, int p, int x) &#123; if (begin &gt;= p || end &lt; p) return; if (begin + 1 == end) &#123; val[index] = x; tag[index] = 0; return; &#125; push_down(index); modify(lll, p, x); modify(rrr, p, x);&#125;void push_down(int begin, int end, int index) &#123; if (begin + 1 == end) &#123; val[index] = max(val[index], tag[index]); return; &#125; push_down(index); push_down(lll); push_down(rrr);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; build(0, n, 1); int q; cin &gt;&gt; q; while (q--) &#123; int op, p, x; cin &gt;&gt; op; if (op == 1) &#123; cin &gt;&gt; p &gt;&gt; x; modify(0, n, 1, p, x); &#125; else &#123; cin &gt;&gt; x; tag[1] = max(tag[1], x); &#125; &#125; push_down(0, n, 1); for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; val[pos[i]] &lt;&lt; (i == n ? '\\n' : ' ');&#125; C. Matching vs Independent Set题目大意给定一个有$~3n~$个点的图，输出一个大小为$~n~$的独立边集或者独立点集。数据范围$~1\\leq\\sum n\\leq10^5,~0\\leq\\sum m\\leq5\\cdot10^5~$。 题解考虑任取一个极大独立边集，如果边数超过$~n~$，则答案已经构造完毕。如果边数少于$~n~$，则至少还有$~n~$个点没有取过，而根据当前的独立边集的极大性，剩余的点两两之间没有边，显然可以构造出大小为$~n~$的独立点集。总时间复杂度为$~O(n+m)~$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 19;int e[maxn][2], ban[maxn], vis[maxn];vector&lt;int&gt; adj[maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int T; cin &gt;&gt; T; while (T--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= 3 * n; ++i) &#123; adj[i].clear(); vis[i] = 0; &#125; for (int i = 1; i &lt;= m; ++i) &#123; ban[i] = 0; int u, v; cin &gt;&gt; u &gt;&gt; v; e[i][0] = u; e[i][1] = v; adj[u].push_back(i); adj[v].push_back(i); &#125; vector&lt;int&gt; edge, vertice; for (int i = 1; i &lt;= m; ++i) if (!ban[i]) &#123; edge.push_back(i); for (auto j : &#123; 0, 1 &#125;) &#123; vis[e[i][j]] = 1; for (auto k : adj[e[i][j]]) ban[k] = 1; &#125; &#125; for (int i = 1; i &lt;= 3 * n; ++i) if (!vis[i]) vertice.push_back(i); if (int(edge.size()) &lt; n) &#123; cout &lt;&lt; \"IndSet\\n\" &lt;&lt; vertice.front(); for (int i = 1; i != n; ++i) cout &lt;&lt; ' ' &lt;&lt; vertice[i]; &#125; else &#123; cout &lt;&lt; \"Matching\\n\" &lt;&lt; edge.front(); for (int i = 1; i != n; ++i) cout &lt;&lt; ' ' &lt;&lt; edge[i]; &#125; cout &lt;&lt; endl; &#125;&#125; D. Rectangle Painting 1题目大意给定一个黑白染色的网格图，每次对一个矩形染白的花费是长和宽的最大值。计算把全图染白的最小花费。数据范围$~1\\leq n\\leq50~$。 题解二维区间$~\\rm DP~$，总时间复杂度为$~O(\\frac{1}{36}n^5)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 56;int s[maxn][maxn], dp[maxn][maxn][maxn][maxn];int rect(int x1, int y1, int x2, int y2) &#123; return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; char ch; cin &gt;&gt; ch; s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; if (ch == '#') ++s[i][j]; &#125; for (int x1 = n; x1; --x1) for (int y1 = n; y1; --y1) for (int x2 = x1; x2 &lt;= n; ++x2) for (int y2 = y1; y2 &lt;= n; ++y2) if (rect(x1, y1, x2, y2)) &#123; auto&amp; cur = dp[x1][y1][x2][y2]; cur = max(x2 - x1, y2 - y1) + 1; for (int x = x1; x &lt;= x2; ++x) if (!rect(x, y1, x, y2)) cur = min(cur, dp[x1][y1][x - 1][y2] + dp[x + 1][y1][x2][y2]); for (int y = y1; y &lt;= y2; ++y) if (!rect(x1, y, x2, y)) cur = min(cur, dp[x1][y1][x2][y - 1] + dp[x1][y + 1][x2][y2]); &#125; cout &lt;&lt; dp[1][1][n][n] &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"2019暑假牛客多校一","slug":"2019暑假牛客多校一","date":"2019-07-19T15:51:08.120Z","updated":"2019-07-20T12:20:39.672Z","comments":true,"path":"2019/07/19/2019暑假牛客多校一/","link":"","permalink":"http://yoursite.com/2019/07/19/2019暑假牛客多校一/","excerpt":"","text":"2019牛客暑期多校训练营（第一场） A. Equivalent Prefixes题目大意给定两个序列，求它们的最长的前缀长度满足这一对子序列的大小关系是一致的。数据范围$~1\\leq n\\leq10^5,~\\sum n\\leq5\\times10^5~$。 题解题意给定的关系等价于笛卡尔树相同。可以单调栈求出每个位置左边第一个比它小的位置，然后依次比较。单组数据的时间复杂度为$~O(n)~$。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;void work(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; l, int n) &#123; stack&lt;int&gt; sta; sta.push(0); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; while (a[sta.top()] &gt; a[i]) sta.pop(); l[i] = sta.top(); sta.push(i); &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; while (cin &gt;&gt; n) &#123; vector&lt;int&gt; a(n + 1), b(n + 1), la(n + 1), lb(n + 1); work(a, la, n); work(b, lb, n); int res = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (la[i] != lb[i]) break; res = i; &#125; cout &lt;&lt; res &lt;&lt; endl; &#125;&#125; B. Integration题目大意给出$~\\int_{0}^{\\infty}\\frac{\\text{d}x}{1+x^2}=\\frac{\\pi}{2}~$。计算积分 \\frac{1}{\\pi}\\int_{0}^{\\infty}\\frac{\\text{d}x}{\\prod_{i=1}^{n}(a_i^2+x^2)}数据范围$~1\\leq n\\leq10^3，~\\sum n^2\\leq10^7~$。 题解考虑裂项 \\frac{1}{(a^2+x^2)(b^2+x^2)}=\\frac{1}{(b^2-a^2)(a^2+x^2)}+\\frac{1}{(a^2-b^2)(b^2+x^2)}递归展开 \\frac{1}{\\prod_{i=1}^{n}(a_i^2+x^2)}有 \\frac{1}{\\prod_{i=1}^{n}(a_i^2+x^2)}=\\sum_{i=1}^{n}\\frac{1}{(a_i^2+x^2)\\prod_{j\\neq i}(a_j^2-a_i^2)}所以答案为 \\frac{1}{\\pi}\\int_{0}^{\\infty}\\frac{\\text{d}x}{\\prod_{i=1}^{n}(a_i^2+x^2)}=\\sum_{i=1}^{n}\\frac{1}{2a_i(\\prod_{j\\neq i}(a_j^2-a_i^2))}单组数据的时间复杂度为$~O(n^2)~$。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1000000007;int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;int sub(int a, int b) &#123; return a &lt; b ? a - b + mod : a - b; &#125;int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;int fpow(int a, int n) &#123; int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; while (cin &gt;&gt; n) &#123; vector&lt;int&gt; a(n), a2(n); for (int i = 0; i != n; ++i) cin &gt;&gt; a[i], a2[i] = mul(a[i], a[i]); int res = 0; for (int i = 0; i != n; ++i) &#123; int cur = add(a[i], a[i]); for (int j = 0; j != n; ++j) if (i != j) cur = mul(cur, sub(a2[j], a2[i])); res = add(res, fpow(cur, mod - 2)); &#125; cout &lt;&lt; res &lt;&lt; endl; &#125;&#125; C. Euclidean Distance题目大意给定$~\\Bbb R^n~$上的一个点$~A=(\\frac{a_1}{m},\\frac{a_2}{m},\\dots,\\frac{a_n}{m})~$，求它到闭集$~D=\\lbrace~(p_1,p_2,\\dots,p_n):\\sum_{i=1}^{n}p_i=1,~p_i\\geq0,\\forall~1\\leq i\\leq n~\\rbrace~$的最短距离。数据范围$~1\\leq n\\leq10^4,~\\sum n\\leq5\\times10^5,~1\\leq m\\leq10^3,~-m\\leq a\\leq m~$。 题解不难求出$~A~$到该$~n-1~$维超平面的距离的平方为 \\frac{(m-\\sum_{i-1}^{n}a_i)^2}{nm^2}然而由于$~p_i\\geq0~$的限制，垂足有可能不在$~D~$内，所以还要计算垂足和$~D~$的距离。设垂足为$~\\hat{A}~$，则有 \\hat{A}=(\\dots,\\frac{m+na_i-\\sum_{i=1}^{n}a_i}{nm},\\dots)记$~\\hat{a}_i=m+na_i-\\sum_{i=1}^{n}a_i~$，则不难发现$~\\hat{A}\\in D~$的充要条件是$~\\hat{a}_i\\geq0,\\forall~1\\leq i\\leq n~$。且对于$~\\hat{a}_i&lt; 0~$，闭集$~D~$上距离$~\\hat{A}~$最短的点$~P~$必须满足$~p_i=0~$。不妨设$~\\hat{A}~$的各个维度中只有$~\\hat{a}_1,\\hat{a}_2,\\dots,\\hat{a}_k~$满足非负，那么问题可转化为在$~\\Bbb R^k~$上求$~(\\hat{a}_1,\\hat{a}_2,\\dots,\\hat{a}_k)~$到$~\\hat{D}=\\lbrace~(p_1,p_2,\\dots,p_k):\\sum_{i=1}^{k}p_i=1,~p_i\\geq0,\\forall~1\\leq i\\leq k~\\rbrace~$的最短距离。如果暴力降维求解，最坏时间复杂度为$~O(n^2)~$。考虑对$~a_i~$升序，根据$~\\hat{a}_i~$的表达式可以发现$~\\hat{a}_i~$也是升序的，因此每次降维的时候必然会除去$~a_i~$的一个前缀而保留后缀。归纳下去可知最后当$~A~$的垂足在$~D~$内时，必然保留的是$~A~$的一个后缀维度。二分或者暴力判断保留的后缀长度，然后对于前缀直接计算平方和，后缀带入距离公式，单组数据的时间复杂度为$~O(n\\log n)~$。注意到$~a~$的数据范围且复杂度的$~O(\\log n)~$仅来自于对$~a~$的升序，因此考虑到基数排序，单组数据为线性复杂度$~O(n)~$。 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; vector&lt;int64_t&gt; a(n), suf(n); for (auto&amp; aa : a) cin &gt;&gt; aa; sort(a.begin(), a.end()); suf.back() = a.back(); for (int i = n - 2; ~i; --i) suf[i] = suf[i + 1] + a[i]; int l = 1, r = n + 1; while (r - l != 1) &#123; int mid = (l + r) &gt;&gt; 1; m - suf[n - mid] + mid * a[n - mid] &lt; 0 ? r = mid : l = mid; &#125; int64_t p = 0, q = l * m * m; for (int i = 0; i != n - l; ++i) p += a[i] * a[i]; p = p * l + (m - suf[n - l]) * (m - suf[n - l]); int64_t d = __gcd(p, q); p /= d; q /= d; if (q == 1) cout &lt;&lt; p &lt;&lt; '\\n'; else cout &lt;&lt; p &lt;&lt; '/' &lt;&lt; q &lt;&lt; '\\n'; &#125; cout.flush();&#125; D. Parity of Tuples题目大意给定$~n~$个$~m~$元组$~a_i=(a_{i1},a_{i2},\\dots,a_{im})~$。定义$~f(x,a_i)=1~$当且仅当对任意$~a_{ij}\\odot x~$在二进制表示上均有奇数个$~1~$，反之$~f(x,a_i)=0~$。定义$~count(x)=\\sum_{i=1}^{n}f(x,a_i)~$，求 \\bigoplus_{x=0}^{2^k-1}\\left(count(x)\\cdot3^x\\mod(10^9+7)\\right)数据范围$~1\\leq n\\leq10^5,~1\\leq m\\leq10,~1\\leq k\\leq20,~0\\leq a_{ij}&lt; 2^k~$。其中$~\\odot~$和$~\\oplus~$分别表示按位与和按位异或。 题解考虑$~f~$作为特征函数的恒等变换 f(x,a_i)=\\frac{1}{2^m}\\prod_{j=1}^{m}\\left(1-(-1)^{\\mid a_i\\odot x\\mid}\\right)注意到如下性质 (-1)^{\\mid a\\odot x\\mid+\\mid b\\odot x\\mid}=(-1)^{\\mid(a\\oplus b)\\odot x\\mid}于是可以在$~O(2^m)~$的时间内把$~f(x,a_i)~$展开，求和得到 count(x)=\\frac{1}{2^m}\\sum_{y=0}^{2^k-1}\\left(g(y)\\cdot(-1)^{\\mid y\\oplus x\\mid}\\right)上式即为$~\\rm FWT~$变换。单组数据时间复杂度为$~O(n\\cdot2^m+k\\cdot2^k)~$，注意$~O(n\\cdot m\\cdot2^m+k\\cdot2^k)~$无法通过。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1000000007;int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;const int maxm = 10;const int maxk = 20;int cnt[1 &lt;&lt; maxk], inv2[maxm + 1], pow3[1 &lt;&lt; maxk], a[1 &lt;&lt; maxm], val[1 &lt;&lt; maxm], tot[1 &lt;&lt; maxm];#define lowbit(x) ((x) &amp; -(x))int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); inv2[0] = pow3[0] = 1; inv2[1] = 500000004; for (int i = 2; i &lt;= maxm; ++i) inv2[i] = mul(inv2[i - 1], inv2[1]); for (int i = 1; i != (1 &lt;&lt; maxk); ++i) pow3[i] = mul(pow3[i - 1], 3); for (int i = 1; i != (1 &lt;&lt; maxm); ++i) tot[i] = tot[i ^ lowbit(i)] ^ 1; int n, m, k; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) &#123; memset(cnt, 0, 4 &lt;&lt; k); while (n--) &#123; for (int i = 0; i != m; ++i) cin &gt;&gt; a[1 &lt;&lt; i]; ++cnt[0]; for (int s = 1; s != (1 &lt;&lt; m); ++s) &#123; val[s] = val[s ^ lowbit(s)] ^ a[lowbit(s)]; tot[s] &amp; 1 ? --cnt[val[s]] : ++cnt[val[s]]; &#125; &#125; for (int i = 0; i != k; ++i) &#123; for (int all = ((1 &lt;&lt; k) - 1) ^ 1 &lt;&lt; i, sub = all; sub; sub = all &amp; (sub - 1)) &#123; int x = cnt[sub], y = cnt[sub ^ 1 &lt;&lt; i]; cnt[sub] = x + y; cnt[sub ^ 1 &lt;&lt; i] = x - y; &#125; int x = cnt[0], y = cnt[1 &lt;&lt; i]; cnt[0] = x + y; cnt[1 &lt;&lt; i] = x - y; &#125; int res = 0; for (int s = 0; s != (1 &lt;&lt; k); ++s) res ^= mul(cnt[s], mul(inv2[m], pow3[s])); cout &lt;&lt; res &lt;&lt; '\\n'; &#125;&#125; E. ABBA题目大意计算有多少种由$~n+m~$个A和$~n+m~$个B组成的字符串满足存在一种划分为$~n+m~$个长度为$~2~$的子序列的方案，满足恰好有$~n~$个AB和$~m~$个BA。数据范围$~0\\leq n,m\\leq10^3~$。 题解注意到只有两种非法串，任意一种划分方案中AB的数量均小于$~n~$或者任意一种划分方案中BA的数量均小于$~m~$，且全集恰好为两个非法串集合与合法串集合的一个不交并。考虑存在一种划分方案使得AB数量不小于$~n~$的串的数量和存在一种划分方案使得BA数量不小于$~m~$的串的数量之和，此时的答案刚好是全集的大小加上合法串的数量，动态规划即可。单组数据时间复杂度为$~O(nm)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1000000007;int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;int sub(int a, int b) &#123; return a &lt; b ? a - b + mod : a - b; &#125;int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;const int maxn = 1 &lt;&lt; 12;int dp1[maxn][maxn], dp2[maxn][maxn], inv[maxn], fact[maxn], finv[maxn];int bino(int n, int k) &#123; return mul(fact[n], mul(finv[k], finv[n - k])); &#125;int main() &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i != maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 0; i &lt;= n + m; ++i) memset(dp1[i], 0, (n + m + 1) &lt;&lt; 2); for (int i = 0; i &lt;= n + m; ++i) memset(dp2[i], 0, (n + m + 1) &lt;&lt; 2); dp1[0][0] = 1; dp2[0][0] = 1; for (int k = 1; k &lt;= ((n + m) &lt;&lt; 1); ++k) for (int i = min(n + m, k); ~i; --i) &#123; int j = k - i; if (i - j &lt;= n) &#123; if (i) dp1[i][j] = add(dp1[i][j], dp1[i - 1][j]); if (j) dp1[i][j] = add(dp1[i][j], dp1[i][j - 1]); &#125; if (j - i &lt;= m) &#123; if (i) dp2[i][j] = add(dp2[i][j], dp2[i - 1][j]); if (j) dp2[i][j] = add(dp2[i][j], dp2[i][j - 1]); &#125; &#125; cout &lt;&lt; sub(add(dp1[n + m][n + m], dp2[n + m][n + m]), bino((n + m) &lt;&lt; 1, n + m)) &lt;&lt; endl; &#125;&#125; F. Random Point in Triangle题目大意给定一个三角形，在内部随机一个点将大三角形划分为$~3~$个子三角形。计算面积最大的子三角形的面积的期望值。 题解直接积分或者离线蒙特卡洛模拟可得期望值即为大三角形面积的$~\\frac{11}{18}~$。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int64_t cross(int64_t x1, int64_t y1, int64_t x2, int64_t y2) &#123; return x1 * y2 - y1 * x2; &#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int64_t x1, y1, x2, y2, x3, y3; while (cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3) cout &lt;&lt; 11 * abs(cross(x1 - x2, y1 - y2, x1 - x3, y1 - y3)) &lt;&lt; '\\n';&#125; G. Substrings 2题目大意定义序列$~a_1,a_2,\\dots,a_k~$和$~b_1,b_2,\\dots,b_k~$是同态的，如果存在一个单射$~f~$使得$~f(a_i)=b_i,\\forall~1\\leq i\\leq k~$。现给定一个序列$~s_1,s_2,\\dots,s_n~$，问最多可以选出多少个相互不同态的连续子序列。数据范围$~1\\leq n\\leq5\\times10^4~$。 题解首先设法把同态条件转化为等于条件。对于任意一个子序列$~t_1,t_2,\\dots,t_k~$。如果$~t_i~$的左边没有和它一样的值，那么把它变为$~n~$，否则把它变为它左边等于它且离它最近的距离。这样两个连续子序列同态等价于两个连续子序列在变换后一致。问题即转化为不同连续子序列数量问题。考虑后缀数组，即将所有的后缀按照字典序排序。然后不同连续子序列数量等于$~\\frac{n(n+1)}{2}~$减去所有字典序相邻后缀的$~\\rm LCP~$。但是每个$~s_i~$在不同的连续子序列内变化对应的值不一定相同。处理变化时考虑子序列的左端点从右向左移动的过程，注意到每次移动至多修改后缀的一个变化值，用可持久化数组分块来维护这个过程。可持久化数组分块是数组分块的一种拓展，数组分块支持$~O(1)~$的单点修改和$~O(\\sqrt n)~$的区间查询。改为记录后缀和则是$~O(\\sqrt n)~$的单点修改和$~O(1)~$的区间查询。由于每次修改只会操作一个分块，因此对于每个时刻的数组状态，用$~O(\\sqrt n)~$个指针指向它对应的分块，然后对于需要修改的那一分块，可以在$~O(\\sqrt n)~$新处理一个块并重新指向它。对于$~\\rm LCP~$和后缀数组，考虑用哈希实现，数据很弱并且是时限很紧，所以用$~64~$位自然溢出。用可持久化分块数组维护哈希值，这样单组数据的时间复杂度为$~O(n\\cdot(\\sqrt n+\\log^2n))~$。用c代替c++可以再使常数少一倍。 代码（c++）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;const uint64_t base = 1000000007;const int maxn = 1 &lt;&lt; 16;const int maxm = 1 &lt;&lt; 8 ;uint64_t bas[maxn], block[maxn &lt;&lt; 1][maxm], *my_hash[maxn][maxm], sum[maxn][maxm];int n, m, b, s[maxn], p[maxn], from[maxn], last[maxn];size_t block_size;uint64_t* new_block(size_t size) &#123; memset(block[block_size], 0, size &lt;&lt; 3); return block[block_size++];&#125;uint64_t* new_block(size_t size, uint64_t* from) &#123; memcpy(block[block_size], from, size &lt;&lt; 3); return block[block_size++];&#125;uint64_t suf_hash(int i, int p) &#123; int j = p / m, k = p % m; return (j == b - 1 ? 0ULL : sum[i][j + 1]) + my_hash[i][j][k];&#125;uint64_t get_hash(int i, int l) &#123; return (suf_hash(i, i) - suf_hash(i, i + l)) * bas[n - i]; &#125;int LCP(int i, int j) &#123; int r = n - max(i, j); if (get_hash(i, r) == get_hash(j, r)) return r; int l = 0; while (r - l != 1) &#123; int m = (l + r) &gt;&gt; 1; get_hash(i, m) == get_hash(j, m) ? l = m : r = m; &#125; return l;&#125;int char_at(int i, int j) &#123; return from[i + j] &lt; i ? n : i + j - from[i + j]; &#125;bool cmp(int i, int j) &#123; int k = LCP(i, j); if (k + i == n) return true; if (k + j == n) return false; return char_at(i, k) &lt; char_at(j, k);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); bas[0] = 1; for (int i = 1; i != maxn; ++i) bas[i] = bas[i - 1] * base; while (cin &gt;&gt; n) &#123; block_size = 0; b = sqrt(n + 1); m = n / b + 1; memset(from, -1, n &lt;&lt; 2); memset(last, -1, (n + 1) &lt;&lt; 2); for (int i = 0; i != n; ++i) cin &gt;&gt; s[i]; for (int i = 0; i != b; ++i) &#123; my_hash[n][i] = new_block(m); for (int j = 0; j != m; ++j) my_hash[n][i][j] = uint64_t(n) * bas[i * m + j]; for (int j = m - 2; ~j; --j) my_hash[n][i][j] += my_hash[n][i][j + 1]; sum[n][i] = my_hash[n][i][0]; &#125; for (int i = b - 2; ~i; --i) sum[n][i] += sum[n][i + 1]; for (int i = n - 1; ~i; --i) &#123; memcpy(my_hash[i], my_hash[i + 1], b * sizeof (uint64_t *)); memcpy(sum[i], sum[i + 1], b &lt;&lt; 3); if (~last[s[i]]) &#123; from[last[s[i]]] = i; int j = last[s[i]] / m, k = last[s[i]] % m; my_hash[i][j] = new_block(m, my_hash[i][j]); uint64_t x = uint64_t(last[s[i]] - i - n) * bas[last[s[i]]]; while (~k) my_hash[i][j][k--] += x; while (~j) sum[i][j--] += x; &#125; last[s[i]] = i; &#125; iota(p, p + n, 0); sort(p, p + n, cmp); int64_t res = n * (n + 1LL) &gt;&gt; 1; for (int i = 1; i != n; ++i) res -= LCP(p[i - 1], p[i]); cout &lt;&lt; res &lt;&lt; endl; &#125;&#125; 代码（c）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#define base (1000000007ULL)#define maxn (65536)#define maxm (256)typedef long long ll;typedef unsigned long long ull;ull bas[maxn], block[maxn][maxm], *hash[maxn][maxm], sum[maxn][maxm];int n, m, b, s[maxn], p[maxn], from[maxn], last[maxn], tmp[maxn];size_t block_size;ull* new_block(size_t size) &#123; memset(block[block_size], 0, size &lt;&lt; 3); return block[block_size++];&#125;ull* copy_block(size_t size, ull* from) &#123; memcpy(block[block_size], from, size &lt;&lt; 3); return block[block_size++];&#125;ull suf_hash(int i, int p) &#123; int j = p / m, k = p % m; return (j == b - 1 ? 0ULL : sum[i][j + 1]) + hash[i][j][k];&#125;ull get_hash(int i, int l) &#123; return (suf_hash(i, i) - suf_hash(i, i + l)) * bas[n - i]; &#125;int LCP(int i, int j) &#123; int r = n - (i &lt; j ? j : i); if (get_hash(i, r) == get_hash(j, r)) return r; int l = 0; while (r - l != 1) &#123; int m = (l + r) &gt;&gt; 1; if (get_hash(i, m) == get_hash(j, m)) l = m; else r = m; &#125; return l;&#125;int char_at(int i, int j) &#123; return from[i + j] &lt; i ? n : i + j - from[i + j]; &#125;int cmp(int i, int j) &#123; int k = LCP(i, j); if (k + i == n) return 1; if (k + j == n) return 0; return char_at(i, k) &lt; char_at(j, k);&#125;void sort(int* a, size_t size) &#123; size_t s1 = size &gt;&gt; 1; if (!s1) return; int *b = a + s1; size_t s2 = size - s1; sort(a, s1); sort(b, s2); size_t i = 0, j = 0, k = 0; while (i != s1 &amp;&amp; j != s2) &#123; if (cmp(a[i], b[j])) tmp[k++] = a[i++]; else tmp[k++] = b[j++]; &#125; while (i != s1) tmp[k++] = a[i++]; while (j != s2) tmp[k++] = b[j++]; memcpy(a, tmp, size &lt;&lt; 2);&#125;int main() &#123; bas[0] = 1; for (int i = 1; i != maxn; ++i) bas[i] = bas[i - 1] * base; while (scanf(\"%d\", &amp;n) != EOF) &#123; block_size = 0; b = sqrt(n + 1); m = n / b + 1; memset(from, -1, n &lt;&lt; 2); memset(last, -1, (n + 1) &lt;&lt; 2); for (int i = 0; i != n; ++i) scanf(\"%d\", s + i); for (int i = 0; i != b; ++i) &#123; hash[n][i] = new_block(m); for (int j = 0; j != m; ++j) hash[n][i][j] = (ull)(n) * bas[i * m + j]; for (int j = m - 2; ~j; --j) hash[n][i][j] += hash[n][i][j + 1]; sum[n][i] = hash[n][i][0]; &#125; for (int i = b - 2; ~i; --i) sum[n][i] += sum[n][i + 1]; for (int i = n - 1; ~i; --i) &#123; memcpy(hash[i], hash[i + 1], b * sizeof (ull *)); memcpy(sum[i], sum[i + 1], b &lt;&lt; 3); if (~last[s[i]]) &#123; from[last[s[i]]] = i; int j = last[s[i]] / m, k = last[s[i]] % m; hash[i][j] = copy_block(m, hash[i][j]); ull x = (ull)(last[s[i]] - i - n) * bas[last[s[i]]]; while (~k) hash[i][j][k--] += x; while (~j) sum[i][j--] += x; &#125; last[s[i]] = i; &#125; for (int i = 0; i != n; ++i) p[i] = i; sort(p, n); ll res = n * (n + 1LL) &gt;&gt; 1; for (int i = 1; i != n; ++i) res -= LCP(p[i - 1], p[i]); printf(\"%lld\\n\", res); &#125;&#125; H. XOR题目大意给定一个可重集$~a_1,a_2,\\dots,a_n~$，计算 \\sum_{S\\subseteq A}^{\\oplus_{x\\in S}x=0}\\mid S\\mid数据范围$~1\\leq n\\leq10^5,~\\sum n\\leq2\\times10^6,~0\\leq a\\leq10^{18}~$。 题解交换求和顺序 \\begin{aligned} \\sum_{S\\subseteq A,~\\oplus_{x\\in S}x=0}{\\mid S\\mid}&=\\sum_{S\\subseteq A}^{\\oplus_{x\\in S}x=0}\\sum_{x\\in S}1\\\\ &=\\sum_{a\\in A}\\sum_{S\\subseteq A\\backslash\\lbrace a\\rbrace}^{\\oplus_{x\\in S}=a}1 \\end{aligned}考虑线性基，则$~\\sum_{S\\subseteq A\\backslash\\lbrace a\\rbrace}^{\\oplus_{x\\in S}=a}1~$等价于$~a~$由$~A\\backslash\\lbrace a\\rbrace~$构成的空间$~S(A\\backslash\\lbrace a\\rbrace)~$内线性表出的方案数。记$~x~$为$~0~$由$~S(A)~$内元素线性表出的方案数，则有$~x=2^{\\mid A\\mid-\\mid S(A)\\mid}~$。如果$~a\\in S(A\\backslash\\lbrace a\\rbrace)~$，则方案数为$~\\frac{x}{2}~$，否则为$~0~$。在构造$~S(A)~$的时候将$~A~$内的元素从左至右加入到$~S~$之中，这一过程至多只有$~64~$个$~a~$无法被前缀构成的$~S~$线性表出，它们单独判断与$~S(A\\backslash\\lbrace a\\rbrace)~$的关系。对于其余的$~a~$，必有$~a\\in S(A\\backslash\\lbrace a\\rbrace)~$。单组数据的时间复杂度为$~O(64\\cdot n+64^3)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt; struct linear_space : vector&lt;T&gt; &#123; T find(T x) &#123; for (const auto&amp; e : *this) x = min(x, x ^ e); return x; &#125; T push(T x) &#123; x = find(x); if (x) this-&gt;push_back(x); return x; &#125;&#125;;template&lt;typename T&gt;linear_space&lt;T&gt; merge(const linear_space&lt;T&gt;&amp; s1, const linear_space&lt;T&gt;&amp; s2) &#123; linear_space&lt;T&gt; ret(s1); for (const auto&amp; x : s2) ret.push(x); return ret;&#125;const int mod = 1000000007;const int inv2 = 500000004;int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;const int maxn = 1 &lt;&lt; 17;uint64_t a[maxn];linear_space&lt;uint64_t&gt; pre[maxn], suf[maxn];int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; while (cin &gt;&gt; n) &#123; int res = inv2, cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; pre[i] = pre[i - 1]; if (!pre[i].push(a[i])) res = add(res, res); &#125; suf[n + 1].clear(); for (int i = n; i; --i) &#123; suf[i] = suf[i + 1]; suf[i].push(a[i]); &#125; for (int i = 1; i &lt;= n; ++i) if (pre[i].size() == pre[i - 1].size() || !merge(pre[i - 1], suf[i + 1]).find(a[i])) ++cnt; cout &lt;&lt; mul(res, cnt) &lt;&lt; '\\n'; &#125;&#125; I. Points Division题目大意需要将平面上的$~n~$个点划分到集合$~A~$或$~B~$之中，每个点划分给不同集合会有价值$~a~$或$~b~$。同时划分需要满足$~A~$内的点不能在某个$~B~$内的点的右下方。输出价值总和的最大值。数据范围$~1\\leq n\\leq10^5,~\\sum n\\leq5\\times10^5~$。 题解不难发现每种划分等价于一条从左下到右上的一条折线将平面划分，不妨设折线的每个左上拐点均为$~B~$内的一个点。显然所有这样的折线的水平部分的纵坐标和垂直部分的横坐标的取值均为$~O(n)~$。考虑从左到右，横坐标相同则从下到上，计算整条折线的最高水平线的位置的所有取法下的价值总和的最大值。用线段树维护，需要支持区间查询，区间加法和单点取$~\\max~$。单组数据的时间复杂度为$~O(n\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;struct point &#123; int x, y, a, b; bool operator&lt; (const point&amp; p) const &#123; return make_pair(x, y) &lt; make_pair(p.x, p.y); &#125;&#125;;istream&amp; operator&gt;&gt; (istream&amp; is, point&amp; p) &#123; return is &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.a &gt;&gt; p.b; &#125;const int maxn = 1 &lt;&lt; 17;point p[maxn];int pos[maxn];int64_t dp[maxn];int64_t seg[maxn &lt;&lt; 1], tag[maxn &lt;&lt; 1];#define mid ((begin + end) &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (lson ^ 1)#define LEFT begin, mid, lson#define RIGHT mid, end, rsonvoid build(int begin, int end, int index) &#123; seg[index] = tag[index] = 0; if (begin != (mid)) &#123; build(LEFT); build(RIGHT); &#125;&#125;#define val(i) (seg[i] + tag[i])#define push_down() do &#123; tag[lson] += tag[index]; tag[rson] += tag[index]; &#125; while (false)#define push_up() do &#123; seg[index] = max(val(lson), val(rson)); tag[index] = 0; &#125; while (false)int64_t query(int begin, int end, int index, int right) &#123; if (begin &gt;= right) return LLONG_MIN; if (end &lt;= right) return val(index); push_down(); int64_t ret = max(query(LEFT, right), query(RIGHT, right)); push_up(); return ret;&#125;void modify1(int begin, int end, int index, int left, int64_t x) &#123; if (end &lt;= left) return; if (begin &gt;= left) &#123; tag[index] += x; return; &#125; push_down(); modify1(LEFT, left, x); modify1(RIGHT, left, x); push_up();&#125;void modify2(int begin, int end, int index, int pos, int64_t x) &#123; if (begin &gt; pos || end &lt;= pos) return; if (begin == mid) &#123; seg[index] = max(val(index), x); tag[index] = 0; return; &#125; push_down(); modify2(LEFT, pos, x); modify2(RIGHT, pos, x); push_up();&#125;int main() &#123; freopen(\"data.txt\", \"r\", stdin); ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; while (cin &gt;&gt; n) &#123; int64_t sum = 0; vector&lt;int&gt; y; for (int i = 0; i != n; ++i) &#123; cin &gt;&gt; p[i]; sum += p[i].a; y.push_back(p[i].y); &#125; sort(p, p + n); sort(y.begin(), y.end()); for (int i = 0; i != n; ++i) pos[i] = lower_bound(y.begin(), y.end(), p[i].y) - y.begin(); build(0, n, 1); for (int i = 0, j = 0; i != n; ) &#123; int64_t temp = 0; while (j != n &amp;&amp; p[i].x == p[j].x) &#123; temp += p[j].b - p[j].a; dp[j] = max(int64_t(0), query(0, n, 1, pos[j])) + temp; ++j; &#125; while (i != j) &#123; modify1(0, n, 1, pos[i], p[i].b - p[i].a); modify2(0, n, 1, pos[i], dp[i]); ++i; &#125; &#125; cout &lt;&lt; max(int64_t(0), query(0, n, 1, n)) + sum &lt;&lt; '\\n'; &#125;&#125; J. Fraction Comparision题目大意水题。 题解水题。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int64_t x, a, y, b; while (cin &gt;&gt; x &gt;&gt; a &gt;&gt; y &gt;&gt; b) &#123; if (__int128(x) * b == __int128(y) * a) cout &lt;&lt; \"=\\n\"; else if (__int128(x) * b &lt; __int128(y) * a) cout &lt;&lt; \"&lt;\\n\"; else cout &lt;&lt; \"&gt;\\n\"; &#125;&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[{"name":"多校","slug":"多校","permalink":"http://yoursite.com/tags/多校/"}]},{"title":"2019BNU排位四","slug":"2019BNU排位四","date":"2019-07-05T15:37:24.175Z","updated":"2019-07-05T15:40:16.326Z","comments":true,"path":"2019/07/05/2019BNU排位四/","link":"","permalink":"http://yoursite.com/2019/07/05/2019BNU排位四/","excerpt":"","text":"2019BNU排位四 A. Slime Combining题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; vector&lt;int&gt; res; for (int i = 0; i != 20; ++i) if (n &amp; 1 &lt;&lt; i) res.emplace_back(i + 1); reverse(res.begin(), res.end()); cout &lt;&lt; res.front(); for (int i = 1; i != int(res.size()); ++i) cout &lt;&lt; ' ' &lt;&lt; res[i]; cout &lt;&lt; endl;&#125; B. Guess the Permutation题目大意水题。 题解水题。 代码12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; a(n, vector&lt;int&gt;(n)); for (auto&amp; row : a) for (auto&amp; aa : row) cin &gt;&gt; aa; for (int i = 0; i != n; ++i) if (find(a[i].begin(), a[i].end(), n - 1) != a[i].end()) &#123; a[i][i] = n; cout &lt;&lt; a[i].front(); for (int j = 1; j != n; ++j) cout &lt;&lt; ' ' &lt;&lt; a[i][j]; cout &lt;&lt; endl; break; &#125;&#125; C. Constellation题目大意给定$~n~$个点，找出一个三角形满足其它的点都在三角形外部。数据范围$~3\\leq n\\leq100000~$。 题解先取点$~1,2~$构成的直线，找直线上的点和直线外但离直线最近的点。直线上的点直接按坐标排序取头两个和直线外的点即构成所求三角形。排序用冒泡方式。总时间复杂度为$~O(n)~$。 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; vector&lt;pair&lt;int64_t, int64_t&gt;&gt; star(n); vector&lt;int64_t&gt; x(n), y(n), d(n); vector&lt;int&gt; p(&#123; 0, 1 &#125;); for (int i = 0; i != n; ++i) &#123; cin &gt;&gt; x[i] &gt;&gt; y[i]; star[i] = make_pair(x[i], y[i]); d[i] = abs((x[1] - x[0]) * (y[i] - y[0]) - (x[i] - x[0]) * (y[1] - y[0])); if (!d[i] &amp;&amp; i &gt; 1) &#123; p.emplace_back(i); d[i] = LLONG_MAX; &#125; &#125; for (int i = 1; i != int(p.size()); ++i) if (star[p[i]] &lt; star[p[0]]) swap(p[0], p[i]); for (int i = 2; i != int(p.size()); ++i) if (star[p[i]] &lt; star[p[1]]) swap(p[1], p[i]); cout &lt;&lt; p[0] + 1 &lt;&lt; ' ' &lt;&lt; p[1] + 1 &lt;&lt; ' ' &lt;&lt; min_element(d.begin() + 2, d.end()) - d.begin() + 1 &lt;&lt; endl;&#125; D. Hamiltonian Spanning Tree题目大意一个$~n~$阶完全图除了一棵树的边的权值为$~x~$以外，其余边的权值均为$~y~$。输出哈密顿路径的最小值。 题解对于$~x&gt;y~$的情况分类讨论即可。对于$~x\\leq y~$的情况树形$~\\rm DP~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 18;vector&lt;int&gt; adj[maxn];int dp[maxn][2];void dfs(int u, int p) &#123; int cal = 0, mx[2] = &#123; 0 &#125;; for (const auto&amp; v : adj[u]) if (v != p) &#123; dfs(v, u); cal += dp[v][1]; if (mx[1] &lt; dp[v][0] + 1 - dp[v][1]) mx[1] = dp[v][0] + 1 - dp[v][1]; if (mx[0] &lt; mx[1]) swap(mx[0], mx[1]); &#125; dp[u][0] = cal + mx[0]; dp[u][1] = dp[u][0] + mx[1];&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; int64_t x, y; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; for (int i = 1; i != n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].emplace_back(v); adj[v].emplace_back(u); &#125; if (n == 2) return cout &lt;&lt; x &lt;&lt; endl, 0; if (n == 3) return cout &lt;&lt; x + y &lt;&lt; endl, 0; if (x &gt; y) &#123; int mx = 0; for (int u = 1; u &lt;= n; ++u) mx = max(mx, int(adj[u].size())); cout &lt;&lt; (n - 1) * y + (mx == n - 1 ? x - y : 0) &lt;&lt; endl; &#125; else &#123; dfs(1, 0); cout &lt;&lt; (n - 1 - dp[1][1]) * y + dp[1][1] * x &lt;&lt; endl; &#125;&#125; E. Robot Arm题目大意有$~n~$个首尾相连的线段，初始时刻第$~i~$个线段的起点为$~(i-1,0)~$终点为$~(i,0)~$。需要支持两种操作：将一个线段固定起点伸长或固定起点旋转。每次操作输出最后一个线段的终点坐标。数据范围$~1\\leq n\\leq 300000~$。 题解每个线段可以视为一个二维向量，那么每个线段的终点坐标等价于向量的前缀和。线段的伸长操作等价于向量的单点修改，线段的旋转操作等价于向量的后缀旋转。可以用线段树维护。总时间复杂度为$~O(n\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const double PI = acos(double(-1));const int maxn = 1 &lt;&lt; 19;struct Seg &#123; double x, y; int ang; Seg(double _x = 0, double _y = 0, int _a = 0): x(_x), y(_y), ang(_a) &#123;&#125; double rad() const &#123; return PI * (ang % 360) / 180; &#125; double cos() const &#123; return std::cos(rad()); &#125; double sin() const &#123; return std::sin(rad()); &#125; Seg rotate() const &#123; double c = cos(), s = sin(); return Seg(x * c - y * s, x * s + y * c); &#125; Seg operator+ (const Seg&amp; l) const &#123; return Seg(x + l.x, y + l.y); &#125; void increase(double l) &#123; double k = 1 + l / hypot(x, y); x *= k; y *= k; &#125;&#125; seg[maxn &lt;&lt; 1];Seg merge(const Seg&amp; l1, const Seg&amp; l2) &#123; return l1.rotate() + l2.rotate(); &#125;#define mid ((begin + end) &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (lson ^ 1)#define LEFT begin, mid, lson#define RIGHT mid, end, rson#define push_down() do &#123; seg[lson].ang += seg[index].ang; seg[rson].ang += seg[index].ang; &#125; while (false)#define push_up() do &#123; seg[index] = merge(seg[lson], seg[rson]); &#125; while (false)void build(int begin, int end, int index) &#123; if (begin == mid) &#123; seg[index] = Seg(1); return; &#125; build(LEFT); build(RIGHT); push_up();&#125;void modify1(int begin, int end, int index, int pos, double len) &#123; if (begin &gt;= pos || end &lt; pos) return; if (begin == mid) &#123; seg[index].x += len; return; &#125; push_down(); modify1(LEFT, pos, len); modify1(RIGHT, pos, len); push_up();&#125;void modify2(int begin, int end, int index, int pos, int ang) &#123; if (end &lt;= pos) return; if (begin &gt;= pos) &#123; seg[index].ang += ang; return; &#125; push_down(); modify2(LEFT, pos, ang); modify2(RIGHT, pos, ang); push_up();&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; build(0, n, 1); while (m--) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; if (x == 1) modify1(0, n, 1, y , z ); else modify2(0, n, 1, y - 1, 360 - z); Seg res = seg[1].rotate(); cout &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; res.x &lt;&lt; ' ' &lt;&lt; res.y &lt;&lt; '\\n'; &#125;&#125; F. Double Knapsack题目大意给定两个大小为$~n~$的可重集合$~A,B~$，元素值均在$~1~$到$~n~$之间。输出它们两的子集使得两个子集的求和一样。 题解把集合视为序列，子集视为连续子序列。考虑$~A~$的前缀和$~a_0,a_1,\\dots,a_n~$，其中$~a_0=0~$，则$~a~$单增。对于$~B~$同理。不妨设$~a_n\\leq b_n~$。对于每个$~a_i,~i=0,1,\\dots,n~$，通过双指针找出第一个不小于$~a_i~$的$~b_j~$，此时必有$~b_j-a_i\\in[0,n)~$。根据抽屉原理，存在$~i_1&lt; i_2,~j_1&lt; j_2~$，满足$~b_{j_1}-a_{i_1}=b_{j_2}-a_{i_2}~$。此时即构造出两个连续子序列。总时间复杂度为$~O(n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 20;int64_t a[maxn], b[maxn], ii[maxn], jj[maxn];void work(int d, int i, int j) &#123; if (~ii[d]) &#123; cout &lt;&lt; i - ii[d] &lt;&lt; endl; for (int k = ii[d] + 1; k &lt;= i; ++k) cout &lt;&lt; k &lt;&lt; (k == i ? '\\n' : ' ' ); cout &lt;&lt; j - jj[d] &lt;&lt; endl; for (int k = jj[d] + 1; k &lt;= j; ++k) cout &lt;&lt; k &lt;&lt; (k == j ? '\\n' : ' ' ); exit(0); &#125; else &#123; ii[d] = i; jj[d] = j; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(ii, -1, sizeof (ii)); memset(jj, -1, sizeof (jj)); ii[0] = jj[0] = 0; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; a[i] += a[i - 1]; &#125; for (int j = 1; j &lt;= n; ++j) &#123; cin &gt;&gt; b[j]; b[j] += b[j - 1]; &#125; if (a[n] &lt;= b[n]) &#123; for (int i = 1, j = 0; i &lt;= n; ++i) &#123; while (b[j] &lt; a[i]) ++j; work(b[j] - a[i], i, j); &#125; &#125; else &#123; for (int j = 1, i = 0; j &lt;= n; ++j) &#123; while (a[i] &lt; b[j]) ++i; work(a[i] - b[j], i, j); &#125; &#125;&#125; H. 2Char题目大意水题。 代码水题。 题解123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int cnt[26][26] = &#123; 0 &#125;; int n; cin &gt;&gt; n; while (n--) &#123; string str; cin &gt;&gt; str; if (*min_element(str.begin(), str.end()) == *max_element(str.begin(), str.end())) &#123; cnt[str.front() - 'a'][str.front() - 'a'] += str.size(); &#125; else &#123; vector&lt;int&gt; ch; for (int i = 0; i != 26; ++i) if (find(str.begin(), str.end(), char(i + 'a')) != str.end()) ch.emplace_back(i); if (int(ch.size()) &gt; 2) continue; cnt[ch.front()][ch.back()] += str.size(); cnt[ch.back()][ch.front()] += str.size(); &#125; &#125; for (int i = 0; i != 26; ++i) for (int j = 0; j != 26; ++j) if (i != j) cnt[i][j] += cnt[i][i]; for (int i = 0; i != 26; ++i) for (int j = 0; j != 26; ++j) if (i != j) cnt[j][i] += cnt[i][i]; int res = 0; for (int i = 0; i != 26; ++i) res = max(res, *max_element(cnt[i], cnt[i] + 26)); cout &lt;&lt; res &lt;&lt; endl;&#125; I. Anton and Lines题目大意水题。 题解水题。 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; int64_t x1, x2; cin &gt;&gt; n &gt;&gt; x1 &gt;&gt; x2; vector&lt;pair&lt;int64_t, int64_t&gt;&gt; line(n); for (auto&amp; l : line) &#123; cin &gt;&gt; l.second &gt;&gt; l.first; l.first += l.second * x1; &#125; sort(line.begin(), line.end()); for (int i = 1; i != n; ++i) if (line[i - 1].first != line[i].first &amp;&amp; (line[i].first - line[i - 1].first) &lt; (x2 - x1) * (line[i - 1].second - line[i].second)) return cout &lt;&lt; \"YES\" &lt;&lt; endl, 0; cout &lt;&lt; \"NO\" &lt;&lt; endl;&#125; J. Beautiful Function题目大意定义好函数$~f(t)~$为$~t,0,1,\\dots,50~$，或这些好函数的加法、减法、乘法、取绝对值的复合，其中乘法至多使用$~50~$次。现给定$~n~$个圆，要求构造出参数方程$~(f(t),g(t))~$满足对于每个圆，存在$~t=0,1,\\dots,50~$满足$~(f(t),g(t))~$在圆上或者圆内。数据范围$~1\\leq n\\leq50,~0\\leq x,y\\leq50,~2\\leq r\\leq50~$。 题解从特征函数角度入手。构造如下函数 h(t)={\\mid t-(p-1)\\mid}+{\\mid t-(p+1)\\mid}-{\\mid t-p\\mid}-{\\mid t-p\\mid}对于$~t\\in\\Bbb Z~$，不难发现$~f(t=p)=2,~f(t\\neq p)=0~$。那么对于每个圆，由于半径$~r\\geq 2~$，圆内必存在偶整点，令$~p~$等于角标，然后将特征函数乘上横纵坐标后求和即可。 代码1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;string str(string a, string i) &#123; return \"(\" + a + \"*((abs((t-(\" + i + \"-1)))+abs((t-(\" + i + \"+1))))-(abs((t-\" + i + \"))+abs((t-\" + i + \")))))\";&#125;void print(int a[], int n) &#123; if (n != 1) cout &lt;&lt; string(n - 1, '('); cout &lt;&lt; str(to_string(a[0]), to_string(0)); for (int i = 1; i != n; ++i) cout &lt;&lt; \"+\" &lt;&lt; str(to_string(a[i]), to_string(i)) &lt;&lt; \")\"; cout &lt;&lt; endl;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, x[50], y[50], r[50]; cin &gt;&gt; n; for (int i = 0; i != n; ++i) &#123; cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; r[i]; x[i] = (x[i] + 1) &gt;&gt; 1; y[i] = (y[i] + 1) &gt;&gt; 1; &#125; print(x, n); print(y, n);&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[]},{"title":"2019BNU排位三","slug":"2019BNU排位三","date":"2019-07-05T14:55:06.863Z","updated":"2019-07-05T14:55:12.866Z","comments":true,"path":"2019/07/05/2019BNU排位三/","link":"","permalink":"http://yoursite.com/2019/07/05/2019BNU排位三/","excerpt":"","text":"2019BNU排位三 A. Nicoleta and the circle of kids题目大意对于$~n~$个点$~0,1,\\dots,n-1~$，对于每个编号$~u~$，连接它到$~(u+1)\\%n~$一条权值为$~1~$的边，一直到连接它到$~(u+k)\\%n~$一条权值为$~k~$的边。计算这个图的最大生成树的大小。 题解记$~d=\\gcd(n,k)~$，则原图可以分解为$~d~$个环，每个环均有$~\\frac{n}{d}~$个点，并用权值为$~k~$的边连接。那么对于每个环上的点，用$~\\frac{n}{d}-1~$条权值为$~k~$的边连接，再用$~d-1~$条权值为$~k-1~$的边连接，此时的生成树有$~n-d~$条$~k~$边和$~d-1~$条$~k-1~$边。不难证明如果$~k~$边数量超过$~n-d~$条，则必构成环，于是此树为最大生成树。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int64_t N, K; cin &gt;&gt; N &gt;&gt; K; int64_t d = __gcd(N, K); cout &lt;&lt; (N - 1) * K + 1 - d &lt;&lt; endl;&#125; B. Ugly Number题目大意给定一个字符串，问它是否是它的所有循环平移中字典序最小的那个。 题解字符串哈希后可以在$~O(\\log n)~$的时间内比较两个串的字典序，做法是二分出最长公共前缀$~\\rm LCP~$，然后比较下一个字符，总时间复杂度为$~O(n\\log n)~$。或者将字符串分解为若干不降子串，然后判断第一个的字典序是否最小，总时间复杂度为$~O(n)~$。 代码（哈希$~O(n\\log n)~$）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int bas = 8886 ;const int inv = 112339 ;int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;int sub(int a, int b) &#123; return a &lt; b ? a - b + mod : a - b; &#125;int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;const int maxn = 1 &lt;&lt; 20;int pos[maxn], neg[maxn], my_hash[maxn], val[maxn], n;string str;void init() &#123; pos[0] = neg[0] = 1; for (int i = 1; i != maxn; ++i) &#123; pos[i] = mul(pos[i - 1], bas); neg[i] = mul(neg[i - 1], inv); &#125; iota(val, val + maxn, 0); shuffle(val, val + maxn, mt19937(chrono::steady_clock::now().time_since_epoch().count()));&#125;int get_hash(int l, int r) &#123; return mul(sub(my_hash[r], my_hash[l]), neg[l]); &#125;bool check(int p) &#123; if (get_hash(0, n) == get_hash(p, p + n)) return false; int L = 0, R = n; while (R - L != 1) &#123; int m = (L + R) &gt;&gt; 1; get_hash(0, m) == get_hash(p, p + m) ? L = m : R = m; &#125; return str[L] &gt; str[p + L];&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); init(); cin &gt;&gt; n &gt;&gt; str; str += str; cerr &lt;&lt; str &lt;&lt; endl; for (int i = 0; i != (n &lt;&lt; 1); ++i) my_hash[i + 1] = add(my_hash[i], mul(val[str[i]], pos[i])); for (int i = 1; i != n; ++i) if (check(i)) return cout &lt;&lt; \"No\" &lt;&lt; endl, 0; cout &lt;&lt; \"Yes\" &lt;&lt; endl;&#125; 代码（$~O(n)~$）1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; string str; cin &gt;&gt; n &gt;&gt; str; if (n == 1 || *min_element(str.begin(), str.end()) == *max_element(str.begin(), str.end())) return cout &lt;&lt; \"Yes\" &lt;&lt; endl, 0; int pos = 1; while (pos != n &amp;&amp; str[pos] &gt;= str[pos - 1]) ++pos; if (pos == 1) return cout &lt;&lt; \"No\" &lt;&lt; endl, 0; string pre(str.substr(0, pos)); str += str; for (int ppp = pos; ppp &lt; n; ppp = pos) &#123; for (++pos; str[pos] &gt;= str[pos - 1]; ++pos); if (str.substr(ppp, pos - ppp) &lt; pre) return cout &lt;&lt; \"No\" &lt;&lt; endl, 0; &#125; cout &lt;&lt; \"Yes\" &lt;&lt; endl;&#125; C. Two Cats题目大意问整除$~\\prod_{i=1}^{n}v_i~$且因子个数为$~b~$的正整数个数。 题解对所有$~v~$因式分解后把$~\\prod_{i=1}^{n}v_i~$的所有质因数及其幂指数存进std::map，然后对幂指数序列$~\\rm DP~$即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 20;int not_prime[maxn], factor[maxn];vector&lt;int&gt; prime;void init_prime() &#123; for (int i = 2; i != maxn; ++i) &#123; if (!not_prime[i]) prime.emplace_back(factor[i] = i); for (const auto&amp; p : prime) &#123; if (i * p &gt;= maxn) break; not_prime[i * p] = 1; factor[i * p] = p; if (i % p == 0) break; &#125; &#125;&#125;const int mod = 1000000007;int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); init_prime(); map&lt;int64_t, int&gt; cnt; int b, n; cin &gt;&gt; b &gt;&gt; n; while (n--) &#123; int64_t v; cin &gt;&gt; v; for (const auto&amp; p : prime) &#123; if (p &gt; v) break; int tot = 0; while (!(v % p)) &#123; ++tot; v /= p; &#125; if (tot) cnt[p] += tot; &#125; if (v != 1LL) ++cnt[v]; &#125; vector&lt;int&gt; dp(b + 1); dp[1] = 1; for (const auto&amp; f : cnt) &#123; int x = f.second + 1; vector&lt;int&gt; dpp(b + 1); for (int i = 1; i &lt;= b; ++i) for (int j = 1; i * j &lt;= b &amp;&amp; j &lt;= x; ++j) dpp[i * j] = add(dpp[i * j], dp[i]); dp = move(dpp); &#125; cout &lt;&lt; dp.back() &lt;&lt; endl;&#125; D. Checkerboard题目大意水题。 题解水题。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int64_t N, rs, cs, rt, ct; cin &gt;&gt; N &gt;&gt; rs &gt;&gt; cs &gt;&gt; rt &gt;&gt; ct; int64_t dis = abs(rt - rs) + abs(ct - cs); if (!dis) return cout &lt;&lt; (N &gt;&gt; 1) &lt;&lt; endl, 0; cout &lt;&lt; (N &lt; dis ? 0 : ((N - dis) &gt;&gt; 1) + 1) &lt;&lt; endl;&#125; E. Loppinha, the boy who likes sopinha题目大意给定一个$~01~$串，每个长度为$~p~$的连续$~1~$会消耗$~\\frac{p(p+1)}{2}~$单位的蛋白质。但是总共只有$~K~$单位的蛋白质。计算最少把多少$~1~$变为$~0~$使得蛋白质足够。数据范围$~1\\leq N\\leq450,~1\\leq K\\leq10^7~$。 题解用$~f(l,t)~$表示长度为$~l~$的连续$~1~$中间把$~t~$个$~1~$变为$~0~$后蛋白质的最少消耗量，然后对于原串一直模拟，直到$~K~$足够即可。总时间复杂度为$~O(N^2)~$。可以堆优化，总时间复杂度降为$~O(N\\log N)~$。 代码（$~O(N^2)~$）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 9;int cal[maxn], cut[maxn][maxn], len[maxn], tim[maxn], cnt;void init() &#123; iota(cal, cal + maxn, 0); for (int i = 1; i != maxn; ++i) &#123; cut[i][0] = cal[i] += cal[i - 1]; for (int j = 1; j != i; ++j) &#123; int k = (i - j) / (j + 1), l = (i - j) % (j + 1); cut[i][j] = (j + 1 - l) * cal[k] + l * cal[k + 1]; &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); init(); int N, K; string str; cin &gt;&gt; N &gt;&gt; K &gt;&gt; str; str.push_back('0'); int sum = 0; for (int i = 0, j = 0; i &lt;= N; ++i) &#123; if (str[i] == '0') &#123; if (j) &#123; len[cnt++] = j; sum += cal[j]; j = 0; &#125; &#125; else &#123; ++j; &#125; &#125; int res = 0; while (sum &gt; K) &#123; ++res; int val = 0, pos; for (int i = 0; i != cnt; ++i) &#123; int cur = cut[len[i]][tim[i]] - cut[len[i]][tim[i] + 1]; if (val &lt; cur) &#123; val = cur; pos = i; &#125; &#125; sum -= val; ++tim[pos]; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; 代码（$~O(N\\log N)~$）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); const int maxn = 1 &lt;&lt; 9; vector&lt;int&gt; cal(maxn); iota(cal.begin(), cal.end(), 0); for (int i = 1; i != maxn; ++i) cal[i] += cal[i - 1]; auto F = [&amp;] (int l, int t) &#123; if (t &gt; l) return 0; int k1 = (l - t) / (t + 1), k2 = (l - t) % (t + 1); return (t + 1 - k2) * cal[k1] + k2 * cal[k1 + 1]; &#125;; auto G = [&amp;] (int l, int t) &#123; return F(l, t) - F(l, t + 1); &#125;; int N, K; string str; cin &gt;&gt; N &gt;&gt; K &gt;&gt; str; str.push_back('0'); int sum = 0; vector&lt;int&gt; len; for (int i = 0, j = 0; i &lt;= N; ++i) &#123; if (str[i] == '0') &#123; if (j) &#123; len.emplace_back(j); sum += cal[j]; j = 0; &#125; &#125; else &#123; ++j; &#125; &#125; int size = len.size(); vector&lt;int&gt; tim(size); priority_queue&lt;pair&lt;int, int&gt;&gt; heap; for (int i = 0; i != size; ++i) heap.emplace(G(len[i], tim[i]), i); int res = 0; while (sum &gt; K) &#123; ++res; auto top = heap.top(); heap.pop(); sum -= top.first; heap.emplace(G(len[top.second], ++tim[top.second]), top.second); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; F. Number Preference题目大意水题。 题解水题。 代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); const int64_t INF = 1000000000000000000LL; int N, cnt = 0; cin &gt;&gt; N; map&lt;int64_t, int&gt; like; set&lt;int64_t&gt; hate; while (N--) &#123; int t, s; cin &gt;&gt; t &gt;&gt; s; cnt += t == 1; while (s--) &#123; int64_t l; cin &gt;&gt; l; if (t == 1) ++like[l]; else hate.emplace(l); &#125; &#125; if (like.empty()) return cout &lt;&lt; INF - hate.size() &lt;&lt; endl, 0; int res = 0; for (const auto&amp; p : like) res += hate.find(p.first) == hate.end() &amp;&amp; p.second == cnt; cout &lt;&lt; res &lt;&lt; endl;&#125; G. Traffic Management题目大意给定$~N~$辆车的初始位置$~S~$和初始速度$~V~$，均为正方向。如果两辆车相撞，则后方较快的消失。问最后一次撞击的位置。数据范围$~1\\leq N\\leq10^5,~0\\leq S,V\\leq10^9~$。 题解贪心。按初始位置排好序后不难发现后面的车至多与前面的车追尾一次。总时间复杂度为$~O(N\\log N)~$。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int N; cin &gt;&gt; N; vector&lt;pair&lt;double, double&gt;&gt; car(N); for (auto&amp; c : car) cin &gt;&gt; c.first &gt;&gt; c.second; sort(car.begin(), car.end(), greater&lt;pair&lt;double, double&gt;&gt;()); double res = 0; for (int i = 1, j = 0; i != N; ++i) car[j].second &lt; car[i].second ? res = max(res, (car[j].first - car[i].first) / (car[i].second - car[j].second)) : j = i; cout &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; res &lt;&lt; endl;&#125; I. I Will Go题目大意给定一个大小为$~N~$的森林，根节点去聚会不受任何限制，其他节点去聚会的必要条件是它父亲也去了宴会。有$~Q~$次询问，询问$~y~$是否去了聚会，但是被告知$~x~$去了，判断能否根据$~x~$确定答案。数据范围$~2\\leq N\\leq1\\times10^5,~1\\leq Q\\leq2\\times10^5~$。 题解当且仅当$~x~$是$~y~$的后代时，才能确定答案。用$~\\rm DFS~$判断即可。总时间复杂度为$~O(N+Q)~$。 代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000;vector&lt;int&gt; son[maxn], root;int dfs_clock, l[maxn], r[maxn];void dfs(int u) &#123; l[u] = dfs_clock++; for (const auto&amp; v : son[u]) dfs(v); r[u] = dfs_clock; &#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int N, Q; cin &gt;&gt; N &gt;&gt; Q; for (int i = 0; i != N; ++i) &#123; int a; cin &gt;&gt; a; if (~a) son[a].emplace_back(i); else root.emplace_back(i); &#125; for (const auto&amp; r : root) dfs(r); while (Q--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; (l[x] &gt;= l[y] &amp;&amp; r[x] &lt;= r[y] ? \"Yes\\n\" : \"No\\n\"); &#125;&#125; L. PC is for kicking题目大意水题。 题解水题。 代码123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int N, a; cin &gt;&gt; N &gt;&gt; a; vector&lt;vector&lt;int&gt;&gt; adj(N + 1); vector&lt;int&gt; bfs(1, a), vis(N + 1); vis[a] = true; while (--N) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].emplace_back(v); adj[v].emplace_back(u); &#125; int res = 0; while (!bfs.empty()) &#123; ++res; vector&lt;int&gt; next; for (const auto&amp; u : bfs) for (const auto&amp; v : adj[u]) if (!vis[v]) &#123; next.emplace_back(v); vis[v] = 1; &#125; bfs = move(next); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[]},{"title":"2019BNU排位二","slug":"2019BNU排位二","date":"2019-07-05T13:40:55.845Z","updated":"2019-07-05T13:41:02.572Z","comments":true,"path":"2019/07/05/2019BNU排位二/","link":"","permalink":"http://yoursite.com/2019/07/05/2019BNU排位二/","excerpt":"","text":"2019BNU排位二 A. Nate and Actual 3D Girls题目大意水题。 题解水题。 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; vector&lt;int&gt; cnt(26), tot(26); while (n--) &#123; string str; cin &gt;&gt; str; for (const auto&amp; ch : str) ++cnt[(ch - 'A') % 26]; &#125; while (m--) &#123; string str; cin &gt;&gt; str; for (const auto&amp; ch : str) ++tot[(ch - 'A' + k) % 26]; &#125; bool res = true; for (int i = 0; i != 26; ++i) res &amp;= cnt[i] &gt;= tot[i]; cout &lt;&lt; (res ? \"Make her kokoro go doki-doki!\" : \"It is gonna be daijoubu.\") &lt;&lt; endl;&#125; B. Nate and Bones题目大意水题。 题解水题。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m, x; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x; int res = 0; for (int i = n * m; i; --i) &#123; int l; cin &gt;&gt; l; res += __gcd(x, l) != 1; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; C. Nate and Contest Invitation题目大意给定一个朋友关系网。最多能邀请$~k~$个人，被邀请的人的朋友以及朋友的朋友等也会来。输出最多能来多少人。 题解并查集或者$~\\text{DFS}~$维护每个连通块的大小即可。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000;int fa[maxn], sz[maxn];int find(int u) &#123; return u == fa[u] ? u : fa[u] = find(fa[u]); &#125;void merge(int u, int v) &#123; u = find(u); v = find(v); if (u != v) &#123; fa[v] = u; sz[u] += sz[v]; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int u = 0; u != n; ++u) sz[fa[u] = u] = 1; vector&lt;pair&lt;string, string&gt;&gt; fri(m); set&lt;string&gt; name; for (auto&amp; f : fri) &#123; cin &gt;&gt; f.first &gt;&gt; f.second; name.emplace(f.first); name.emplace(f.second); &#125; int temp = 0; map&lt;string, int&gt; id; for (const auto&amp; str : name) id[str] = temp++; for (const auto&amp; f : fri) merge(id[f.first], id[f.second]); vector&lt;int&gt; group; for (int u = 0; u != n; ++u) if (fa[u] == u) group.emplace_back(sz[u]); sort(group.begin(), group.end()); cout &lt;&lt; accumulate(group.begin() + max(0, int(group.size()) - k), group.end(), 0) &lt;&lt; endl;&#125; D. Nate and Dimension-Hopping Money题目大意水题。 题解水题。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); double n, x, y; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; x /= 100; y /= 100; cout &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; n &lt;&lt; ' ' &lt;&lt; n / (1 - y + x * y) &lt;&lt; ' ' &lt;&lt; n * (1 - x) / (1 - y + x * y) &lt;&lt; ' ' &lt;&lt; n * (1 - x - y + x * y) / (1 - y + x * y) &lt;&lt; ' ' &lt;&lt; n * (1 - x - y + x * y) / (1 - y + x * y) &lt;&lt; endl;&#125; F. Nate and Fan Meet-and-Greet题目大意水题。 题解水题。 代码1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int64_t x; cin &gt;&gt; x; cout &lt;&lt; x &lt;&lt; endl;&#125; G. Nate and Game题目大意给定$~n~$个三角形，问一条平行于$~\\rm x~$轴的直线最多穿过多少三角形。 代码扫描线维护每一条线经过的三角形数量。本题由于坐标范围小，可以改用差分数组维护，复杂度可以少一个$~\\log~$。 代码123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; map&lt;int, int&gt; add, sub; set&lt;int&gt; line; while (n--) &#123; int x[3], y[3]; for (int i = 0; i != 3; ++i) cin &gt;&gt; x[i] &gt;&gt; y[i]; int mi = *min_element(y, y + 3), mx = *max_element(y, y + 3); ++add[mi]; ++sub[mx]; line.emplace(mi); line.emplace(mx); &#125; int res = 0, cur = 0; for (const auto&amp; y : line)&#123; res = max(res, cur += add[y]); cur -= sub[y]; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; H. Nate and High School Nakama题目大意总共有$~n~$个点，输出所有可能的图中的连通块数量之和。 题解先计算$~n~$阶完全图的连图子图数量$~f(n)~$。记不连通子图数量为$~g(n)~$，则有$~f(n)+g(n)=2^{\\frac{n(n-1)}{2}}~$。对$~g(n)~$，枚举点$~1~$所在连通块的大小，则有 g(n)=\\sum_{k=1}^{n-1}f(k)\\binom{n-1}{k-1}2^{\\frac{(n-k)(n-k-1)}{2}}即 f(n)=2^{\\frac{n(n-1)}{2}}-\\sum_{k=1}^{n-1}f(k)\\binom{n-1}{k-1}2^{\\frac{(n-k)(n-k-1)}{2}}记全点集为$~S=\\lbrace~1,2,\\dots,n~\\rbrace~$，用边集$~E~$代表图，记$~F(E)~$为$~E~$的所有连通块点集构成的集合。即对任意$~V\\in F(E)~$，有$~V\\subset S~$且$~V~$在$~E~$下连通，并且$~V_1\\cap V_2=\\varnothing,\\forall~V_1\\neq V_2\\in F(E)~$。于是答案为计算$~\\sum_{E}{\\mid F(E)\\mid}~$。对于上述$~V~$与$~E~$的关系，即$~V~$构成$~E~$的连通块点集，记为$~V\\mid E~$。则有如下恒等变换 \\sum_{E}{\\mid F(E)\\mid}=\\sum_{E}\\sum_{V\\in F(E)}1=\\sum_{V\\subset S}\\sum_{V\\mid E}1其中$~\\sum_{V\\mid E}1~$表示点集$~V~$恰好构成一个连通块的图的数量。不难注意到对于$~{\\mid V_1\\mid}={\\mid V_2\\mid}~$，有$~\\sum_{V_1\\mid E}1=\\sum_{V_2\\mid E}1~$。于是把枚举$~S~$的子集$~V~$改为枚举$~\\mid V\\mid~$，则答案为 \\sum_{E}{\\mid F(E)\\mid}=\\sum_{k=1}^{n}\\binom{n}{k}f(k)2^{\\frac{(n-k)(n-k-1)}{2}}代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1000000007;int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;int sub(int a, int b) &#123; return a &lt; b ? a - b + mod : a - b; &#125;int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;int fpow(int a, int64_t n) &#123; int ret = 1; for (n = (n % (mod - 1) + mod - 1) % (mod - 1); n; n &gt;&gt;= 1) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); &#125; return ret;&#125;const int maxn = 1 &lt;&lt; 12;int inv[maxn], fact[maxn], finv[maxn], cal[maxn], res[maxn];void init() &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i != maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); cal[i] = add(cal[i - 1], i - 1); &#125; for (int i = 0; i != maxn; ++i) cal[i] = fpow(2, cal[i]);&#125;int bino(int n, int k) &#123; return mul(fact[n], mul(finv[k], finv[n - k])); &#125;void solve() &#123; res[1] = 1; for (int n = 2; n != maxn; ++n) &#123; res[n] = cal[n]; for (int k = 1; k != n; ++k) res[n] = sub(res[n], mul(res[k], mul(bino(n - 1, k - 1), cal[n - k]))); &#125;&#125;int main() &#123; init(); solve(); int n; cin &gt;&gt; n; int ans = 0; for (int k = 1; k &lt;= n; ++k) ans = add(ans, mul(res[k], mul(bino(n, k), cal[n - k]))); cout &lt;&lt; ans &lt;&lt; endl;&#125; I. Nate and Integer Coefficient题目大意已知$~a~$且$~x~$满足$~x^2-ax+1=0~$，求$~b~$满足$~x^{2n}-bx^n+1=0~$。数据范围$~1\\leq T\\leq10^5,~{\\mid a\\mid},{\\mid n\\mid}\\leq10^{18}~$。 题解不难发现$~\\pm n~$的答案是一样的，下面只考虑$~n\\geq 0~$的情况。记$~a_k~$满足$~x^{2k}-a_kx^k+1=0~$。有$~a_0=2,~a_1=a~$。于是对于$~0\\leq k_1\\leq k_2~$，有 a_{k_1}x^{k_1}=x^{2k_1}+1\\\\a_{k_2}x^{k_2}=x^{2k_2}+1两式相乘，得 \\begin{aligned} a_{k_1}a_{k_2}x^{k_1+k_2}&=(x^{2k_1}+1)(x^{2k_2}+1)\\\\ &=(x^{2(k_1+k_2)}+1)+x^{2k_1}(x^{2(k_2-k_1)}+1)\\\\ &=a_{k1+k2}x^{k_1+k_2}+x^{2k_1}\\cdot a_{k_2-k_1}x^{k_2-k_1}\\\\ &=(a_{k_1+k_2}+a_{k_2-k_1})x^{k_1+k_2} \\end{aligned}取$~k_1=n,~k_2=n+1~$，于是得到序列$~\\lbrace~a_n~\\rbrace~$的线性递推式 a_{n+1}=a_1a_n-a_{n-1}=a\\cdot a_n-a_{n-1}接下来矩阵快速幂即可。总时间复杂度为$~O(T\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1000000007;int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;void mul(int A[2][2], int B[2][2], int C[2][2]) &#123; for (int i = 0; i != 2; ++i) for (int j = 0; j != 2; ++j) &#123; C[i][j] = 0; for (int k = 0; k != 2; ++k) C[i][j] = add(C[i][j], mul(A[i][k], B[k][j])); &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int T; cin &gt;&gt; T; while (T--) &#123; int64_t a, n; cin &gt;&gt; a &gt;&gt; n; int A = (a % mod + mod) % mod; if (!n) &#123; cout &lt;&lt; 2 &lt;&lt; '\\n'; continue; &#125; int bas[2][2] = &#123; &#123; A, mod - 1 &#125;, &#123; 1, 0 &#125; &#125;, mat[2][2] = &#123; &#123; 1, 0 &#125;, &#123; 0, 1 &#125; &#125;, tmp[2][2]; for (n = abs(n); n; n &gt;&gt;= 1) &#123; if (n &amp; 1) &#123; mul(mat, bas, tmp); memcpy(mat, tmp, sizeof (tmp)); &#125; mul(bas, bas, tmp); memcpy(bas, tmp, sizeof (tmp)); &#125; cout &lt;&lt; add(mul(mat[1][0], A), add(mat[1][1], mat[1][1])) &lt;&lt; '\\n'; &#125;&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[]},{"title":"2019BNU排位一","slug":"2019BNU排位一","date":"2019-07-05T12:24:05.452Z","updated":"2019-07-05T12:24:15.483Z","comments":true,"path":"2019/07/05/2019BNU排位一/","link":"","permalink":"http://yoursite.com/2019/07/05/2019BNU排位一/","excerpt":"","text":"2019BNU排位一 A. Mental Rotation题目大意给定一个图，输出旋转后的样子。 题解模拟即可，具体见代码。 代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); char map[128]; map['.'] = '.'; map['&lt;'] = '^'; map['&gt;'] = 'v'; map['^'] = '&gt;'; map['v'] = '&lt;'; int N; string str; cin &gt;&gt; N &gt;&gt; str; vector&lt;string&gt; pic(N); for (auto&amp; row : pic) cin &gt;&gt; row; int cnt = 128; for (const auto&amp; ch : str) ch == 'R' ? ++cnt : --cnt; auto rotate = [&amp;] () &#123; vector&lt;string&gt; tmp(N); for (int i = 0; i != N; ++i) &#123; tmp[i].resize(N); for (int j = 0; j != N; ++j) tmp[i][j] = pic[N - 1 -j][i]; &#125; pic = move(tmp); for (auto&amp; row : pic) for (auto&amp; ch : row) ch = map[ch]; &#125;; for (cnt &amp;= 3; cnt; --cnt) rotate(); for (const auto&amp; row : pic) cout &lt;&lt; row &lt;&lt; endl;&#125; B. SpongeBob SquarePants题目大意水题。 题解水题。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int T; cin &gt;&gt; T; while (T--) &#123; int w, h; cin &gt;&gt; w &gt;&gt; h; cout &lt;&lt; (w == h ? \"YES\\n\" : \"NO\\n\"); &#125;&#125; C. I Don’t Want To Pay For The Late Jar!题目大意水题。 题解水题。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int D; cin &gt;&gt; D; for (int cas = 1; cas &lt;= D; ++cas) &#123; int N, S, res = -1; cin &gt;&gt; N &gt;&gt; S; while (N--) &#123; int f, t; cin &gt;&gt; f &gt;&gt; t; res = max(res, f - max(0, t - S)); &#125; cout &lt;&lt; \"Case #\" &lt;&lt; cas &lt;&lt; \": \" &lt;&lt; res &lt;&lt; endl; &#125;&#125; E. Optimal Slots题目大意输出$~01~$背包的字典序最小方案。 题解裸$~01~$背包，可以用std::bitset优化。 代码123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int T, N; while (true) &#123; cin &gt;&gt; T; if (!T) break; cin &gt;&gt; N; vector&lt;int&gt; a(N), cal(N); for (auto&amp; aa : a) cin &gt;&gt; aa; vector&lt;bitset&lt;(1 &lt;&lt; 14)&gt;&gt; dp0(N + 1), dp1(N + 1); dp1[N].set(0); for (int i = N - 1; ~i; --i) &#123; dp0[i] = dp0[i + 1] | dp1[i + 1]; dp1[i] = dp0[i] &lt;&lt; a[i]; for (int j = T; ~j; --j) if (dp1[i].test(j)) &#123; cal[i] = j; break; &#125; &#125; vector&lt;int&gt; res; for (int sum = *max_element(cal.begin(), cal.end()), p = -1; sum; sum -= a[p]) &#123; do &#123; ++p; &#125; while (!dp1[p].test(sum)); res.emplace_back(a[p]); &#125; for (const auto&amp; ans : res) cout &lt;&lt; ans &lt;&lt; ' '; cout &lt;&lt; accumulate(res.begin(), res.end(), 0) &lt;&lt; '\\n'; &#125;&#125; F. Military Class题目大意二分图，其中两行之间编号之差的绝对值不超过$~e~$的可以连边，同时给出了$~k~$对边不能连。问一共有多少完美匹配。数据范围$~1\\leq n\\leq2000,~0\\leq e\\leq4,~0\\leq k\\leq2000~$。 题解状压$~\\text{DP}~$。记录半径为$~4~$总共$~9~$个点的匹配状态，总时间复杂度为$~O(9\\cdot2^9\\cdot n)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 11;const int maxs = 1 &lt;&lt; 9 ;int ok[maxn], dp[maxn][maxs];const int mod = 1000000007;int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, e, k; cin &gt;&gt; n &gt;&gt; e &gt;&gt; k; for (int i = 0; i != n; ++i) ok[i] = ((1 &lt;&lt; min(e + 5, n - i + 4)) - 1) ^ ((1 &lt;&lt; (4 - min(e, i))) - 1); while (k--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; if (abs(u - v) &lt;= e) ok[u - 1] &amp;= ~(1 &lt;&lt; (v - u + 4)); &#125; dp[0][((1 &lt;&lt; min(9, n + 4)) - 1) ^ ((1 &lt;&lt; 4) - 1)] = 1; for (int i = 0; i != n; ++i) for (int s = 0; s != maxs; ++s) if (dp[i][s]) &#123; for (int j = 1; j != (1 &lt;&lt; 9); j &lt;&lt;= 1) if (ok[i] &amp; s &amp; j) &#123; int ss = s ^ j; if (ss &amp; 1) continue; ss &gt;&gt;= 1; if (i + 5 &lt; n) ss ^= 1 &lt;&lt; 8; dp[i + 1][ss] = add(dp[i + 1][ss], dp[i][s]); &#125; &#125; for (int i = 1; i != maxs; ++i) assert(!dp[n][i]); cout &lt;&lt; dp[n][0] &lt;&lt; endl;&#125; H. Are You Safe?题目大意求一个凸包并判断一些点是否在凸包内。 题解直接抄板子。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;struct Point &#123; int x, y; Point(int _x = 0, int _y = 0): x(_x), y(_y) &#123;&#125; bool operator&lt; (const Point&amp; p) const &#123; return x == p.x ? y &lt; p.y : x &lt; p.x; &#125; Point operator- (const Point&amp; p) const &#123; return Point(x - p.x, y - p.y); &#125; int operator^ (const Point&amp; p) const &#123; return x * p.y - p.x * y; &#125;&#125; c[64], p[64], h[64];int convex(Point *p, int n, Point* ch) &#123; sort(p, p + n); int m = 0; for (int i = 0; i != n; ++i) &#123; while (m &gt; 1 &amp;&amp; ((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) &lt;= 0) --m; ch[m++] = p[i]; &#125; int k = m; for (int i = n - 2; ~i; --i) &#123; while (m &gt; k &amp;&amp; ((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) &lt;= 0) --m; ch[m++] = p[i]; &#125; if (n &gt; 1) --m; return m;&#125;int main() &#123; int T; cin &gt;&gt; T; for (int cas = 1; cas &lt;= T; ++cas) &#123; int C, P; cin &gt;&gt; C &gt;&gt; P; for (int i = 0; i != C; ++i) cin &gt;&gt; c[i].x &gt;&gt; c[i].y; for (int i = 0; i != P; ++i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y; int n = convex(c, C, h); cout &lt;&lt; \"Case \" &lt;&lt; cas &lt;&lt; endl; for (int i = 0; i != n; ++i) cout &lt;&lt; h[i].x &lt;&lt; ' ' &lt;&lt; h[i].y &lt;&lt; endl; cout &lt;&lt; h-&gt;x &lt;&lt; ' ' &lt;&lt; h-&gt;y &lt;&lt; endl; p[P] = p[0]; int area = 0; for (int i = 0; i != n; ++i) area += h[i] ^ h[i + 1]; area = abs(area); for (int i = 0; i != P; ++i) &#123; cout &lt;&lt; p[i].x &lt;&lt; ' ' &lt;&lt; p[i].y &lt;&lt; \" is \"; int calc = 0; for (int j = 0; j != n; ++j) calc += abs((h[j] - p[i]) ^ (h[j + 1] - p[i])); if (area == calc) cout &lt;&lt; \"un\"; cout &lt;&lt; \"safe!\\n\"; &#125; cout &lt;&lt; endl; &#125;&#125; I. To Crash Or Not To Crash题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); string str; while (cin &gt;&gt; str) &#123; auto p = str.find('='); if (~p) &#123; for (++p; p != str.size(); ++p) if (str[p] != '.') return cout &lt;&lt; str[p] &lt;&lt; endl, 0; cout &lt;&lt; \"You shall pass!!!\" &lt;&lt; endl; &#125; &#125;&#125; J. Kitchen Plates题目大意给定一组大小关系，问是否存在一种排序满足所有的关系。 题解拓扑排序。 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); vector&lt;int&gt; adj[5]; int deg[5] = &#123; 0 &#125;; for (int i = 0; i != 5; ++i) &#123; string str; cin &gt;&gt; str; int u = str.front() - 'A', v = str.back() - 'A'; if (str[1] == '&gt;') swap(u, v); adj[u].emplace_back(v); ++deg[v]; &#125; vector&lt;int&gt; topo; for (int u = 0; u != 5; ++u) if (!deg[u]) topo.emplace_back(u); for (int i = 0; i != int(topo.size()); ++i) for (const auto&amp; u : adj[topo[i]]) if (!--deg[u]) topo.emplace_back(u); if (int(topo.size()) != 5) return cout &lt;&lt; \"impossible\" &lt;&lt; endl, 0; for (const auto&amp; u : topo) cout &lt;&lt; char(u + 'A'); cout &lt;&lt; endl;&#125; K. Help The Support Lady题目大意有$~n~$个任务，用时为$~t~$，期限为$~2t~$。问最多能做多少任务。 题解贪心。对于每个任务，在$~t~$时刻之前开始才能完成，否则直接抛弃。对$~t~$升序，每次做当前可以完成的用时最短的任务即可。 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int m; cin &gt;&gt; m; for (int cas = 1; cas &lt;= m; ++cas) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; t(n); for (auto&amp; tt : t) cin &gt;&gt; tt; sort(t.begin(), t.end()); int res = 0; for (int i = 0, j = 0; i != n; ++i) &#123; if (j &lt;= t[i]) &#123; j += t[i]; ++res; &#125; &#125; cout &lt;&lt; \"Case #\" &lt;&lt; cas &lt;&lt; \": \" &lt;&lt; res &lt;&lt; endl; &#125;&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[]},{"title":"2019BNU排位热身","slug":"2019BNU排位热身","date":"2019-07-05T02:44:42.084Z","updated":"2019-07-05T12:08:04.617Z","comments":true,"path":"2019/07/05/2019BNU排位热身/","link":"","permalink":"http://yoursite.com/2019/07/05/2019BNU排位热身/","excerpt":"","text":"2019BNU排位热身 A. Pineapple Incident题目大意水题。 题解水题。 代码1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t, s, x; cin &gt;&gt; t &gt;&gt; s &gt;&gt; x; cout &lt;&lt; (t &lt;= x &amp;&amp; (x - t) % s &lt;= 1 &amp;&amp; t + 1 != x ? \"YES\" : \"NO\") &lt;&lt; endl;&#125; B. Barnicle题目大意给定一个科学记数法数字字符串，转化为小数表示。 题解用字符&#39;e&#39;和&#39;.&#39;把原串截成整数部分、小数部分和进位部分$~3~$段，然后可以利用std::stringstream把进位部分转化为整数，把小数部分的前缀移动至整数部分的后缀，处理完前导零和后导零即可。 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); string str; cin &gt;&gt; str; int b, p1 = str.find('.'), p2 = str.find('e'); string a(str.substr(0, p1)), d(str.substr(p1 + 1, p2 - p1 - 1)); stringstream ss(str.substr(p2 + 1)); ss &gt;&gt; b; int bb = min(b, p2 - p1 - 1); b -= bb; a += d.substr(0, bb); d = d.substr(bb); while (!d.empty() &amp;&amp; d.back() == '0') d.pop_back(); if (d.empty()) cout &lt;&lt; a &lt;&lt; string(b, '0') &lt;&lt; endl; else cout &lt;&lt; a &lt;&lt; '.' &lt;&lt; d &lt;&lt; endl;&#125; C. Lorenzo Von Matterhorn题目大意在一棵完全二叉树上支持路径修改和路径查询操作。数据范围$~1\\leq q\\leq1000,~1\\leq u,v\\leq10^{18},~1\\leq w\\leq10^9~$。 题解注意到这棵树的深度至为$~60~$层，以及总操作数不超过$~1000~$，那么涉及到的点或边的总量不会超过$~1.2\\times10^6~$。于是可以用std::map暴力存权值，问题的关键变为如何在完全二叉树上确定路径。事实上只要当$~u\\neq v~$时，一直让较大的那个数字除以$~2~$下取整即可，边可以用它的儿子点编号表示。总复杂度$~O(60q\\log q)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int q; cin &gt;&gt; q; map&lt;int64_t, int64_t&gt; cost; while (q--) &#123; int op; int64_t u, v, w; cin &gt;&gt; op &gt;&gt; u &gt;&gt; v; if (op == 1) &#123; cin &gt;&gt; w; while (u != v) &#123; if (u &lt; v) &#123; cost[v] += w; v &gt;&gt;= 1; &#125; else &#123; cost[u] += w; u &gt;&gt;= 1; &#125; &#125; &#125; else &#123; int64_t res = 0; while (u != v) &#123; if (u &lt; v) &#123; res += cost[v]; v &gt;&gt;= 1; &#125; else &#123; res += cost[u]; u &gt;&gt;= 1; &#125; &#125; cout &lt;&lt; res &lt;&lt; '\\n'; &#125; &#125;&#125; D. Puzzles题目大意给定一棵树的形状，根节点为$~1~$，在随机$~\\text{DFS}~$过程下，问每个节点的$~\\text{DFS}~$序的期望$~f(u)~$。数据范围$~1\\leq n\\leq10^5~$。 题解先进行一次$~\\text{DFS}~$过程线性处理出每个节点为根的子树的大小$~s(u)~$。根节点的期望值一定是$~1~$。假设已知节点$~p~$的期望值，那么考虑它的儿子$~u~$的期望值$~f(p)~$。对于另一个儿子$~v~$，如果先遍历了$~v~$则$~u~$的$~\\text{DFS}~$序需要增加$~s(v)~$。注意到对于$~u~$的每个兄弟$~v~$，它们遍历的前后顺序的概率各占一半，且相互独立，于是有$~f(u)=f(p)+\\frac{1}{2}\\sum_{v\\in son(p)}^{u\\neq v}s(v)+1~$。再执行一遍$~\\text{DFS}~$过程即可，总时间复杂度为$~O(n)~$。 代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100001;vector&lt;int&gt; son[maxn];double sz[maxn], ord[maxn];int dfs1(int u) &#123; for (const auto&amp; v : son[u]) sz[u] += dfs1(v); return sz[u] += 1; &#125;void dfs2(int u) &#123; ord[u] += 1; for (const auto&amp; v : son[u]) &#123; ord[v] = ord[u] + (sz[u] - sz[v] - 1) / 2; dfs2(v); &#125; &#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int u = 2; u &lt;= n; ++u) &#123; int p; cin &gt;&gt; p; son[p].emplace_back(u); &#125; dfs1(1); dfs2(1); for (int u = 1; u != n; ++u) cout &lt;&lt; fixed &lt;&lt; setprecision(7) &lt;&lt; ord[u] &lt;&lt; ' '; cout &lt;&lt; ord[n] &lt;&lt; endl;&#125; E. PLEASE题目大意有$~3~$个杯子，初始球在中间，每次等概率随机交换左边和中间或者右边和中间。问在$~n=\\prod_{i=1}^{k}a_i~$次交换后球在中间的概率是多少，用即约分数取模后表出。数据范围$~1\\leq k\\leq10^5,~1\\leq a\\leq10^{18}~$。 题解设第$~i~$次交换后球在中间的概率为$~b_i~$，则有$~b_0=1,~b_1=0~$。不难得出关系式 b_{n+1}=\\frac{1-b_n}{2}及 b_{n+1}-\\frac{1}{3}=-\\frac{1}{2}\\left(b_n-\\frac{1}{3}\\right)于是得出通项公式 \\begin{aligned} b_n &=\\frac{1}{3}+\\frac{2}{3}\\left(-\\frac{1}{2}\\right)^n \\\\ &=\\frac{\\frac{1}{3}\\left(2^{n-1}-(-1)^{n-1}\\right)}{2^{n-1}} \\end{aligned}于有$~p=\\frac{1}{3}(2^{n-1}-(-1)^{n-1}),q=2^{n-1}~$且满足$~(p,q)=1~$。接下来欧拉降幂和快速幂即可，总时间复杂度为$~O(k+\\log mod)~$。 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1000000007;const int neg = 1000000006;const int inv2 = 500000004;const int inv3 = 333333336;int add(int a, int b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;int sub(int a, int b) &#123; return a &lt; b ? a - b + mod : a - b; &#125;int mul(int a, int b) &#123; return 1LL * a * b % mod; &#125;int fpow(int a, int n) &#123; int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int k; cin &gt;&gt; k; int64_t aa = 1; int par = 1; while (k--) &#123; int64_t a; cin &gt;&gt; a; aa = a % neg * aa % neg; par &amp;= a; &#125; int two = fpow(2, aa); cout &lt;&lt; sub(mul(two, inv2), mul(par ? add(two, 1) : sub(two, 1), inv3)) &lt;&lt; '/' &lt;&lt; mul(two, inv2) &lt;&lt; endl;&#125; F. Link/Cut Tree题目大意输出$~[l,r]~$中的所有的$~k~$的幂。数据范围$~1\\leq l\\leq r\\leq10^{18},~2\\leq k\\leq10^9~$。 题解水题。注意不要爆long long。 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const int64_t INF = 1LL &lt;&lt; 60; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int64_t l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; vector&lt;int64_t&gt; res; int64_t cur = 1; while (cur &lt; l) cur = double(cur) * k &gt; INF ? INF : cur * k; while (cur &lt;= r) &#123; res.emplace_back(cur); cur = double(cur) * k &gt; INF ? INF : cur * k; &#125; if (res.empty()) return cout &lt;&lt; -1 &lt;&lt; endl, 0; cout &lt;&lt; res.front(); for (int i = 1; i != int(res.size()); ++i) cout &lt;&lt; ' ' &lt;&lt; res[i]; cout &lt;&lt; endl;&#125; G. Gena’s Code题目大意给定一组数字，至多一个不是$~10~$的幂，求它们的积。 题解找出不是$~10~$的幂的特殊数字串然后根据其它串的长度在它后面补$~0~$即可。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; string head(\"1\"); int l = 0; while (n--) &#123; string str; cin &gt;&gt; str; if (str == \"0\") return cout &lt;&lt; 0 &lt;&lt; endl, 0; if (str == \"1\" + string(str.size() - 1, '0')) l += str.size() - 1; else head = str; &#125; cout &lt;&lt; head &lt;&lt; string(l, '0') &lt;&lt; endl;&#125; H. Peter and Snow Blower题目大意给定一个多边形和一个旋转中心，输出多边形绕旋转中心一周后扫过的面积。 题解计算几何。只要求出多边形中离旋转中心最远的距离和最近的距离。具体见代码。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;struct Point &#123; double x, y; Point(double _x = 0, double _y = 0): x(_x), y(_y) &#123;&#125;&#125;;istream&amp; operator&gt;&gt; (istream&amp; is, Point&amp; p) &#123; return is &gt;&gt; p.x &gt;&gt; p.y; &#125;double dis2(Point p1, Point p2) &#123; return hypot(p1.x - p2.x, p1.y - p2.y); &#125; int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; double px, py; cin &gt;&gt; n &gt;&gt; px &gt;&gt; py; vector&lt;double&gt; x(n), y(n); double R = 0, r = 1e18; for (int i = 0; i != n; ++i) &#123; cin &gt;&gt; x[i] &gt;&gt; y[i]; x[i] -= px; y[i] -= py; double d2 = x[i] * x[i] + y[i] * y[i]; R = max(R, d2); r = min(r, d2); &#125; x.emplace_back(x.front()); y.emplace_back(y.front()); for (int i = 0; i != n; ++i) &#123; if (x[i + 1] * (x[i + 1] - x[i]) + y[i + 1] * (y[i + 1] - y[i]) &lt; 0) continue; if (x[i] * (x[i] - x[i + 1]) + y[i] * (y[i] - y[i + 1]) &lt; 0) continue; double d = fabs(x[i + 1] * y[i] - x[i] * y[i + 1]) / hypot(x[i + 1] - x[i], y[i + 1] - y[i]); R = max(R, d * d); r = min(r, d * d); &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(7) &lt;&lt; acos(double(-1)) * (R - r) &lt;&lt; endl;&#125; I. Skills题目大意给定能力序列$~a_1,a_2,\\dots,a_n~$并且还可以再操作$~m~$次$~+1~$，序列值上界为$~A~$。最终序列的权值计算为 (\\sum_{i=1}^{n}{\\Bbb I(a_i=A)})\\times c_f+\\min(a1,a2,\\dots,a_n)\\times c_m输出最大的权值以及此时的新序列$~\\hat{a}_1,\\hat{a}_2,\\dots,\\hat{a}_n~$。数据范围$~1\\leq n\\leq100000,~1\\leq A\\leq10^9,~0\\leq c_f,c_m\\leq1000,~0\\leq m\\leq10^{15}~$。 题解先对序列$~a_1,a_2,\\dots,~a_n~$升序，处理好前缀和后缀和。权值最大化的方案一定是让一个前缀增加至一个相等的新最小值，后缀增加至$~A~$。那么枚举多长的后缀变为$~A~$，可以二分得到新的最小值最大可以是多少，更新答案即可。总时间复杂度为$~O(n\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; int64_t A, cf, cm, m; cin &gt;&gt; n &gt;&gt; A &gt;&gt; cf &gt;&gt; cm &gt;&gt; m; vector&lt;int64_t&gt; a(n), p(n), suf(n), pre(n); for (auto&amp; aa : a) cin &gt;&gt; aa; iota(p.begin(), p.end(), 0); sort(p.begin(), p.end(), [&amp;] (int i, int j) &#123; return a[i] &lt; a[j]; &#125;); suf.front() = A - a[p.back()]; for (int i = 1; i != n; ++i) suf[i] = suf[i - 1] + A - a[p[n - i - 1]]; pre.front() = a[p.front()]; for (int i = 1; i != n; ++i) pre[i] = pre[i - 1] + a[p[i]]; for (int i = 0; i != n; ++i) pre[i] = i * a[p[i]] + a[p[i]] - pre[i]; int pos1 = upper_bound(pre.begin(), pre.end(), m) - pre.begin(), pos2 = 0; int64_t mii = min(A, a[p[pos1 - 1]] + (m - pre[pos1 - 1]) / pos1), res = mii * cm; for (int i = 0; i != n; ++i) &#123; int64_t rem = m - suf[i]; if (rem &lt; 0) break; auto ite = upper_bound(pre.begin(), pre.end(), rem); int l = min(n - i - 1, (upper_bound(pre.begin(), pre.end(), rem) - pre.begin())); int64_t mi = min(A, l ? a[p[l - 1]] + (rem - pre[l - 1]) / l : A); int64_t ans = i * cf + cf + mi * cm; if (res &lt;= ans) &#123; res = ans; mii = mi; pos1 = l; pos2 = i + 1; &#125; &#125; while (pos1--) &#123; m -= mii - a[p[pos1]]; a[p[pos1]] = mii; &#125; while (pos2) &#123; m -= A - a[p[n - pos2]]; a[p[n - pos2--]] = A; &#125; cout &lt;&lt; res &lt;&lt; endl; cout &lt;&lt; a.front(); for (int i = 1; i != n; ++i) cout &lt;&lt; ' ' &lt;&lt; a[i]; cout &lt;&lt; endl;&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[]},{"title":"2019BNUCPC","slug":"2019BNUCPC","date":"2019-05-17T10:17:33.334Z","updated":"2019-05-24T08:32:57.787Z","comments":true,"path":"2019/05/17/2019BNUCPC/","link":"","permalink":"http://yoursite.com/2019/05/17/2019BNUCPC/","excerpt":"","text":"2019BNUCPC A. 足球题目大意水题。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; size_t T; cin &gt;&gt; T; while (T--) &#123; vector&lt;int&gt; a(23); for (auto&amp; aa : a) cin &gt;&gt; aa; cout &lt;&lt; accumulate(a.begin(), a.end(), 0) * *min_element(a.begin(), a.end()) &lt;&lt; endl; &#125;&#125; B. 进制题目大意水题。 题解水题。 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;int64_t&gt; sum(18); for (int i = 2; i &lt;= 10; ++i) &#123; int64_t base = 1; for (auto&amp; s : sum) &#123; s += base; base *= i; &#125; &#125; size_t T; cin &gt;&gt; T; while (T--) &#123; string str; cin &gt;&gt; str; reverse(str.begin(), str.end()); int64_t res = 0; for (size_t i = 0; i != str.size(); ++i) if (str[i] == '1') res += sum[i]; cout &lt;&lt; res &lt;&lt; '\\n'; &#125;&#125; C. 寻找路径题目大意改编自$~\\text{2019 Google Code Jam Qualification T2}~$。要从$~n\\times m~$的网格图的左下角走到右上角，只能向上或者向右。现给定一个由$~n~$个向上和$~m~$个向右组成的路径，问是否存在另一条路径与给定路径没有重复的边，存在则输出任意一种。 题解如果第一步和最后一步不一样，则显然可以输出贴着右下方或者左上方的路径。如果一样，不妨设第一步和最后一步都是向上，那么如果新的路径存在，则它的第一步和最后一步必须向右。如果在给定路径上存在两个连续的向右，那么用$~n~$个向上从这两个向右的中点穿过，前面和后面均为向右即可。如果不存在，很容易发现答案也是不存在的。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; size_t T; cin &gt;&gt; T; while (T--) &#123; size_t n, m; string str, res; cin &gt;&gt; n &gt;&gt; m &gt;&gt; str; if (str.front() == 'U' &amp;&amp; str.back() == 'U') &#123; for (size_t i = 2; i != n + m; ++i) if (str[i] == 'R' &amp;&amp; str[i - 1] == 'R') &#123; res = string(count(str.begin(), str.begin() + i, 'R'), 'R') + string(n, 'U'); res.append(n + m - res.size(), 'R'); break; &#125; if (res.empty()) res = \"impossible\"; &#125; if (str.front() == 'U' &amp;&amp; str.back() == 'R') &#123; res = string(m, 'R') + string(n, 'U'); &#125; if (str.front() == 'R' &amp;&amp; str.back() == 'U') &#123; res = string(n, 'U') + string(m, 'R'); &#125; if (str.front() == 'R' &amp;&amp; str.back() == 'R') &#123; for (size_t i = 2; i != n + m; ++i) if (str[i] == 'U' &amp;&amp; str[i - 1] == 'U') &#123; res = string(count(str.begin(), str.begin() + i, 'U'), 'U') + string(m, 'R'); res.append(n + m - res.size(), 'U'); break; &#125; if (res.empty()) res = \"impossible\"; &#125; cout &lt;&lt; res &lt;&lt; endl; &#125;&#125; D. 选数字题目大意给定序列$~a_1,a_2,\\dots,a_n~$，问等概率选$~k~$个数字中最小值的期望乘以$~\\binom{n}{k}~$的值。 题解题目等价于询问对于所有的$~k~$个数字的选法中最小值的总和。考虑第$~i~$小的数字的贡献次数，相当于先选这个数再在第$~i+1~$小至第$~n~$小（最大）的数字中选剩下的$~k-1~$个数字，这个值是$~\\binom{n-i}{k-1}~$。最后全部加起来即可。 代码123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const size_t maxn = 1 &lt;&lt; 10; const uint64_t mod = 1000000007; auto mul = [&amp;mod] (const uint64_t&amp; a, const uint64_t&amp; b) &#123; return a * b % mod; &#125;; vector&lt;uint64_t&gt; inv(maxn), fact(maxn), finv(maxn); inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (size_t i = 2; i != maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125; size_t T; cin &gt;&gt; T; while (T--) &#123; size_t n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;uint64_t&gt; a(n); for (auto&amp; aa : a) cin &gt;&gt; aa; sort(a.begin(), a.end()); uint64_t res = 0; for (size_t i = 0; i + k &lt;= n; ++i) res += mul(mul(a[i], fact[n - i - 1]), mul(finv[k - 1], finv[n - k - i])); cout &lt;&lt; res % mod &lt;&lt; endl; &#125;&#125; E. 高等术学题目大意场上初始有$~1~$号怪兽，每个怪兽死亡都会召唤若干新的怪兽到场上，共$~n~$只，血量为$~h_1,h_2,\\dots,h_n~$。攻击为$~\\text{AOE}~$模式，即每次攻击场上所有怪兽受到相同伤害。攻击力为$~d_1,d_2,\\dots,d_m~$的循环。每次攻击需要花费$~1~$的代价，但是如果本次攻击消灭的至少$~1~$只怪兽，则下次攻击免费。问消灭所有怪兽的总代价。数据范围$~1\\leq n\\leq10^5,~1\\leq m\\leq10^5,~1\\leq h\\leq10^9,~1\\leq d\\leq10^9~$。 题解显然要用堆来维护当前场上血量最少的怪。然后计算需要多少次攻击时现考虑需要多少个$~m~$次的攻击，然后在$~d~$的前缀和上二分。一个技巧是在把新的怪兽入堆时，把它的血量加上之前攻击力的总和。总时间复杂度为$~O(n(\\log n+\\log m))~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); size_t n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;uint64_t&gt; h(n), d(m); vector&lt;vector&lt;size_t&gt;&gt; next(n); for (auto&amp; hh : h) cin &gt;&gt; hh; for (auto&amp; dd : d) cin &gt;&gt; dd; auto p = d; for (size_t i = 1; i != m; ++i) p[i] += p[i - 1]; for (auto&amp; vec : next) &#123; size_t k; cin &gt;&gt; k; vec.resize(k); for (auto&amp; nn : vec) cin &gt;&gt; nn, --nn; &#125; priority_queue&lt;pair&lt;uint64_t, size_t&gt;, vector&lt;pair&lt;uint64_t, size_t&gt;&gt;, greater&lt;pair&lt;uint64_t, size_t&gt;&gt;&gt; que; que.emplace(h.front(), size_t(0)); uint64_t cur = 0, res = 0; while (!que.empty()) &#123; uint64_t rem = que.top().first - cur / m * p.back(); auto ite = lower_bound(p.begin(), p.end(), rem); uint64_t cnt = ite - p.begin() - cur % m; if (ite == p.end()) &#123; rem -= p.back(); cnt += rem / p.back() * m; if (rem %= p.back()) cnt += lower_bound(p.begin(), p.end(), rem) - p.begin(); else --cnt; &#125; res += cnt; cur += cnt; ++cur; uint64_t tot = cur / m * p.back() + p[cur % m] - d[cur % m]; while (!que.empty() &amp;&amp; que.top().first &lt;= tot) &#123; for (const auto&amp; nn : next[que.top().second]) que.emplace(h[nn] + tot, nn); que.pop(); &#125; &#125; cout &lt;&lt; ++res &lt;&lt; endl;&#125; F. 仙人掌题目大意问大小为$~n~$且满足$~\\text{DFS}~$序为$~1,2,\\dots,n~$的有标号仙人掌个数。仙人掌为任何一条边至多属于一个简单环的连通图。数据范围$~1\\leq T\\leq5000,~1\\leq n\\leq5000~$。 题解动态规划。用$~{\\scr F}_i~$表示大小为$~i~$且满足$~\\text{DFS}~$序单调的有标号仙人掌构成的集合。记$~dp_i^{(0)}={\\mid {\\scr F}_i\\mid}~$，则$~dp^{(0)}~$为答案序列。对于仙人掌$~F~$，用$~S(F)\\subseteq F~$表示$~F~$中包含根节点的不连通子树。记$~dp_i^{(1)}=\\sum_{F\\in{\\scr F}_i}{\\mid S(F)\\mid}~$。显然$~dp_1^{(0)}=dp_1^{(0)}=1~$。对于$~i&gt;1~$，枚举根$~1~$的标号最大的儿子，设为$~j+1~$。则整个仙人掌等价于标号为$~1,2,\\dots,j~$的仙人掌$~A~$的根节点$~1~$上挂一棵标号为$~j+1,j+2,\\dots,i~$的仙人掌$~B~$，或者再加一条覆盖边$~(1,j+1)~$的非$~\\text{DFS}~$树边$~l~$。注意到$~l~$的一端为$~1~$，另一端根据仙人掌的性质，必然在$~S(B)~$之中。所以有状态转移式 \\begin{aligned} dp_i^{(0)}&=\\sum_{j=1}^{i-1}dp_j^{(0)}\\times(dp_{i-j}^{(0)}+dp_{i-j}^{(1)})\\\\ dp_i^{(1)}&=\\sum_{j=1}^{i-1}dp_j^{(0)}\\times dp_{i-j}^{(1)}+dp_j^{(1)}\\times(dp_{i-j}^{(0)}+dp_{i-j}^{(1)})\\\\ \\end{aligned}代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const uint64_t mod = 1000000007; auto add = [&amp;mod] (const uint64_t&amp; a, const uint64_t&amp; b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;; auto mul = [&amp;mod] (const uint64_t&amp; a, const uint64_t&amp; b) &#123; return a * b % mod; &#125;; const size_t maxn = 5000; vector&lt;uint64_t&gt; dp0(maxn + 1), dp1(maxn + 1); dp0[1] = dp1[1] = 1; for (size_t i = 2; i &lt;= maxn; ++i) for (size_t j = 1; j != i; ++j) &#123; dp0[i] = add(dp0[i], mul(dp0[j], add(dp0[i - j], dp1[i - j]))); dp1[i] = add(dp1[i], add(mul(dp0[j], dp1[i - j]), mul(dp1[j], add(dp0[i - j], dp1[i - j])))); &#125; size_t T, n; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; cout &lt;&lt; dp0[n] &lt;&lt; endl; &#125;&#125; G. 慢慢变小的序列题目大意需要对序列$~A_1,A_2,\\dots,A_n~$支持两种操作。修改操作为将区间$~[L,R]~$与首项为$~X~$，公差为$~Y~$的等差数列取最小值。查询操作为查询$~A_x~$的值。数据范围$~1\\leq n,q\\leq100000,~{\\mid A\\mid}\\leq100000,~{\\mid X\\mid}\\leq100000,~{\\mid Y\\mid}\\leq5~$。 题解注意到$~Y~$的数据范围，用$~11~$棵线段树维护每种公差的修改即可。总时间复杂度为$~O(11q\\log n)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;inline void minn(int&amp; x, const int&amp; y) &#123; x = min(x, y); &#125;int seg[11][1 &lt;&lt; 18];#define lson (index &lt;&lt; 1)#define rson (lson ^ 1)#define mid ((begin + end) &gt;&gt; 1)#define LEFT begin, mid, lson#define RIGHT mid, end, rson#define SEG left, rightvoid build5(int begin, int end, int index) &#123; if (begin + 1 == end) &#123; cin &gt;&gt; seg[5][index]; return; &#125; build5(LEFT); build5(RIGHT);&#125;void modify(int id, int begin, int end, int index, int left, int right, int x) &#123; if (left &gt;= end || right &lt;= begin) return; if (left &lt;= begin &amp;&amp; right &gt;= end) &#123; minn(seg[id][index], x + (begin - left) * (id - 5)); return; &#125; modify(id, LEFT, SEG, x); modify(id, RIGHT, SEG, x);&#125;int query(int id, int begin, int end, int index, int pos) &#123; if (pos &gt; end || pos &lt;= begin) return inf; if (begin + 1 == end) return seg[id][index]; return min(min(query(id, LEFT, pos), query(id, RIGHT, pos)), seg[id][index] + (pos - begin - 1) * (id - 5));&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #define endl '\\n' memset(seg, 0x3f, sizeof (seg)); int n, q; cin &gt;&gt; n &gt;&gt; q; build5(0, n, 1); while (q--) &#123; int opt; cin &gt;&gt; opt; if (opt == 1) &#123; int l, r, x, y; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x &gt;&gt; y; modify(y + 5, 0, n, 1, l - 1, r, x); &#125; else &#123; int x; cin &gt;&gt; x; int res = inf; for (int i = 0; i &lt;= 10; ++i) minn(res, query(i, 0, n, 1, x)); cout &lt;&lt; res &lt;&lt; endl; &#125; &#125;&#125; H. 你不知道的故事题目大意有$~2^k-1~$个灯和开关，初始亮灭状态给出。可以把它们视作一棵完全二叉树的$~\\text{BFS}~$序。对于每个开关$~i~$，它一定能控制对应位置的灯$~i~$，有可能控制灯$~2i,2i+1,\\lfloor\\frac{i}{2}\\rfloor~$，即完全二叉树上与它相邻的点。且保证每个灯不会被它的两个儿子开关同时控制。对于任意一种全局开关控制情况，均对应着一种开关方式使得亮的灯数最多。现问这个最多灯数的最小值（在所有全局开关控制情况下）。 题解动态规划。显然直接暴力枚举所有的全局开关控制情况然后做树形$~\\text{DP}~$是不可能的。用三个$~01~$状态分别记录当前点的亮灭情况，父亲的亮灭情况，自己的开关能否控制父亲。数值表示的是当前点的子树能对答案的最大贡献。转移过程暴力枚举自己的开关能否控制左右儿子，左右儿子的开关能否控制自己，共$~12~$种情况取$~\\min~$，然后根据自己是否按开关取$~\\max~$。 代码12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int a[1 &lt;&lt; 15], dp[1 &lt;&lt; 15][2][2][2];int main() &#123; #define loop(o) for (int o = 0; o != 2; ++o) int k; cin &gt;&gt; k; for (int i = 1; i != (1 &lt;&lt; k); ++i) cin &gt;&gt; a[i]; memset(dp, 0x3f, sizeof (dp)); for (int i = 1 &lt;&lt; k &gt;&gt; 1; i != (1 &lt;&lt; k); ++i) loop(s) loop(f) loop(x) dp[i][s][f][x] = max((s ^ 1) + x - ((x &amp; f) &lt;&lt; 1), s); for (int i = (1 &lt;&lt; k &gt;&gt; 1) - 1; i; --i) loop(s) loop(f) loop(x) loop(l) loop(r) loop(lf) loop(rf) if (!(lf &amp; rf)) dp[i][s][f][x] = min(dp[i][s][f][x], max( dp[i &lt;&lt; 1][l ^ a[i &lt;&lt; 1]][s ^ 1][lf] + dp[i &lt;&lt; 1 ^ 1][r ^ a[i &lt;&lt; 1 ^ 1]][s ^ 1][rf] + (s ^ 1) + x - ((x &amp; f) &lt;&lt; 1), dp[i &lt;&lt; 1][ a[i &lt;&lt; 1]][s ][lf] + dp[i &lt;&lt; 1 ^ 1][ a[i &lt;&lt; 1 ^ 1]][s ][rf] + s )); cout &lt;&lt; dp[1][a[1]][0][0] &lt;&lt; endl;&#125;","categories":[{"name":"比赛笔记","slug":"比赛笔记","permalink":"http://yoursite.com/categories/比赛笔记/"}],"tags":[]},{"title":"2019BITCPC","slug":"2019BITCPC","date":"2019-04-26T15:37:04.393Z","updated":"2019-04-26T15:37:12.773Z","comments":true,"path":"2019/04/26/2019BITCPC/","link":"","permalink":"http://yoursite.com/2019/04/26/2019BITCPC/","excerpt":"","text":"2019BITCPC A. 两只脑斧题目大意水题。 题解水题。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; map&lt;string, char&gt; res; res[\"0\"] = 'X'; res[\"5--\"] = 'E'; res[\"2-\"] = 'I'; res[\"1-\"] = 'E'; res[\"4-\"] = 'I'; res[\"3-\"] = 'E'; res[\"6-\"] = 'I'; res[\"5-\"] = 'E'; res[\"7-\"] = 'I'; res[\"1\"] = 'E'; res[\"2\"] = 'I'; res[\"3\"] = 'E'; res[\"4\"] = 'I'; res[\"5\"] = 'E'; res[\"6\"] = 'I'; res[\"1+\"] = 'E'; res[\"7\"] = 'I'; res[\"3+\"] = 'E'; res[\"2+\"] = 'I'; res[\"5+\"] = 'E'; res[\"4+\"] = 'I'; res[\"1++\"] = 'E'; res[\"6+\"] = 'I'; res[\"3++\"] = 'E'; res[\"7+\"] = 'I'; size_t n; cin &gt;&gt; n; while (n--) &#123; string str; cin &gt;&gt; str; cout &lt;&lt; res[str]; &#125; cout &lt;&lt; endl;&#125; B. 炼金术题目大意给$~m~$个小写字母串，要求输出一个长度为$~n~$的小写字母串，使得所有给定串都不是它的子串。保证一定有解。数据范围$~1\\leq n\\leq10^5,~1\\leq m\\leq10^4,~{\\sum_{i=1}^{m}\\mid s_i\\mid}\\leq3\\times10^5~$。 题解建立$~\\text{AC}~$自动机，那么可以将其看成一个有向图，显然每个单词末尾字符所对应的节点是不可经过的。在建立自动机的$~\\text{BFS}~$过程中，将当前节点是否可经过属性逻辑或上其$~fail~$节点的属性。那么扣去不可经过的节点，题目转化为在该有向图任意寻找一条长度为$~n~$的链。通过$~\\text{DFS}~$寻找环，如果无环，则在$~\\text{DAG}~$上$~\\text{DP}~$，总时间复杂度为$~O(n+\\sum s)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;struct ACAM &#123; static const size_t maxs = 1 &lt;&lt; 20; static const size_t ch_size = 26; struct &#123; size_t next[ch_size], fail, to, dis; bool end, vis; &#125; trie[maxs]; size_t size, n; char res[maxs]; void init() &#123; memset(trie, 0, sizeof (trie)); size = 1, res[n] = '\\0'; &#125; void insert(const char str[], size_t len) &#123; size_t cur = 0; for (size_t i = 0; i != len; ++i) &#123; size_t ch = str[i] - 'a'; if (!trie[cur].next[ch]) trie[cur].next[ch] = size++; cur = trie[cur].next[ch]; &#125; trie[cur].end = true; &#125; void build_fail() &#123; queue&lt;size_t&gt; que; for (size_t i = 0; i != ch_size; ++i) if (trie-&gt;next[i]) que.emplace(trie-&gt;next[i]); while (!que.empty()) &#123; size_t cur = que.front(); que.pop(); for (size_t i = 0; i != ch_size; ++i) &#123; if (trie[cur].next[i]) &#123; trie[trie[cur].next[i]].fail = trie[trie[cur].fail].next[i]; que.emplace(trie[cur].next[i]); &#125; else &#123; trie[cur].next[i] = trie[trie[cur].fail].next[i]; &#125; &#125; trie[cur].end |= trie[trie[cur].fail].end; trie[cur].to = -1; &#125; trie[0].to = -1; &#125; bool dfs1(size_t cur = 0, size_t index = 0) &#123; if (index == n) return true; if (~trie[cur].to) &#123; res[index++] = 'a' + trie[cur].to; return dfs1(trie[cur].next[trie[cur].to], index); &#125; if (trie[cur].vis) return false; trie[cur].vis = true; for (size_t i = 0; i != ch_size; ++i) if (!trie[trie[cur].next[i]].end) &#123; res[index] = 'a' + i; if (dfs1(trie[cur].next[trie[cur].to = i], index + 1)) return true; else trie[cur].to = -1; &#125; return false; &#125; size_t dfs2(size_t cur = 0) &#123; if (trie[cur].dis) return trie[cur].dis; for (size_t i = 0; i != ch_size; ++i) if (!trie[trie[cur].next[i]].end) trie[cur].dis = max(trie[cur].dis, dfs2(trie[cur].next[i])); return ++trie[cur].dis; &#125; void route() &#123; for (size_t i = 0, cur = 0; i != n; ++i) &#123; for (size_t j = 0; j != ch_size; ++j) if (i + trie[trie[cur].next[j]].dis &gt;= n) &#123; res[i] = 'a' + j; break; &#125; &#125; &#125;&#125; acam;int main() &#123; ios::sync_with_stdio(false); size_t m; cin &gt;&gt; acam.n &gt;&gt; m; acam.init(); while (m--) &#123; string str; cin &gt;&gt; str; acam.insert(str.data(), str.size()); &#125; acam.build_fail(); if (!acam.dfs1()) &#123; assert(acam.dfs2() &gt; acam.n); acam.route(); &#125; cout &lt;&lt; acam.res &lt;&lt; endl;&#125; C. 赛尔逵传说题目大意打怪兽。怪兽血量为$~d~$，攻击力为$~x~$，自己攻击力为$~k~$。同时可以嗑最多$~c~$次$~\\text{buff}~$，使得下一次攻击力增加$~k~$，随后失效。怪物轮流上，自己先攻击，问最少损失的血量。数据范围$~1\\leq n\\leq10^5,~1\\leq k,c\\leq10^6,~1\\leq d,x\\leq10^6~$。 题解在不考虑$~\\text{buff}~$的条件下，对付每个怪兽需要受到的攻击次数为$~\\lfloor\\frac{d-1}{k}\\rfloor~$，而每层$~\\text{buff}~$可以使得该次数减$~1~$。于是对于怪兽的攻击力$~x~$排序后模拟即可，总时间复杂度为$~O(n\\log n + c)~$。 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; size_t n, k, c; cin &gt;&gt; n &gt;&gt; k &gt;&gt; c; vector&lt;pair&lt;size_t, size_t&gt;&gt; monster(n); for (auto&amp; m : monster) &#123; size_t d, x; cin &gt;&gt; d &gt;&gt; x; m = pair&lt;size_t, size_t&gt;(x, (d - 1) / k); &#125; sort(monster.begin(), monster.end()); reverse(monster.begin(), monster.end()); uint64_t res = 0; for (auto m : monster) &#123; size_t cur = min(c, m.second); c -= cur; res += m.first * uint64_t(m.second - cur); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. 碟中谍题目大意有一个通道，上下侧为$~y=w~$和$~y=0~$，左右侧为$~x=+\\infty~$和$~x=-\\infty~$。同时平面上有$~n~$个圆形障碍物，坐标为$~(x,y)~$，半径为$~r~$。自己也是圆形，问最大的半径使得可以从左边移动至右边。数据范围$~1\\leq T\\leq100,~1\\leq 2\\leq10^5,~0\\leq n\\leq10^3,~-10^5\\leq x\\leq10^5,~0\\leq y\\leq w,~1\\leq r\\leq10^5~$。 题解假设当前自己的半径为$~R~$。则可以把上下侧改为$~y=w-R~$和$~y=R~$，每个圆的半径都增加$~R~$。那么此时能否通过等价于是否存在一条无半径路径穿越这个通道，等价于这些圆是否将上下侧连通。那么本题可以转化为最短路问题，路径的长度定义为路径上边的长度的最大值，边的长度定义为两个圆的距离。用$~\\text{Dijstra}~$算法，总时间复杂度为$~O(Tn^2)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const size_t maxn = 1 &lt;&lt; 10;const double inf = 1e18;struct Circle &#123; double x, y, r; &#125; circle[maxn];inline double dis(const Circle&amp; c1, const Circle&amp; c2) &#123; return max(0.0, hypot(c1.x - c2.x, c1.y - c2.y) - c1.r - c2.r); &#125;double cost[maxn][maxn], res[maxn];bool vis[maxn];int main() &#123; size_t t; scanf(\"%u\", &amp;t); while (t--) &#123; double w; size_t n; scanf(\"%lf%u\", &amp;w, &amp;n); for (size_t i = 0; i != n; ++i) scanf(\"%lf%lf%lf\", &amp;circle[i].x, &amp;circle[i].y, &amp;circle[i].r); for (size_t i = 0; i != n; ++i) for (size_t j = 0; j != n; ++j) cost[i][j] = dis(circle[i], circle[j]); cost[n + 1][n + 1] = cost[n][n] = 0; cost[n + 1][n] = cost[n][n + 1] = w; for (size_t i = 0; i != n; ++i) &#123; cost[n + 1][i] = cost[i][n + 1] = max(0.0, circle[i].y - circle[i].r); cost[n][i] = cost[i][n] = max(0.0, w - circle[i].y - circle[i].r); &#125; n += 2; for (size_t i = 0; i != n; ++i) res[i] = inf; memset(vis, 0, n); res[n - 1] = 0; size_t next = n - 1; while (next != n - 2U) &#123; vis[next] = true; double cur = inf; size_t last = next; for (size_t i = 0; i != n; ++i) if (!vis[i]) if ((res[i] = min(res[i], max(res[last], cost[last][i]))) &lt; cur) next = i, cur = res[i]; &#125; printf(\"%.6f\\n\", res[n - 2] / 2); &#125;&#125; E. 只有一端开口的瓶子题目大意现在有一个$~1,2,\\dots,n~$的全排列构成的序列和$~k~$个空的栈。可以有如下三种操作：把当前序列的头部放入第$~p~$个栈的顶部；把第$~p~$个栈的顶部放入新序列的尾部；把第$~p~$个栈的顶部放入第$~q~$个栈的顶部。最终要使得新序列升序，即为$~1,2,\\dots,n~$。先给定$~T~$组全排列，问这些全排列分别至少需要准备多少个栈才能完成升序操作。数据范围$~1\\leq T\\leq100,~1\\leq n\\leq10^5~$。 题解不难发现答案不会大于$~2~$，那么只需要判断答案是否为$~1~$即可。线性栈模拟，总时间复杂度为$~O(Tn)~$。 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; size_t t; cin &gt;&gt; t; while (t--) &#123; size_t n; cin &gt;&gt; n; size_t next = 1; stack&lt;size_t&gt; sta; while (n--) &#123; size_t p; cin &gt;&gt; p; sta.emplace(p); while (!sta.empty() &amp;&amp; sta.top() == next) &#123; sta.pop(); ++next; &#125; &#125; cout &lt;&lt; (sta.empty() ? 1 : 2) &lt;&lt; endl; &#125;&#125; F. 风王之瞳题目大意计算长宽为$~n,m~$的正方形网格图有多少个格点正方形。 题解不妨设$~n\\leq m~$。先考虑对于边长为$~k\\leq n~$的正方形，顶点都落在该正方形上的格点正方形有$~k~$个。而这样的正方形有$~(n-k+1)(m-k+1)~$个。于是答案为 \\sum_{k=1}^{n}k(n-k+1)(m-k+1)=\\frac{n(n+1)(n+2)(2m-n+1)}{12}代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; size_t t; cin &gt;&gt; t; while (t--) &#123; uint64_t n, m; cin &gt;&gt; n &gt;&gt; m; if (n &gt; m) swap(n, m); cout &lt;&lt; n * (n + 1) * (n + 2) / 6 * (2 * m - n + 1) / 2 &lt;&lt; endl; &#125;&#125; G. 神圣的 F2 连接着我们题目大意有一个二分图，两边的编号都是$~1,2,\\dots,n~$，左边有$~p~$个关键点$~x_1,x_2,\\dots,x_p~$，右边有$~q~$个关键点$~y_1,y_2,\\dots,y_q~$。还有$~m~$组双向边，权值为$~w~$，将左边编号在$~[a,b]~$的点于右边编号在$~[c,d]~$的点相连，注意同一侧的点之间是没有边的。需要所有左边的关键点$~x~$到右边最近的$~y~$的距离，或者无法连通。数据范围$~1\\leq n,m,p,q\\leq10^5,~1\\leq a\\leq b\\leq n,~1\\leq c\\leq d\\leq n,~1\\leq w\\leq10^9~$。 题解显然是多源最短路问题，关键在于如何建图，如果暴力建图那么边数是$~O(nm)~$的。对于每侧的点都建立两棵线段树：在线段树一上，所有的父子对都连一条父亲指向儿子的权值为$~0~$的边；在线段树二上，所有的父子对都连一条儿子指向父亲的权值为$~0~$的边；在两颗线段树对应的点对上，连一条线段树一上节点指向线段树二上节点的权值为$~0~$的边。对于题目给出的边，将区间$~[a,b]~$和$~[c,d]~$在两边的线段树上分解，再给图增加两个中间点代表从左到右和从右到左的边。连接的边有：在左二树分解到的节点指向一号中间点的权值为$~w~$的边；一号中间点指向在右一树分解到的节点的权值为$~0~$的边；在右二树上分解到的节点指向二号中间点的权值为$~w~$的边；二号中间点指向在左一树分解到的节点的权值为$~0~$的边。然后跑堆优化的$~\\text{Dijstra}~$多源最短路，只要在最开始将所有的$~y~$入堆，剩下的步骤和单源最短路一致。总时间复杂度为$~O(m\\log^2n)~$，空间复杂度为$~O(n+m\\log n)~$。注意本题会卡时间常数和空间常数。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (index &lt;&lt; 1)#define rson (lson ^ 1)#define mid ((begin + end) &gt;&gt; 1)#define LEFT begin, mid, lson, side#define RIGHT mid, end, rson, side#define SEG left, right#define size_t uint32_tconst size_t maxn = 100005;const size_t zero = 0;size_t pos[2][maxn], graph_size, seg[2][maxn &lt;&lt; 2];struct &#123; uint64_t dis; size_t side, index; &#125; node[maxn * 10];vector&lt;pair&lt;size_t, size_t&gt;&gt; dir[maxn * 10];void build(size_t begin, size_t end, size_t index, size_t side) &#123; node[graph_size &lt;&lt; 1].side = node[graph_size &lt;&lt; 1 ^ 1].side = side; node[graph_size &lt;&lt; 1].index = node[graph_size &lt;&lt; 1 ^ 1].index = index; node[graph_size &lt;&lt; 1].dis = node[graph_size &lt;&lt; 1 ^ 1].dis = -1; dir[graph_size &lt;&lt; 1].emplace_back(graph_size &lt;&lt; 1 ^ 1, zero); seg[side][index] = graph_size++; if (begin + 1U == end) &#123; pos[side][end] = index; return; &#125; build(LEFT); build(RIGHT); dir[seg[side][index] &lt;&lt; 1].emplace_back(seg[side][lson] &lt;&lt; 1, zero); dir[seg[side][index] &lt;&lt; 1].emplace_back(seg[side][rson] &lt;&lt; 1, zero); dir[seg[side][lson] &lt;&lt; 1 ^ 1].emplace_back(seg[side][index] &lt;&lt; 1 ^ 1, zero); dir[seg[side][rson] &lt;&lt; 1 ^ 1].emplace_back(seg[side][index] &lt;&lt; 1 ^ 1, zero);&#125;void link(size_t left, size_t right, size_t begin, size_t end, size_t index, size_t side, size_t w) &#123; if (left &gt;= end || right &lt;= begin) return; if (left &lt;= begin &amp;&amp; right &gt;= end) &#123; dir[seg[side][index] &lt;&lt; 1 ^ 1].emplace_back(graph_size &lt;&lt; 1 ^ side, w); dir[graph_size &lt;&lt; 1 ^ 1 ^ side].emplace_back(seg[side][index] &lt;&lt; 1, zero); return; &#125; link(SEG, LEFT, w); link(SEG, RIGHT, w);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); size_t n, m, p, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; q; build(0, n, 1, 0); build(0, n, 1, 1); while (m--) &#123; size_t a, b, c, d, w; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; w; node[graph_size &lt;&lt; 1].side = node[graph_size &lt;&lt; 1 ^ 1].side = -1; node[graph_size &lt;&lt; 1].index = node[graph_size &lt;&lt; 1 ^ 1].index = -1; node[graph_size &lt;&lt; 1].dis = node[graph_size &lt;&lt; 1 ^ 1].dis = -1; link(--a, b, 0, n, 1, 0, w); link(--c, d, 0, n, 1, 1, w); ++graph_size; &#125; vector&lt;size_t&gt; x(p); for (auto&amp; xx : x) cin &gt;&gt; xx; priority_queue&lt;pair&lt;uint64_t, size_t&gt;, vector&lt;pair&lt;uint64_t, size_t&gt;&gt;, greater&lt;pair&lt;uint64_t, size_t&gt;&gt;&gt; que; while (q--) &#123; size_t y; cin &gt;&gt; y; que.emplace(uint64_t(zero), seg[1][pos[1][y]] &lt;&lt; 1); &#125; while (!que.empty()) &#123; uint64_t dis = que.top().first; size_t cur = que.top().second; que.pop(); if (~node[cur].dis) continue; node[cur].dis = dis; for (auto next : dir[cur]) if (!~node[next.first].dis) que.emplace(dis + next.second, next.first); dir[cur].clear(); &#125; uint64_t res = zero; for (auto xx : x) res = max(res, node[seg[0][pos[0][xx]] &lt;&lt; 1].dis); if (~res) cout &lt;&lt; res &lt;&lt; endl; else cout &lt;&lt; \"boring game\" &lt;&lt; endl;&#125; H. 目标是成为数论大师题目大意问$~f(x)=\\sqrt{ax}+b~$的点，保证存在且为整数。输出格式为升序不重。数据范围$~1\\leq T\\leq100,~-10^3\\leq a,b\\leq10^3~$。 题解解二次方程，注意细节。 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; size_t t; cin &gt;&gt; t; while (t--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; res; auto add = [&amp;] (int x) &#123; if ((int)round(sqrt(a * x)) + b == x) res.emplace_back(x); &#125;; int delta = round(sqrt(a * a + 4 * a * b)); add((a + 2 * b - delta) / 2); add((a + 2 * b + delta) / 2); sort(res.begin(), res.end()); res.resize(unique(res.begin(), res.end()) - res.begin()); cout &lt;&lt; res.size() &lt;&lt; endl &lt;&lt; res.front(); for (size_t i = 1; i != res.size(); ++i) cout &lt;&lt; ' ' &lt;&lt; res[i]; cout &lt;&lt; endl; &#125;&#125; I. 出给 paul-lu 的数数题题目大意一个$~n\\times n~$的表上每个位置的值只能取$~[1,k]~$。定义一个位置为$~\\text{bi}~$点当且仅当它严格大于它所处的行与列的所有其它的值。记$~B_i\\in[0,n^2]~$为恰好有$~i~$个$~\\text{bi}~$点的方案数。计算$~\\sum_{i=0}^{n^2}{i^2\\cdot B_i}~$。数据范围$~1\\leq T\\leq20,~1\\leq n,k\\leq200~$。 题解对任意方案$~A~$，用$~f(A)~$表示该方案下的$~\\text{bi}~$点的数量，则有 \\sum_{i=0}^{n^2}{i^2\\cdot B_i}=\\sum_Af^2(A)用$~S(A)~$表示该方案下的所有$~\\text{bi}~$点的集合，则 f(A)=\\sum_{p\\in S(A)}1于是 \\sum_{i=0}^{n^2}{i^2\\cdot B_i}=\\sum_A\\sum_{p_1\\in S(A)}\\sum_{p_2\\in S(A)}1对于两点$~p_1,p_2~$（可重），用$~g(p_1,p_2)~$表示它们均为$~\\text{bi}~$的方案数，则可以交换求和顺序，得到 \\sum_{i=0}^{n^2}{i^2\\cdot B_i}=\\sum_{p_1}\\sum_{p_2}g(p_1,p_2)当$~p_1,p_2~$不重合但同行或者同列时，显然有$~g=0~$。不难发现$~g~$其实只有$~2~$种非平凡取值，即$~p_1,p_2~$重合时和$~p_1,p_2~$不重合时。那么令$~g_0=g((1,1),(1,1)),~g_1=g((1,1),(2,2))~$，则有 g_0=k^{(n-1)^2}\\sum_{i=0}^{k-1}i^{2(n-1)} \\\\ g_1=k^{(n-2)^2}\\sum_{i=0}^{k-1}\\sum_{j=0}^{k-1}\\min(i,j)^{2(n-1)}\\max(i,j)^{2(n-2)} \\\\ \\sum_{i=0}^{n^2}{i^2\\cdot B_i}=n^2g_0+n^2(n-1)^2g_1 \\\\剩下的计算步骤是十分简单的。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const uint64_t mod = 1000000007; auto sub = [&amp;] (const uint64_t&amp; a, const uint64_t&amp; b) &#123; return a &lt; b ? a - b + mod : a - b; &#125;; auto add = [&amp;] (const uint64_t&amp; a, const uint64_t&amp; b) &#123; return sub(a, mod - b); &#125;; auto mul = [&amp;] (const uint64_t&amp; a, const uint64_t&amp; b) &#123; return a * b % mod; &#125;; auto fpow = [&amp;] (uint64_t a, uint64_t n) &#123; uint64_t ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret; &#125;; size_t t; cin &gt;&gt; t; while (t--) &#123; uint64_t n, k; cin &gt;&gt; n &gt;&gt; k; uint64_t cal1 = 0, cal2 = 0; for (uint64_t i = 0; i != k; ++i) cal1 = add(cal1, fpow(i, (n - 1) &lt;&lt; 1)); cal1 = mul(cal1, fpow(k, (n - 1) * (n - 1))); for (uint64_t i = 0; i != k; ++i) for (uint64_t j = 0; j != k; ++j) cal2 = add(cal2, mul(fpow(min(i, j), (n - 1) &lt;&lt; 1), fpow(max(i, j), (n - 2) &lt;&lt; 1))); cal2 = mul(mul(cal2, (n - 1) * (n - 1)), fpow(k, (n - 2) * (n - 2))); cout &lt;&lt; mul(add(cal1, cal2), n * n) &lt;&lt; endl; &#125;&#125; J. 金色传说题目大意定义一个长度为$~n~$的字符串表达式合法，当且仅当它仅由$~0,1,\\dots,9~$，以及$~+~$或$~-~$组成，且首尾不能是运算符，运算符不相邻（注意允许数字有前导零）。问所有长度为$~n~$的合法字符串表达式的值之和。数据范围$~1\\leq T\\leq100,~1\\leq n\\leq5\\times10^5~$。 题解设答案序列为$~{f_n}~$，前几项$~f_0=0,~f_1=45,~f_2=4950,\\dots~$，其生成多项式为 F(x)=\\sum_{n=0}^{\\infty}f_nx^n准备工作先考虑序列$~{g_n:g_n=10^n}~$，易得其生成多项式为 G(x)=~\\sum_{n=0}^{\\infty}10^nx^n=\\frac{1}{1-10x}考虑仅有数字组成的字符串，对应的答案序列为$~{h_n:h_n=\\frac{10^n(10^n-1)}{2}}~$，其生成多项式可以推出为 H(x)=\\sum_{n=0}^{\\infty}h_nx^n=\\frac{1}{2}\\left(\\frac{1}{1-100x}-\\frac{1}{1-10x}\\right)计算$~f_n~$。若没有运算符，则对$~f_n~$为$~h_n~$。若有运算符，考虑最后一个数字的长度$~k~$，满足$~1\\leq k\\leq n-2~$。此时最后一个数字有$~g_k~$种取法，运算符有$~2~$种取法。注意到此时由于正负号相消，最后一个数字对于$~f_n~$的贡献为$~0~$，于是剩下的贡献为$~2g_kf_{n-1-k}~$。即 \\begin{aligned} f_n &=h_n+2\\sum_{k=1}^{n-2}g_kf_{n-1-k} \\\\ &=h_n-2f_{n-1-k}+2\\sum_{k=0}^{n-1}g_kf_{n-1-k} \\\\ \\end{aligned}这是一个卷积式，它对于$n\\geq1~$均满足。于是对于$~n=1,2,\\dots~$，等式两边乘以$~x^{n-1}~$后累加，可以得出生成多项式的等式 \\frac{F(x)-F(0)}{x}=\\frac{H(x)-H(0)}{x}-2F(x)+2G(x)F(x)可以算出 F(x)=\\frac{1}{1-110x+980x^2+2000x^3}于是对于$~n\\geq3~$，有线性递推式 f_n=110f_{n-1}-980f_{n-2}-2000f_{n-3}预处理或者矩阵快速幂均可通过此题，时间复杂度分别为$~O(n+T)~$和$~O(T\\log n)~$。 代码（$~O(T\\log n)~$）12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const size_t mod = 998244353; auto add = [&amp;] (const size_t&amp; a, const size_t&amp; b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;; auto mul = [&amp;] (const size_t&amp; a, const size_t&amp; b) &#123; return 1LL * a * b % mod; &#125;; auto mat_mul = [&amp;] (size_t A[3][3], size_t B[3][3], size_t C[3][3]) &#123; for (size_t i = 0; i != 3; ++i) for (size_t j = 0; j != 3; ++j) for (size_t k = 0; k != 3; ++k) C[i][j] = add(C[i][j], mul(A[i][k], B[k][j])); &#125;; size_t t; cin &gt;&gt; t; while (t--) &#123; size_t n, res[3][3] = &#123; &#123; 1, 0, 0 &#125;, &#123; 0, 1, 0 &#125;, &#123; 0, 0, 1 &#125; &#125;, bas[3][3] = &#123; &#123; 110, mod - 980, mod - 2000 &#125;, &#123; 1, 0, 0, &#125;, &#123; 0, 1, 0 &#125; &#125;, tmp[3][3]; for (cin &gt;&gt; n; n; n &gt;&gt;= 1) &#123; if (n &amp; 1) &#123; memset(tmp, 0, sizeof (tmp)); mat_mul(res, bas, tmp); memcpy(res, tmp, sizeof (tmp)); &#125; memset(tmp, 0, sizeof (tmp)); mat_mul(bas, bas, tmp); memcpy(bas, tmp, sizeof (tmp)); &#125; cout &lt;&lt; mul(add(mul(res[2][0], 110), res[2][1]), 45) &lt;&lt; endl; &#125;&#125; K. 多项式求导题目大意多项式求导。 题解水题。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const int mod = 998244353; auto mul = [&amp;mod] (const int&amp; a, const int&amp; b) &#123; return 1LL * a * b % mod; &#125;; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n + 1); for (int i = n; ~i; --i) cin &gt;&gt; a[i]; while (k--) &#123; vector&lt;int&gt; a_(n + 1, 0); for (int i = n; i; --i) a_[i - 1] = mul(a[i], i); a = a_; &#125; for (int i = n; i; --i) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; a.front() &lt;&lt; endl;&#125; L. 旅行的意义题目大意地图是个$~\\text{DAG}~$，起点为$~1~$。每到一个新的点会停留$~1~$天，然后等概率的选择再留$~1~$天或者去下一个可以到的点，路程花费$~1~$天。至多停留$~2~$天，然后必须等概率的选择下一个可以到的点，如果不能继续则停止。问总天数的期望。数据范围$~1\\leq T\\leq10,~1\\leq n\\leq10^5,~0\\leq m\\leq10^5~$ 题解裸的$~\\text{DAG}~$上概率$~\\text{DP}~$，代码使用的拓扑排序代替记忆化$~\\text{DFS}~$。注意快读！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); const int mod = 998244353; auto add = [&amp;mod] (const int&amp; a, const int&amp; b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;; auto mul = [&amp;mod] (const int&amp; a, const int&amp; b) &#123; return 1LL * a * b % mod; &#125;; vector&lt;int&gt; inv(100002, 1); for (int i = 2; i &lt;= 100001; ++i) inv[i] = mul(inv[mod % i], mod - mod / i); size_t t; cin &gt;&gt; t; while (t--) &#123; size_t n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;size_t&gt;&gt; to(n), from(n); vector&lt;size_t&gt; deg(n, 0), topo; vector&lt;int&gt; res(n, 0); while (m--) &#123; size_t u, v; cin &gt;&gt; u &gt;&gt; v; --u; --v; to[u].emplace_back(v); from[v].emplace_back(u); &#125; for (size_t u = 0; u != n; ++u) if (!(deg[u] = to[u].size())) &#123; res[u] = 2; topo.emplace_back(u); &#125; for (size_t i = 0; i != topo.size(); ++i) &#123; auto&amp; u = topo[i]; if (!to[u].empty()) &#123; for (auto v : to[u]) res[u] = add(res[u], res[v]); res[u] = mul(res[u], inv[to[u].size()]); res[u] = add(res[u], inv[to[u].size() + 1] + 2); &#125; for (auto v : from[u]) if (!--deg[v]) topo.emplace_back(v); &#125; cout &lt;&lt; res.front() &lt;&lt; endl; &#125;&#125;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"http://yoursite.com/categories/刷题笔记/"}],"tags":[]},{"title":"Codeforces Round 542 [Alex Lopashev Thanks-Round] (Div. 2)","slug":"Codeforces Round 542 [Alex Lopashev Thanks-Round] (Div. 2)","date":"2019-04-18T10:15:18.855Z","updated":"2019-04-18T10:27:32.608Z","comments":true,"path":"2019/04/18/Codeforces Round 542 [Alex Lopashev Thanks-Round] (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/04/18/Codeforces Round 542 [Alex Lopashev Thanks-Round] (Div. 2)/","excerpt":"","text":"Codeforces Round #542 [Alex Lopashev Thanks-Round] (Div. 2) A. Be Positive题目大意水题。 题解水题。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, a, neg = 0, pos = 0; cin &gt;&gt; n; for (int i = 0; i != n; ++i) &#123; cin &gt;&gt; a; if (a &lt; 0) ++neg; if (a &gt; 0) ++pos; &#125; if (neg * 2 &gt;= n) return cout &lt;&lt; -1 &lt;&lt; endl, 0; if (pos * 2 &gt;= n) return cout &lt;&lt; 1 &lt;&lt; endl, 0; cout &lt;&lt; 0 &lt;&lt; endl;&#125; B. Two Cakes题目大意给定一个长度为$~2n~$的序列，数字$~1,2,\\dots,n~$各出现$~2~$次。有$~2~$人初始再序列的最左边，他们分别要依次拿到$~1,2,\\dots,n~$，且每个数字只能被拿一次，所以结束时刚好拿完。问这$~2~$人移动距离之和的最小值。数据范围$~1\\leq n\\leq10^5~$。 题解水题。见代码。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; pos(n + 1); pos.front() = vector&lt;int&gt;(2, 0); for (int i = 0; i != n * 2; ++i) &#123; int a; cin &gt;&gt; a; pos[a].push_back(i); &#125; long long res = 0; for (int i = 0; i != n; ++i) res += min(abs(pos[i + 1][0] - pos[i][0]) + abs(pos[i + 1][1] - pos[i][1]), abs(pos[i + 1][0] - pos[i][1]) + abs(pos[i + 1][1] - pos[i][0])); cout &lt;&lt; res &lt;&lt; endl;&#125; C. Connect题目大意给一个地图由土和水组成，起点终点均在土上，只能在土上移动。可以至多建$~1~$个隧道连接$~2~$个土，欧式距离的平方。问从起点到终点的最小花费。数据范围$~1\\leq n\\leq50~$。 题解爆搜$~\\text{BFS}~$或者$~\\text{DFS}~$得到起点和终点的联通块，然后暴力枚举隧道的起点和终点即可。总时间复杂度为$~O(n^4)~$。注意到在爆搜过程中，可以不枚举终点纵坐标$~y_2~$，只需要使得$~(y-y_1 )^2~$最小，这一步可以预处理，所以总时间复杂度可以降为$~O(n^3)~$。 代码（$~O(n^4)~$）12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; char cell[52][52]; memset(cell, '1', sizeof (cell)); int dx[4] = &#123; 1, 0, -1, 0 &#125;, dy[4] = &#123; 0, 1, 0, -1 &#125;, dis[52][52]; memset(dis, 0x3f, sizeof (dis)); int n, r1, c1, r2, c2; cin &gt;&gt; n &gt;&gt; r1 &gt;&gt; c1 &gt;&gt; r2 &gt;&gt; c2; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) cin &gt;&gt; cell[i][j]; vector&lt;pair&lt;int, int&gt;&gt; que; auto push = [&amp;] (const int&amp; x, const int&amp; y) &#123; cell[x][y] = '1'; que.emplace_back(x, y); &#125;; push(r2, c2); for (size_t i = 0; i != que.size(); ++i) &#123; int X = que[i].first; int Y = que[i].second; for (int y = 1; y &lt;= n; ++y) dis[X][y] = min(dis[X][y], (Y - y) * (Y - y)); for (size_t j = 0; j != 4U; ++j) if (cell[X + dx[j]][Y + dy[j]] == '0') push(X + dx[j], Y + dy[j]); &#125; int res = INT_MAX; que.clear(); push(r1, c1); for (size_t i = 0; i != que.size(); ++i) &#123; int X = que[i].first; int Y = que[i].second; for (int x = 1; x &lt;= n; ++x) res = min(res, (X - x) * (X - x) + dis[x][Y]); for (size_t j = 0; j != 4U; ++j) if (cell[X + dx[j]][Y + dy[j]] == '0') push(X + dx[j], Y + dy[j]); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; 代码（$~O(n^3)~$）1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;char cell[52][52];int dx[4] = &#123; 1, 0, -1, 0 &#125;, dy[4] = &#123; 0, 1, 0, -1 &#125;, dis[52][52];int main() &#123; memset(cell, '1', sizeof (cell)); memset(dis, 0x3f, sizeof (dis)); int n, r1, c1, r2, c2; cin &gt;&gt; n &gt;&gt; r1 &gt;&gt; c1 &gt;&gt; r2 &gt;&gt; c2; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) cin &gt;&gt; cell[i][j]; vector&lt;pair&lt;int, int&gt;&gt; que; auto push = [&amp;] (const int&amp; x, const int&amp; y) &#123; cell[x][y] = '1'; que.emplace_back(x, y); &#125;; push(r2, c2); for (size_t i = 0; i != que.size(); ++i) &#123; int X = que[i].first; int Y = que[i].second; for (int y = 1; y &lt;= n; ++y) dis[X][y] = min(dis[X][y], (Y - y) * (Y - y)); for (size_t j = 0; j != 4U; ++j) if (cell[X + dx[j]][Y + dy[j]] == '0') push(X + dx[j], Y + dy[j]); &#125; int res = INT_MAX; que.clear(); push(r1, c1); for (size_t i = 0; i != que.size(); ++i) &#123; int X = que[i].first; int Y = que[i].second; for (int x = 1; x &lt;= n; ++x) res = min(res, (X - x) * (X - x) + dis[x][Y]); for (size_t j = 0; j != 4U; ++j) if (cell[X + dx[j]][Y + dy[j]] == '0') push(X + dx[j], Y + dy[j]); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D1. Toy Train (Simplified)题目大意有$~n~$个车站围成环，以及$~m~$颗糖果的初始位置和目标位置。火车每次到站至多只能装$~1~$颗糖果，但是可以卸下若干糖果。问分别以每个站为起点，要将所有糖果送到目标地点，火车的最少行驶距离。数据范围$~2\\leq n\\leq100,~1\\leq m\\leq200~$。 题解考虑第$~i~$站，一共有$~x~$颗糖果以它为起点，且最近的终点为$~y~$，这一步可以在$~O(m)~$内处理完。那么火车第$~1~$次到达该站时，至少还要行驶$~(x-1)\\cdot n+y~$。而每次到达一个新站，取该站目标地点最远的那颗糖果这样就能得到最小距离的方案。按题意枚举起点以及起点到所有站的距离，总时间复杂度为$~O(n^2+m)~$。 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; dis(n + 1, 0), cnt(n + 1, 0); while (m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; ++cnt[a]; dis[a] = min(dis[a], a &gt; b ? b - a : b - a - n); &#125; for (int i = 1; i &lt;= n; ++i) &#123; int res = 0; for (int j = 1; j &lt;= n; ++j) if (cnt[j]) res = max(res, (i &gt; j ? j - i + n : j - i) + cnt[j] * n + dis[j]); cout &lt;&lt; res &lt;&lt; ' '; &#125; cout &lt;&lt; endl;&#125; D2. Toy Train题目大意上一题的基础上增加数据范围$~2\\leq n\\leq5000,~1\\leq m\\leq20000~$。 题解上一题的$~O(n^2+m)~$做法依然能过。但是注意到在计算第$~1~$个位置的答案时，已经处理的大部分区间的最小值。那么只需要记录前缀$~\\min~$和后缀$~\\min~$，这样每个位置的答案可以在$~O(1)~$内求出，总时间复杂度为$~O(n+m)~$。 代码（$~O(n+m)~$）1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; dis(n + 1, 0), cnt(n + 1, 0); while (m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; ++cnt[a]; dis[a] = min(dis[a], a &gt; b ? b - a : b - a - n); &#125; vector&lt;int&gt; pre(n, -n), suf(n + 2, -n); for (int i = 1; i != n; ++i) &#123; pre[i] = pre[i - 1]; if (cnt[i]) pre[i] = max(pre[i], cnt[i] * n + dis[i] + i); &#125; for (int i = n; i; --i) &#123; suf[i] = suf[i + 1]; if (cnt[i]) suf[i] = max(suf[i], cnt[i] * n + dis[i] + i); &#125; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; max(pre[i - 1] + n - i, suf[i] - i) &lt;&lt; ' '; cout &lt;&lt; endl;&#125; E. Wrong Answer题目大意要计算一个序列的 \\max_{0\\leq l\\leq r< n}{(r-l+1)\\sum_{i=l}^{r}{a_i}}现给出一个假算法的伪代码12345678910111213function find_answer(n, a) # Assumes n is an integer between 1 and 2000, inclusive # Assumes a is a list containing n integers: a[0], a[1], ..., a[n-1] res = 0 cur = 0 k = -1 for i = 0 to i = n-1 cur = cur + a[i] if cur &lt; 0 cur = 0 k = i res = max(res, (i-k)*cur) return res 输出一个序列$~a_0,a_1,\\dots,a_{n-1}~$满足正确算法得到的答案比假算法得到的答案恰好大$~k~$。数据范围$~1\\leq k\\leq10^9,~1\\leq n\\leq2000,~{\\mid a_i\\mid}\\leq10^6~$。 题解不妨令$~a_0=0,~a_i\\geq 0,~\\forall~i&gt;0,~S=\\sum_{i&gt;0} a_i&gt;1~$。于是有$~k=n(S-1)-(n-1)S=S-n~$。令$~n=2000~$，于是$~S=k+2000~$，构造方法十分简单。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const int maxn = 2000; const int maxa = 1000000; int k; cin &gt;&gt; k; k += maxn; cout &lt;&lt; maxn &lt;&lt; endl &lt;&lt; -1; for (int i = 1; i != maxn; ++i) &#123; if (k &gt; maxa) cout &lt;&lt; ' ' &lt;&lt; maxa, k -= maxa; else cout &lt;&lt; ' ' &lt;&lt; k, k = 0; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 541 (Div. 2)","slug":"Codeforces Round 541 (Div. 2)","date":"2019-03-12T05:49:45.902Z","updated":"2019-03-12T05:49:52.721Z","comments":true,"path":"2019/03/12/Codeforces Round 541 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/03/12/Codeforces Round 541 (Div. 2)/","excerpt":"","text":"Codeforces Round #541 (Div. 2) A. Sea Battle题目大意水题。 题解水题。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int w1, h1, w2, h2; cin &gt;&gt; w1 &gt;&gt; h1 &gt;&gt; w2 &gt;&gt; h2; cout &lt;&lt; (w1 + h1 + h2 + 2 &lt;&lt; 1) &lt;&lt; endl;&#125; B. Draw!题目大意水题。 题解水题。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int last = 0, res = 1; while (n--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; res += max(0, min(a, b) - last); last = max(a, b) - (a != b); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; C. Birthday题目大意给定$~n~$个数子，要求排成一个环，使得相邻的差的绝对值之和最小。 题解贪心。升序后奇项排一起偶项排一起。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; sort(a.begin(), a.end()); for (int i = 0; i &lt; n; i += 2) cout &lt;&lt; a[i] &lt;&lt; ' '; for (int i = n &amp; 1 ? n - 2 : n - 1; i != 1; i -= 2) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; a[1] &lt;&lt; endl;&#125; D. Gourmet choice题目大意由$~n+m~$个菜品，给出一个$~n\\times m~$的矩阵表示相应的比较关系。输出根据这个矩阵的打分方式，满足矩阵的比较关系，且不同的分数数量最小。有可能输出不存在。数据范围$~1\\leq n,m\\leq1000~$。 题解拓扑排序。建图时需要注意如果$~a&gt;b~$且$~b=c~$，则需要增加$~a&gt;c~$。可以用$~\\text{DSU}~$并查集和$~\\text{bitset}~$来维护相等的联通块，这样建图的时间复杂度上限为$~O(\\frac{(n+m)^3\\log n+m}{\\text{bitset}})~$（不写按秩合并）。应该还有更优的建图方式，但上述做法能过，总时间复杂度为$~O(\\frac{(n+m)^3\\log n+m}{\\text{bitset}}+(n+m)^2)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 11;int n, m, deg[maxn], fa[maxn], res[maxn];bitset&lt;maxn&gt; mat[maxn], adj[maxn];vector&lt;int&gt; toward[maxn];vector&lt;vector&lt;int&gt;&gt; topo;int find(int x) &#123; return x == fa[x] ? x : (fa[x] = find(fa[x])); &#125;inline void merge(int x, int y) &#123; x = find(x); y = find(y); mat[fa[y] = x] |= mat[y];&#125;void topo_sort() &#123; vector&lt;int&gt; now; for (int i = 0; i != n + m; ++i) &#123; for (int j = 0; j != n + m; ++j) if (adj[i][j]) adj[i] |= mat[find(j)]; for (int j = 0; j != n + m; ++j) if (adj[i][j]) ++deg[j]; &#125; for (int i = 0; i != n + m; ++i) if (!deg[i]) now.push_back(i); int cnt = 0; while (!now.empty()) &#123; cnt += now.size(); topo.push_back(now); vector&lt;int&gt; tmp; for (const auto&amp; i : now) for (int j = 0; j != n + m; ++j) if (adj[i][j]) if (!--deg[j]) tmp.push_back(j); now = tmp; &#125; if (cnt != n + m) exit((cout &lt;&lt; \"No\" &lt;&lt; endl, 0));&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i != n + m; ++i) mat[fa[i] = i].set(i); for (int i = 0; i != n; ++i) for (int j = n; j != n + m; ++j) &#123; char ch; cin &gt;&gt; ch; if (ch == '&lt;') adj[j].set(i); if (ch == '&gt;') adj[i].set(j); if (ch == '=') merge(i, j); &#125; topo_sort(); for (int i = 0; i != (int)topo.size(); ++i) for (const auto&amp; j : topo[i]) res[j] = topo.size() - i; cout &lt;&lt; \"Yes\" &lt;&lt; endl; for (int i = 0; i != n; ++i) cout &lt;&lt; res[i] &lt;&lt; ' '; cout &lt;&lt; endl; for (int i = 0; i != m; ++i) cout &lt;&lt; res[i + n] &lt;&lt; ' '; cout &lt;&lt; endl;&#125; E. String Multiplication题目大意对于给定字符串$~s=\\overline{s_1s_2\\dots s_n}~$和$~t=\\overline{t_1t_2\\dots t_m}~$，定义$~s+t=\\overline{s_1s_2\\dots s_nt_1t_2\\dots t_m}~$和$~s\\cdot t=t+s_1+t+s_2+t+\\dots+t+s_n+t~$。现给定字符串序列$~p_1,p_2,\\dots,p_n~$，问$~(((p_1\\cdot p_2)\\cdot p3)\\cdot\\dots)\\cdot p_n~$中最长的连续相同子序列长度。数据范围$~\\sum{\\mid p\\mid}\\leq100000~$。 题解不难发现$~\\cdot~$运算满足结合律，那么等价于询问$~p_1\\cdot(p_2\\cdot(\\dots\\cdot p_n))~$。直接线性模拟即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; stack&lt;string&gt; strs; while (n--) &#123; string str; cin &gt;&gt; str; strs.push(str); &#125; string now = strs.top(); strs.pop(); int cal1 = 0, cal2 = 0, res = 0, cnt = 0; char ch1 = now.front(), ch2 = now.back(), last = '$'; for (int i = 0; i != (int)now.size(); ++i) &#123; if (now[i] == ch1) ++cal1; else break; &#125; for (int i = now.size() - 1; ~i; --i) &#123; if (now[i] == ch2) ++cal2; else break; &#125; for (const auto&amp; ch : now) &#123; if (ch != last) cnt = 0; res = max(res, ++cnt); last = ch; &#125; bool check = res == (int)now.size(); while (!strs.empty()) &#123; now = strs.top(); strs.pop(); if (check) &#123; int tmp1 = 0, tmp2 = 0, tmp = 0; for (int i = 0; i != (int)now.size(); ++i) &#123; if (now[i] == ch1) ++tmp1; else break; &#125; cal1 = tmp1 + (tmp1 + 1) * res; for (int i = now.size() - 1; ~i; --i) &#123; if (now[i] == ch1) ++tmp2; else break; &#125; cal2 = tmp2 + (tmp2 + 1) * res; cnt = 0; for (const auto&amp; ch : now) &#123; if (ch != ch1) cnt = 0; else tmp = max(tmp, ++cnt); &#125; res = max(res, tmp + (tmp + 1) * res); check = tmp == (int)now.size(); &#125; else if (ch1 == ch2) &#123; if (~now.find(ch1)) res = max(res, cal1 + cal2 + 1); &#125; else &#123; if (~now.find(ch1)) res = max(res, cal1 + 1); if (~now.find(ch2)) res = max(res, cal2 + 1); &#125; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; F. Asya And Kittens给定正整数$~n~$和$~n-1~$对$~x\\not=y~$，满足$~1\\leq x,y\\leq n~$。需要找到一个全排列，初始每项均属于单独的区间。然后按顺序考虑$~(x,y)~$，$x~$所在的区间必须与$~y~$所在的区间相邻，然后将这两个区间合并，最终整个全排列均在一个区间之内。数据范围$~2\\leq n\\leq150000~$。 题解裸并查集。不写按秩合并的时间复杂度上限为$~O(n\\log n)~$。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 150001;int fa[maxn];vector&lt;int&gt; sons[maxn];int find(int x) &#123; return x == fa[x] ? x : (fa[x] = find(fa[x])); &#125;inline void merge(int x, int y) &#123; x = find(x); y = find(y); sons[fa[y] = x].push_back(y);&#125;void dfs(int u) &#123; cout &lt;&lt; u &lt;&lt; ' '; for (auto&amp; v : sons[u]) dfs(v);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) fa[i] = i; while (--n) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y); &#125; dfs(find(1)); cout &lt;&lt; endl;&#125; G. Most Dangerous Shark题目大意给出$~m~$个多米诺骨牌的给高度$~a~$和花费$~c~$。问将所有多米诺骨牌推倒的最小总花费。数据范围$~1\\leq m\\leq10^7,~1\\leq a\\leq m,~1\\leq c\\leq100000~$。 题解用$~left_i~$表示将$~i~$向左推，恰好推倒至$~left_i~$。那么不难发现所有的区间$~I_i=[left_i,i]~$均互相包含或者不交，所以可以通过栈结构来线性求出。同理用$~right_i~$表示将$~i~$向右推，恰好推倒至$~right_i~$。接下来动态规划，用$~dp_i~$表示将前$~i~$个都推倒的最小花费，则有转移式 dp_i=\\min\\lbrace dp_j+c_i:left_i\\leq j< i\\rbrace\\cup\\lbrace dp_{j-1}+c_j:j< i\\leq right_j\\rbrace整个过程均可用栈维护，总时间复杂度为$~O(m)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;pair&lt;int, long long&gt;&gt;&gt; blocks(n); vector&lt;int&gt; a(m + 1), left(m + 1), right(m + 1); vector&lt;long long&gt; c(m + 1), dp(m + 1), minn(m + 1); for (auto&amp; block : blocks) &#123; int k; cin &gt;&gt; k; block.resize(k); for (auto&amp; domi : block) cin &gt;&gt; domi.first; for (auto&amp; domi : block) cin &gt;&gt; domi.second; &#125; int q, index = 0; cin &gt;&gt; q; while (q--) &#123; int id, mul; cin &gt;&gt; id &gt;&gt; mul; for (auto&amp; domi : blocks[id - 1]) &#123; ++index; a[index] = domi.first; c[index] = domi.second * mul; &#125; &#125; stack&lt;int&gt; sta1; for (int i = m; i; --i) &#123; for (right[i] = min(m, i + a[i] - 1); !sta1.empty() &amp;&amp; right[i] &gt;= sta1.top(); sta1.pop()) right[i] = max(right[i], right[sta1.top()]); sta1.push(i); &#125; while (!sta1.empty()) sta1.pop(); dp.front() = 0; stack&lt;pair&lt;int, long long&gt;&gt; sta2; for (int i = 1; i &lt;= m; ++i) &#123; minn[i] = dp[left[i] = max(0, i - a[i])]; for (left[i] = max(0, i - a[i]); !sta1.empty() &amp;&amp; left[i] &lt; sta1.top(); sta1.pop()) &#123; left[i] = min(left[i], left[sta1.top()]); minn[i] = min(minn[i], minn[sta1.top()]); &#125; dp[i] = minn[i] + c[i]; while (!sta2.empty() &amp;&amp; i &gt; right[sta2.top().first]) sta2.pop(); if (sta2.empty()) &#123; sta2.push(make_pair(right[i], dp[i - 1] + c[i])); &#125; else &#123; dp[i] = min(dp[i], sta2.top().second); sta2.push(make_pair(right[i], min(sta2.top().second, dp[i - 1] + c[i]))); &#125; minn[i] = min(minn[i], dp[i]); sta1.push(i); &#125; cout &lt;&lt; dp.back() &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Educational Codeforces Round 61 (Rated for Div. 2)","slug":"Educational Codeforces Round 61 (Rated for Div. 2)","date":"2019-03-10T04:00:44.878Z","updated":"2019-03-10T04:07:59.844Z","comments":true,"path":"2019/03/10/Educational Codeforces Round 61 (Rated for Div. 2)/","link":"","permalink":"http://yoursite.com/2019/03/10/Educational Codeforces Round 61 (Rated for Div. 2)/","excerpt":"","text":"Educational Codeforces Round 61 (Rated for Div. 2) A. Regular Bracket Sequence题目大意现有$~cnt_1~$个$~\\text{((}~$，$cnt_2~$个$~\\text{()}~$，$~cnt_3~$个$~\\text{)(}~$，$~cnt_4~$个$~\\text{))}~$。问能否组合成一个合法括号串。 题解判断$~cnt_1=cnt_4~$，且$~cnt_1&gt;0~$或$~cnt_3=0~$ 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int cnt[4]; for (int i = 0; i != 4; ++i) cin &gt;&gt; cnt[i]; cout &lt;&lt; (cnt[0] == cnt[3] &amp;&amp; (cnt[0] &amp;&amp; !cnt[2])) &lt;&lt; endl;&#125; B. Discounts题目大意水题。 题解水题。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;long long&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; sort(a.begin(), a.end()); long long sum = accumulate(a.begin(), a.end(), 0LL); int m; cin &gt;&gt; m; while (m--) &#123; int q; cin &gt;&gt; q; cout &lt;&lt; sum - a[n - q] &lt;&lt; endl; &#125;&#125; C. Painting the Fence题目大意给定$~n~$以内$~q~$个离散区间，问$~q-2~$个区间的并集最多包含多少个整点。数据范围$~3\\leq n,q\\leq5000~$。 题解考虑$~q-1~$的做法。对于数轴$~1,2,\\dots,n~$上差分，则得到所包含于区间数量的差分数组。同时把每个区间放入其右端点的$~\\text{vector}~$之中。从小到大枚举右端点，则可以知道每个区间中有多少个点的值为$~1~$，代表不取这个区间所减少的答案。整个过程都是线性的，所以时间复杂度为$~O(n+q)~$。那么对于本体，现暴力枚举第一个不选的区间即可，总时间复杂度为$~O(q\\cdot(n+q))~$。 代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, q; cin &gt;&gt; n &gt;&gt; q; vector&lt;int&gt; d(n + 2, 0); vector&lt;pair&lt;int, int&gt;&gt; seg(q); vector&lt;vector&lt;int&gt;&gt; line(n + 1); for (int i = 0; i != q; ++i) &#123; cin &gt;&gt; seg[i].first &gt;&gt; seg[i].second; ++d[seg[i].first]; --d[++seg[i].second]; line[seg[i].second - 1].push_back(i); &#125; int res = 0; for (int i = 0; i != q; ++i) &#123; vector&lt;int&gt; dd(d), sweep(n + 1, 0); --dd[seg[i].first]; ++dd[seg[i].second]; int sub = 0x3f3f3f3f, cal = 0; for (int j = 1; j &lt;= n; ++j) &#123; sweep[j] = sweep[j - 1]; if ((dd[j] += dd[j - 1]) == 1) ++sweep[j]; if (dd[j]) ++cal; for (auto&amp; k : line[j]) if (i != k) sub = min(sub, sweep[seg[k].second - 1] - sweep[seg[k].first - 1]); &#125; res = max(res, cal - sub); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. Stressful Training题目大意有$~n~$台电脑，给出初始电量$~a~$和每分钟耗电$~b~$。总共$~k~$分钟，现有$~1~$个充电器，每分钟只能给$~1~$台电脑充电。问使得在最后一刻之前没有电脑没电（为负）的最小功率或者不存在。数据范围$~1\\leq n,k\\leq2\\cdot10^5,~1\\leq a\\leq10^{17},~1\\leq b\\leq10^{12}~$。 题解二分答案，然后判断是否合法。使用优先队列的话总时间复杂度为$~O(k\\log n\\log\\max)~$，很难通过。对于每台电脑，将其放入没电的时刻所对应的$~\\text{vector}~$之中，模拟这$~k~$分钟即可。这样总时间复杂度为$~O((n+k)\\log\\max)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const long long INF = 0x3f3f3f3f3f3f3f3f;int n, k;long long x;vector&lt;pair&lt;long long, long long&gt;&gt; ab;vector&lt;vector&lt;pair&lt;long long, long long&gt;&gt;&gt; line;bool check() &#123; for (auto&amp; time : line) time.clear(); for (auto&amp; laptop : ab) if (laptop.first / laptop.second &lt; k) line[laptop.first / laptop.second].push_back(laptop); int cnt = 0; int fuck = 0; for (auto&amp; time : line) &#123; ++cnt; for (auto&amp; laptop : time) &#123; long long temp = ((laptop.first / laptop.second + 1) * laptop.second - laptop.first - 1) / x + 1; if ((cnt -= temp) &lt; 0) return false; if ((laptop.first + temp * x) / laptop.second &lt; k) line[(laptop.first + temp * x) / laptop.second].push_back(make_pair(laptop.first + temp * x, laptop.second)); &#125; &#125; return true;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; k; ab.resize(n); line.resize(--k); for (auto&amp; in : ab) cin &gt;&gt; in.first; for (auto&amp; in : ab) cin &gt;&gt; in.second; bool flag = true; for (auto&amp; laptop : ab) if (laptop.first &lt; laptop.second * k) flag = false; if (flag) return cout &lt;&lt; 0 &lt;&lt; endl, 0; long long left = 0, right = INF; while (right - left != 1) &#123; x = (left + right) &gt;&gt; 1; if (check()) right = x; else left = x; &#125; cout &lt;&lt; (right == INF ? -1 : right) &lt;&lt; endl;&#125; E. Knapsack题目大意数字$~1\\leq i\\leq8~$有$~cnt_i~$个。问组成的和在不超过$~W~$下的最大值。 题解考虑$~S=\\gcd(1,2,\\dots,8)=840~$。对于数字$~i~$，取$~\\frac{S}{i}~$个求和能得到$~S~$。动态规划，记$~dp[i][j]~$为已经考虑了前$~i~$个数字，每个数字至多取$~\\min(\\frac{S}{i},cnt_i)~$个，未取过的数字还能凑出多少$~S~$。这样空间复杂度为$~O(8^2\\cdot840)~$，时间复杂度为$~O(8\\cdot\\log8\\cdot840^2)~$。 代码12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const int maxn = 8; const int gcd = 840; long long w, cnt, res = 0; vector&lt;vector&lt;long long&gt;&gt; dp(maxn + 1, vector&lt;long long&gt;(maxn * gcd + 1, -1)); dp.front().front() = 0; cin &gt;&gt; w; for (int i = 1; i &lt;= maxn; ++i) &#123; cin &gt;&gt; cnt; for (int j = 0; j &lt;= gcd / i &amp;&amp; j &lt;= cnt; ++j) for (int k = i * j; k &lt;= maxn * gcd; ++k) if (~dp[i - 1][k - i * j]) dp[i][k] = max(dp[i][k], dp[i - 1][k - i * j] + (cnt - j) / (gcd / i)); &#125; for (int i = 0; i &lt;= maxn * gcd &amp;&amp; i &lt;= w; ++i) if (~dp.back()[i]) res = max(res, i + gcd * min(dp.back()[i], (w - i) / gcd)); cout &lt;&lt; res &lt;&lt; endl;&#125; F. Clear the String题目大意给定一个小写字母串，每次可以消除连续的相同子串，问最小消除次数。数据范围$~1\\leq n\\leq500~$。 题解相邻去重后就是一个区间$~\\text{DP}~$问题。具体见代码，时间复杂度为$~O(n^3)~$。 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;string str;int dp[500][500];int calc(int l, int r) &#123; if (~dp[l][r]) return dp[l][r]; if (l &gt; r) return dp[l][r] = 0; dp[l][r] = calc(l + 1, r) + 1; for (int i = l + 1; i &lt; r; ++i) if (str[l] == str[i]) dp[l][r] = min(dp[l][r], calc(l + 1, i - 1) + calc(i, r)); if (str[l] == str[r]) dp[l][r] = min(dp[l][r], calc(l + 1, r - 1) + 1); return dp[l][r];&#125;int main() &#123; int n; cin &gt;&gt; n &gt;&gt; str; str = string(str.begin(), unique(str.begin(), str.end())); memset(dp, -1, sizeof (dp)); cout &lt;&lt; calc(0, str.size() - 1) &lt;&lt; endl;&#125; G. Greedy Subsequences题目大意给定一个序列$~a_1,a_2,\\dots,a_n~$，定义贪心子序列满足除首项外，每一项均为原序列中右边第一个大于前一项的值。给定$~k~$，输出区间$~[1,k],~[2,k+1],~\\dots,~[n-k+1,n]~$的最长贪心子序列长度。数据范围$~1\\leq k\\leq n\\leq10^6,~1\\leq a\\leq n~$。 题解记$~f(r)=\\max\\lbrace l:a_r\\geq a_l,~l&lt; r\\rbrace~$，其中不妨设$~a_0=\\inf~$。这一步可以通过单调栈线性求出。再令$~g(l,r)~$表示首相为$~a_l~$，右边不超过$~r~$的最长贪心子序列长度。则有转移式 g(l,r)=\\begin{cases} g(l,r-1) &\\text{$l\\leq f(r)$} \\\\ g(l,r-1)+1 &\\text{$l>f(r)$} \\end{cases}且区间$~[r-k+1,r]~$的答案为$~\\max_{l=r-k+1}^{r}{g(l,r)}~$。用线段树维护即可，总时间复杂度为$~O(n\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 20;int a[maxn], seg[maxn &lt;&lt; 1], tag[maxn &lt;&lt; 1];#define mid ((begin + end) &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (index &lt;&lt; 1 ^ 1)#define LEFT begin, mid, lson#define RIGHT mid, end, rson#define SEG left, rightvoid push_down(int index) &#123; seg[index] += tag[index]; if (index &lt; maxn) &#123; tag[lson] += tag[index]; tag[rson] += tag[index]; &#125; tag[index] = 0;&#125;void modify(int begin, int end, int index, int left, int right) &#123; push_down(index); if (begin &gt;= left &amp;&amp; end &lt;= right) &#123; ++tag[index]; return; &#125; if (left &lt; mid) modify(LEFT, SEG); if (right &gt; mid) modify(RIGHT, SEG); seg[index] = max(seg[lson] + tag[lson], seg[rson] + tag[rson]);&#125;int query(int begin, int end, int index, int left, int right) &#123; push_down(index); if (begin &gt;= left &amp;&amp; end &lt;= right) return seg[index]; if (begin &gt;= right || end &lt;= left) return 0; return max(query(LEFT, SEG), query(RIGHT, SEG));&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin &gt;&gt; n &gt;&gt; k; a[0] = 1 &lt;&lt; 20; stack&lt;int&gt; sta; sta.push(0); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; while (a[sta.top()] &lt; a[i]) sta.pop(); modify(0, n, 1, sta.top(), i); sta.push(i); if (i &gt;= k) cout &lt;&lt; query(0, n, 1, i - k, i) &lt;&lt; ' '; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"2014-2015 ACM-ICPC, NEERC, Northern Subregional Contest (TBC)","slug":"2014-2015 ACM-ICPC, NEERC, Northern Subregional Contest (TBC)","date":"2019-03-10T04:00:44.878Z","updated":"2019-03-13T13:21:24.455Z","comments":true,"path":"2019/03/10/2014-2015 ACM-ICPC, NEERC, Northern Subregional Contest (TBC)/","link":"","permalink":"http://yoursite.com/2019/03/10/2014-2015 ACM-ICPC, NEERC, Northern Subregional Contest (TBC)/","excerpt":"","text":"2014-2015 ACM-ICPC, NEERC, Northern Subregional Contest A. Alarm Clock题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen(\"alarm.in\", \"r\", stdin); freopen(\"alarm.out\", \"w\", stdout); map&lt;int, pair&lt;int, int&gt;&gt; res; const int d[] = &#123;6, 2, 5, 5, 4, 5, 6, 3, 7, 6&#125;; for (int i = 0; i != 24; ++i) for (int j = 0; j != 60; ++j) res[d[i % 10] + d[i / 10] + d[j % 10] + d[j / 10]] = make_pair(i, j); int n; scanf(\"%d\", &amp;n); auto ite = res.find(n); if (ite == res.end()) puts(\"Impossible\"); else printf(\"%02d:%02d\\n\", ite-&gt;second.first, ite-&gt;second.second);&#125; B. Buffcraft题目大意水题。 题解水题。有坑。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen(\"buffcraft.in\", \"r\", stdin); freopen(\"buffcraft.out\", \"w\", stdout); int b, k, cd, cp; cin &gt;&gt; b &gt;&gt; k &gt;&gt; cd &gt;&gt; cp; vector&lt;pair&lt;long long, int&gt;&gt; d(cd + 1), p(cp + 1); d.front() = p.front() = make_pair(0, 0); for (int i = 1; i &lt;= cd; ++i) cin &gt;&gt; d[i].first, d[i].second = i; for (int i = 1; i &lt;= cp; ++i) cin &gt;&gt; p[i].first, p[i].second = i; sort(d.begin() + 1, d.end(), greater&lt;pair&lt;long long, int&gt;&gt;()); sort(p.begin() + 1, p.end(), greater&lt;pair&lt;long long, int&gt;&gt;()); vector&lt;long long&gt; dd(cd + 1, 0), pp(cp + 1, 0); for (int i = 1; i &lt;= cd; ++i) dd[i] = dd[i - 1] + d[i].first; for (int i = 1; i &lt;= cp; ++i) pp[i] = pp[i - 1] + p[i].first; int n = 0, m = 0; long long cal = 0; for (int i = 0; i &lt;= min(k, cd); ++i) &#123; long long temp = (b + dd[i]) * (pp[min(cp, k - i)] + 100); if (cal &lt; temp) &#123; cal = temp; n = i; m = min(cp, k - i); &#125; &#125; cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; m &lt;&lt; endl; for (int i = 1; i &lt; n; ++i) cout &lt;&lt; d[i].second &lt;&lt; ' '; if (n) cout &lt;&lt; d[n].second; cout &lt;&lt; endl; for (int i = 1; i &lt; m; ++i) cout &lt;&lt; p[i].second &lt;&lt; ' '; if (m) cout &lt;&lt; p[m].second; cout &lt;&lt; endl;&#125; D. Digits题目大意输出最小的$~n~$个不同正整数的和，满足这些数的各位数之和相等。数据范围$~1\\leq n\\leq5000~$。 题解注意到数据范围较小，考虑爆搜。爆搜$~10^7~$以内的正整数更新数据范围内对应的答案即可。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen(\"digits.in\", \"r\", stdin); freopen(\"digits.out\", \"w\", stdout); vector&lt;long long&gt; res(5001, 0x3f3f3f3f3f3f3f3f), cal(64, 0); vector&lt;int&gt; cnt(64, 0); for (int i = 1; i &lt;= 10000000; ++i) &#123; int sum = 0; for (int j = i; j; j /= 10) sum += j % 10; if (++cnt[sum] &lt;= 5000) res[cnt[sum]] = min(res[cnt[sum]], cal[sum] += i); &#125; int n; cin &gt;&gt; n; cout &lt;&lt; res[n] &lt;&lt; endl;&#125; G. Grave题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen(\"grave.in\", \"r\", stdin); freopen(\"grave.out\", \"w\", stdout); int x[4], y[4], w, h; for (int i = 0; i != 4; ++i) cin &gt;&gt; x[i] &gt;&gt; y[i]; cin &gt;&gt; w &gt;&gt; h; bool flag = false; if (x[2] - x[0] &gt;= w &amp;&amp; y[1] - y[0] &gt;= h) flag = true; if (x[1] - x[3] &gt;= w &amp;&amp; y[1] - y[0] &gt;= h) flag = true; if (x[1] - x[0] &gt;= w &amp;&amp; y[2] - y[0] &gt;= h) flag = true; if (x[1] - x[0] &gt;= w &amp;&amp; y[1] - y[3] &gt;= h) flag = true; cout &lt;&lt; (flag ? \"Yes\" : \"No\") &lt;&lt; endl;&#125; H. Hiking in the Hills题目大意给定一个三维空间下的地形图，表面由$~n~$个三角形拼接而成。然后给定平面上的起点和终点，输出一条路径，使得路径的海拔的最大值最小。数据范围$~2\\leq n\\leq2000~$。 题解对偶图的单源最短路问题。将三角形视为点，任意相接触的两三角形的公共边或公共点是为边，那么边权则是公共部分的最低海拔。暴力建图即可，时间复杂度为$~O(n^2)~$，单元最短路用$~\\text{Dijstra}~$算法，是否堆优化均不影响时间复杂度。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Point &#123; ll x, y, z; Point() &#123;&#125; Point(ll xx, ll yy, ll zz): x(xx), y(yy), z(zz) &#123;&#125; void input() &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; &#125; void output() &#123; cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ' &lt;&lt; z &lt;&lt; '\\n'; &#125; bool operator == (const Point&amp; p) const &#123; return x == p.x &amp;&amp; y == p.y; &#125; Point operator - (const Point&amp; p) const &#123; return Point(x - p.x, y - p.y, 0); &#125; ll operator ^ (const Point&amp; p) const &#123; return x * p.y - y * p.x; &#125;&#125;;inline Point lower(const Point&amp; p1, const Point&amp; p2) &#123; return p1.z &lt; p2.z ? p1 : p2; &#125;struct Triagnle &#123; Point p[3]; Triagnle() &#123;&#125; Triagnle(Point a, Point b, Point c) &#123; p[0] = a, p[1] = b, p[2] = c; &#125; Triagnle(Point pp[]) &#123; for (int i = 0; i != 3; ++i) p[i] = pp[i]; &#125; void input() &#123; for (int i = 0; i != 3; ++i) p[i].input(); &#125; ll area() &#123; return abs((p[1] - p[0]) ^ (p[2] - p[0])); &#125; bool have(Point&amp; pp) &#123; ll cal = 0; for (int i = 0; i != 3; ++i) cal += abs((p[i] - pp) ^ (p[(i + 1) % 3] - pp)); return cal == area(); &#125;&#125;;inline vector&lt;Point&gt; operator &amp; (const Triagnle&amp; t1, const Triagnle&amp; t2) &#123; vector&lt;Point&gt; ret; for (int i = 0; i != 3; ++i) for (int j = 0; j != 3; ++j) if (t1.p[i] == t2.p[j]) ret.push_back(t1.p[i]); return ret;&#125;#define ff first#define ss second#define mp make_pairstruct Node &#123; Point p; int id, from; ll h; Node() &#123;&#125; Node(Point pp, int i, int f, ll hh): p(pp), id(i), from(f), h(hh) &#123;&#125; bool operator &lt; (const Node&amp; n) const &#123; return h &gt; n.h; &#125;&#125;;int main() &#123; freopen(\"hiking.in\", \"r\", stdin); freopen(\"hiking.out\", \"w\", stdout); int n; cin &gt;&gt; n; vector&lt;Triagnle&gt; planes(n); for (auto&amp; plane : planes) plane.input(); vector&lt;vector&lt;pair&lt;int, Point&gt;&gt;&gt; adj(n); for (int i = 0; i != n; ++i) for (int j = i + 1; j != n; ++j) &#123; auto tmp = planes[i] &amp; planes[j]; if (tmp.size()) &#123; if (tmp.size() == 1) &#123; adj[i].push_back(mp(j, tmp.front())); adj[j].push_back(mp(i, tmp.front())); &#125; else &#123; auto p = lower(tmp.front(), tmp.back()); adj[i].push_back(mp(j, p)); adj[j].push_back(mp(i, p)); &#125; &#125; &#125; Point start, finish; start.input(); finish.input(); int begin, end; for (int i = 0; i != n; ++i) if (planes[i].have(start)) &#123; begin = i; break; &#125; for (int i = 0; i != n; ++i) if (planes[i].have(finish)) &#123; end = i; break; &#125; priority_queue&lt;Node&gt; que; que.push(Node(start, begin, begin, start.z)); vector&lt;bool&gt; vis(n, false); vector&lt;int&gt; from(n); vector&lt;Point&gt; nodes(n); while (!que.empty()) &#123; auto now = que.top(); que.pop(); if (vis[now.id]) continue; vis[now.id] = true; from[now.id] = now.from; nodes[now.id] = now.p; for (auto&amp; next : adj[now.id]) if (!vis[next.ff]) que.push(Node(next.ss, next.ff, now.id, max(now.h, next.ss.z))); &#125; vector&lt;Point&gt; res(1, finish); while (true) &#123; res.push_back(nodes[end]); if (end == begin) break; end = from[end]; &#125; reverse(res.begin(), res.end()); cout &lt;&lt; res.size() &lt;&lt; '\\n'; for (auto&amp; ans : res) ans.output();&#125; I. Instruction题目大意铁路轨道视为一棵$~n~$个节点的二叉树，起点为根节点，终点为叶节点。然后给定$~m~$列火车的出发时刻$~t~$和终点$~p~$。每个非叶节点的初始指向为编号较小的子节点。为使得每辆火车均到达相应终点，那么需要在一些时刻修改一些非叶节点的指向。输出一种不超过$~100000~$次的修改方案。数据范围$~3\\leq n\\leq51,~1\\leq m\\leq100,~0\\leq t\\leq10000,~1\\leq p\\leq26~$。 题解模拟。对于每辆火车，考虑它从起点到终点的过程，则可以得到这条路径上的非叶节点在某些时刻需要满足的状态（指向哪个子节点）。最终对于每个节点，所有的状态按时间升序然后去重即可。总时间复杂度为$~O(nm\\log m)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;#define ff first#define ss second#define mp make_pairint main() &#123; freopen(\"instruction.in\", \"r\", stdin); freopen(\"instruction.out\", \"w\", stdout); int n; cin &gt;&gt; n; int p[128], fa[64], son[64][2], tmp[64] = &#123;0&#125;, to[64][64], go[64][64], state[64] = &#123;0&#125;, check[64] = &#123;0&#125;; for (int i = 1; i &lt;= n; ++i) &#123; char ch; int f; cin &gt;&gt; ch &gt;&gt; f; fa[i] = f; to[f][i] = tmp[f]; son[f][tmp[f]++] = i; if (ch == 'p') &#123; char name; cin &gt;&gt; name; p[name] = i; for (int j = i; j; j = fa[j]) go[fa[j]][i] = to[fa[j]][j]; &#125; else &#123; check[i] = 1; &#125; &#125; vector&lt;pii&gt; node[64], res; int m; cin &gt;&gt; m; while (m--) &#123; int t; char ch; cin &gt;&gt; t &gt;&gt; ch; int id = p[ch]; for (int i = 0; i != id; i = son[i][go[i][id]]) node[i].push_back(mp(t++, go[i][id])); &#125; for (int i = 1; i &lt;= n; ++i) if (check[i]) &#123; sort(node[i].begin(), node[i].end()); int now = 0; for (auto fuck : node[i]) if (now != fuck.ss) &#123; now = fuck.ss; res.push_back(mp(fuck.ff, i)); &#125; &#125; sort(res.begin(), res.end()); cout &lt;&lt; res.size() &lt;&lt; '\\n'; for (auto ans : res) cout &lt;&lt; ans.ss &lt;&lt; ' ' &lt;&lt; ans.ff &lt;&lt; '\\n';&#125; J. Joy of Flight题目大意给定起点和终点坐标，飞机需要恰好在第$~k~$秒到达终点，同时给出这期间的风向变化和飞机的最大速度$~v_\\max~$，每秒飞机的真实位移等于飞机速度向量于风速向量之和。输出每秒飞机所到达的坐标或者不存在到达终点的方案。 题解分离风速与自身速度。那么方案存在等价于起点经过$~k~$秒的风吹所到达的坐标与终点的距离$~dis~$小于等于$~k\\cdot v_\\max~$。那么每秒的飞机速度即为$~\\frac{dis}{k}~$。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;long long, long long&gt; pll;#define ff first#define ss second#define mp make_pairint main() &#123; freopen(\"joy.in\", \"r\", stdin); freopen(\"joy.out\", \"w\", stdout); pll begin, end; scanf(\"%lld%lld%lld%lld\", &amp;begin.ff, &amp;begin.ss, &amp;end.ff, &amp;end.ss); int n, k; long long vmax; scanf(\"%d%d%lld\", &amp;n, &amp;k, &amp;vmax); vector&lt;pair&lt;int, pll&gt;&gt; input(n); vector&lt;pll&gt; winds(k); for (int i = 0; i != n; ++i) &#123; scanf(\"%d%lld%lld\", &amp;input[i].ff, &amp;input[i].ss.ff, &amp;input[i].ss.ss); for (int j = input[i - 1].ff; i &amp;&amp; j != input[i].ff; ++j) winds[j] = input[i - 1].ss; &#125; for (int i = input.back().ff; i != k; ++i) winds[i] = input.back().ss; pll flow = mp(end.ff - begin.ff, end.ss - begin.ss); for (auto&amp; wind : winds) flow = mp(flow.ff - wind.ff, flow.ss - wind.ss); if (flow.ff * flow.ff + flow.ss * flow.ss &gt; vmax * vmax * k * k) return puts(\"No\"), 0; puts(\"Yes\"); pll temp = begin; int day = 0; for (auto&amp; wind : winds) &#123; ++day; temp = mp(temp.ff + wind.ff, temp.ss + wind.ss); printf(\"%f %f\\n\", temp.ff + (double)flow.ff * day / k, temp.ss + (double)flow.ss * day / k); &#125;&#125; K. Kebab House题目大意数轴上从$~1~$开始有$~n~$个相连的线段区间，并给出每个区间的长度$~q~$。现要在所有线段内合法的取若干个点，满足相邻的两个点之间所未取到的点的数量至少为$~t~$，每个线段内最多取$~q-x~$个点。问合法的方案数（包括不取）。数据范围$~1\\leq n\\leq1000,~0\\leq t\\leq100,~0\\leq q\\leq250,~0\\leq x\\leq q~$。 题解动态规划。问$~\\text{WSY}~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using ul = std::uint32_t;using li = std::int32_t;using ll = std::int64_t;using ull = std::uint64_t;const ul base = 1e9 + 7;ul plus(ul a, ul b)&#123; return a + b &lt; base ? a + b : a + b - base;&#125;ul minus(ul a, ul b)&#123; return a &lt; b ? a + base - b : a - b;&#125;ul mul(ul a, ul b)&#123; return ull(a) * ull(b) % ull(base);&#125;//#define TEST#ifdef TESTstd::istream&amp; myis = std::cin;std::ostream&amp; myos = std::cout;#endif#ifndef TESTstd::ifstream myis(\"kebab.in\");std::ofstream myos(\"kebab.out\");#endiful m, n, t;ul segst[250001];ul segable[250001];ul sum[250001];ul ans[250001][251];ul finalans = 1;int main()&#123; std::ios::sync_with_stdio(false); myis.tie(0); myis &gt;&gt; m &gt;&gt; t; for (ul i = 0, st = 1; i != m; ++i) &#123; ul q, x; myis &gt;&gt; q &gt;&gt; x; for (ul j = st; j != st + q; ++j) &#123; segst[j] = st; segable[j] = q - x; &#125; st = st + q; n = st - 1; &#125; sum[0] = 1; for (ul i = 1; i &lt;= n; ++i) &#123; sum[i] = sum[i - 1]; for (ul j = 1; j &lt;= segable[i]; ++j) &#123; if (j == 1) &#123; if (i &gt;= t + 1) &#123; ans[i][j] = sum[std::min(i - t - 1, segst[i] - 1)]; &#125; else &#123; ans[i][j] = 1; &#125; &#125; else &#123; if (i &gt;= t + 1 &amp;&amp; i - t - 1 &gt;= segst[i] + j - 2) &#123; ans[i][j] = minus(ans[i - t - 1][j - 1], segst[i] + j - 2 &gt;= 1 ? ans[segst[i] + j - 3][j - 1] : ul(0)); &#125; &#125; sum[i] = plus(sum[i], ans[i][j]); finalans = plus(finalans, ans[i][j]); ans[i][j] = plus(ans[i - 1][j], ans[i][j]); &#125; &#125; myos &lt;&lt; finalans &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[]},{"title":"EOJ Monthly 2019.2 (based on February Selection)","slug":"EOJ Monthly 2019.2 (based on February Selection)","date":"2019-02-25T09:29:22.057Z","updated":"2019-02-27T09:08:35.860Z","comments":true,"path":"2019/02/25/EOJ Monthly 2019.2 (based on February Selection)/","link":"","permalink":"http://yoursite.com/2019/02/25/EOJ Monthly 2019.2 (based on February Selection)/","excerpt":"","text":"EOJ Monthly 2019.2 (based on February Selection) A. 回收卫星题目大意交互题。有一个球心为$~(x,~y,~z)~$半径为$~r~$的球，且原点$~(0,~0,~0)~$保证在球内部或边界上。每次可以询问一个点是否在球的内部或边界上，需要在至多$~200~$次询问下确定球心坐标。数据范围$~{\\mid x\\mid}\\leq10^9,~{\\mid y\\mid}\\leq10^9,~{\\mid z\\mid}\\leq10^9,~1\\leq r\\leq10^9~$。 题解通过二分可以确定$~x_1=\\max\\lbrace x_0\\mid(x-x_0)^2+y^2+z^2\\leq r^2\\rbrace~$和$~x_2=\\min\\lbrace x_0\\mid(x-x_0)^2+y^2+z^2\\leq r^2\\rbrace~$。注意到绝对值最大为$~2\\times10^9~$，二分上界必须大于该数，且会爆$~\\text{int}~$。考虑关于$~x_0~$的一元二次方程 (x-x_0)^2+y^2+z^2=r^2解为 x_0=x\\pm\\sqrt{r^2-y^2-z^2}于是有 x_1=x+\\left\\lfloor\\sqrt{r^2-y^2-z^2}\\right\\rfloor \\\\ x_2=x-\\left\\lfloor\\sqrt{r^2-y^2-z^2}\\right\\rfloor \\\\ x={\\frac{x_1+x_2}{2}}同理可解出$~y~$与$~z~$。次数最多$~6\\times32=192~$次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 2000000001;inline int query(const int&amp; x, const int&amp; y, const int&amp; z) &#123; cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ' &lt;&lt; z &lt;&lt; endl; int ret; cin &gt;&gt; ret; return ret;&#125;int main() &#123; long long left, right, x1, x2, y1, y2, z1, z2; &#123; left = 0, right = INF; while (right - left != 1) &#123; int mid = left + right &gt;&gt; 1; if (query(mid, 0, 0)) left = mid; else right = mid; &#125; x1 = left; &#125; &#123; left = 0, right = INF; while (right - left != 1) &#123; int mid = left + right &gt;&gt; 1; if (query(-mid, 0, 0)) left = mid; else right = mid; &#125; x2 = -left; &#125; &#123; left = 0, right = INF; while (right - left != 1) &#123; int mid = left + right &gt;&gt; 1; if (query(0, mid, 0)) left = mid; else right = mid; &#125; y1 = left; &#125; &#123; left = 0, right = INF; while (right - left != 1) &#123; int mid = left + right &gt;&gt; 1; if (query(0, -mid, 0)) left = mid; else right = mid; &#125; y2 = -left; &#125; &#123; left = 0, right = INF; while (right - left != 1) &#123; int mid = left + right &gt;&gt; 1; if (query(0, 0, mid)) left = mid; else right = mid; &#125; z1 = left; &#125; &#123; left = 0, right = INF; while (right - left != 1) &#123; int mid = left + right &gt;&gt; 1; if (query(0, 0, -mid)) left = mid; else right = mid; &#125; z2 = -left; &#125; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; (x1 + x2 &gt;&gt; 1) &lt;&lt; ' ' &lt;&lt; (y1 + y2 &gt;&gt; 1) &lt;&lt; ' ' &lt;&lt; (z1 + z2 &gt;&gt; 1) &lt;&lt; endl;&#125; B. 解题题目大意给定一个$~n~$位大整数，询问$~q~$次，每次给定一个正整数$~m~$。选取大整数十进制表示下连续的一段保留，其余全变成$~0~$，找出最小的如此生成的正整数满足是$~m~$的倍数，或者不存在。数据范围$~1\\leq n\\leq10^6,~1\\leq q\\leq500,~\\sum m\\leq5\\times10^7~$。 题解记$~a_i~$为大整数后$~i~$位模$~m~$的余数，注意需要添加$~a_0=0~$。取区间$~[l,r]~$生成的数字是$~m~$的倍数，等价于$~a_{n+1-l}=a_{n-r}~$。只要将$~i~$从小到大计算$~a_i~$，对于最小的$~j~$，存在$~i&lt; j~$满足$~a_i=a_j~$，则答案$~[l,r]=[n+1-j,n-i]~$。由抽屉原理，至多计算$~m+1~$次就一定能得出答案。总时间复杂度为$~O(\\sum m)~$。 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); string num; cin &gt;&gt; num; const int n = num.size(); vector&lt;int&gt; dig(n); for (int i = 0; i != n; ++i) dig[i] = num[i] - '0'; int q; cin &gt;&gt; q; while (q--) &#123; int m; cin &gt;&gt; m; vector&lt;int&gt; pos(m, 0); pos[0] = n; bool flag = true; int base = 1, now = 0; for (int i = n - 1; ~i; --i) &#123; now = (now + base * dig[i]) % m; if (pos[now]) &#123; cout &lt;&lt; i + 1 &lt;&lt; ' ' &lt;&lt; pos[now] &lt;&lt; '\\n'; flag = false; break; &#125; pos[now] = i; base = base * 10 % m; &#125; if (flag) cout &lt;&lt; -1 &lt;&lt; '\\n'; &#125;&#125; C. 魔板题目大意有一个$~n\\times m~$个格点的网格图，第$~i~$行第$~j~$列的坐标为$~(i,j)~$。每个点有个数字，有序状态下$~(i,j)~$的数字为$~(i-1)\\times m+j~$。有两种置换方式：选择$~(x&lt; n,~y&lt; m)~$，将$~(x,y),(x+1,y),(x,y+1)~$上的数字顺时针交换；选择$~(x&lt; n,~y&lt; m)~$，将$~(x,y),(x+1,y),(x+1,y+1),(x,y+1)~$上的数字顺时针交换。现给定一个打乱的状态，输出任意一种使其有序的操作方式，且次数不能超过$~3\\cdot10^6~$。数据范围$~2\\leq n,m\\leq100~$。 题解构造大模拟。注意到先进行$~1~$次操作$~2~$再进行$~2~$次操作$~1~$，等价于只交换$~(x+1,y)~$和$~(x+1,y+1)~$。先进行$~2~$次操作$~1~$再进行$~1~$次操作$~2~$，等价于只交换$~(x,y+1)~$和$~(x+1,y+1)~$。那么暴力模拟即可，上限$~3\\cdot10^6~$其实很宽松。 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;#define ff first#define ss second#define mp make_pairpii pos[10001];int mat[101][101], m, n, res_size;pair&lt;int, pii&gt; res[1 &lt;&lt; 22];inline void work1(int x, int y) &#123; int a = mat[x][y], b = mat[x + 1][y], c = mat[x][y + 1]; pos[mat[x + 1][y] = a] = mp(x + 1, y); pos[mat[x][y + 1] = b] = mp(x, y + 1); pos[mat[x][y] = c] = mp(x, y); res[res_size++] = mp(1, mp(x, y));&#125;inline void work2(int x, int y) &#123; int a = mat[x][y], b = mat[x + 1][y], c = mat[x + 1][y + 1], d = mat[x][y + 1]; pos[mat[x + 1][y] = a] = mp(x + 1, y); pos[mat[x + 1][y + 1] = b] = mp(x + 1, y + 1); pos[mat[x][y + 1] = c] = mp(x, y + 1); pos[mat[x][y] = d] = mp(x, y); res[res_size++] = mp(2, mp(x, y));&#125;inline void swap_up(int x, int y) &#123; work2(x, y); work1(x, y); work1(x, y);&#125;inline void swap_right(int x, int y) &#123; work1(x, y); work1(x, y); work2(x, y);&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; mat[i][j]; pos[mat[i][j]] = mp(i, j); &#125; for (int i = 1, k = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j, ++k) &#123; while (pos[k].ss &lt; j) &#123; if (pos[k].ff != n) &#123; work1(pos[k].ff, pos[k].ss); work1(pos[k].ff - 1, pos[k].ss); &#125; else &#123; swap_up(pos[k].ff - 1, pos[k].ss); &#125; &#125; while (pos[k].ss &gt; j) &#123; if (pos[k].ff != n) &#123; work1(pos[k].ff, pos[k].ss - 1); &#125; else &#123; swap_up(pos[k].ff - 1, pos[k].ss - 1); &#125; &#125; while (pos[k].ff &gt; i + 1) &#123; if (j != 1) &#123; work2(pos[k].ff - 1, pos[k].ss - 1); &#125; else &#123; work1(pos[k].ff - 1, pos[k].ss); work1(pos[k].ff, pos[k].ss - 1); &#125; &#125; if (pos[k].ff != i) &#123; if (j != m) &#123; work1(pos[k].ff - 1, pos[k].ss); work1(pos[k].ff, pos[k].ss - 1); &#125; else &#123; swap_right(pos[k].ff - 1, pos[k].ss - 1); &#125; &#125; &#125; cout &lt;&lt; res_size &lt;&lt; '\\n'; for (int i = 0; i != res_size; ++i) cout &lt;&lt; res[i].ff &lt;&lt; ' ' &lt;&lt; res[i].ss.ff &lt;&lt; ' ' &lt;&lt; res[i].ss.ss &lt;&lt; '\\n';&#125; D. 进制转换题目大意问$~[l,r]~$中有多少个数的$~k~$进制表示恰好有$~m~$个末尾$~0~$。数据范围$1\\leq T\\leq10^5,~1\\leq l\\leq r\\leq10^18,~2\\leq k,m\\leq100$。 题解水题。预处理所有的$~k^m~$，然后将$~k^m~$的倍数的数量减去$~k^{m+1}~$的数量即可。总时间复杂度为$~O(km+T)~$，注意细节。 代码1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const long long INF = 0x3f3f3f3f3f3f3f3f;long long pown[101][102];inline long long calc(const long long&amp; n, const int&amp; k, const int&amp; m) &#123; return (~pown[k][m] ? n / pown[k][m] : 0) - (~pown[k][m + 1] ? n / pown[k][m + 1] : 0);&#125;int main() &#123; for (int i = 2; i &lt;= 100; ++i) &#123; pown[i][0] = 1; for (int j = 1; j &lt;= 101; ++j) &#123; if (pown[i][j - 1] &lt; INF / i &amp;&amp; ~pown[i][j - 1]) pown[i][j] = pown[i][j - 1] * i; else pown[i][j] = -1; &#125; &#125; int t; cin &gt;&gt; t; while (t--) &#123; long long l, r; int k, m; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k &gt;&gt; m; cout &lt;&lt; calc(r, k, m) - calc(l - 1, k, m) &lt;&lt; endl; &#125;&#125; E. 中位数题目大意给定一个带点权有重边的有向无环图$~\\text{DAG}~$，问点$~1~$到点$~n~$所有路径的最大中位数。路径的中位数定义为升序后角标为$~\\lfloor\\frac{x}{2}\\rfloor+1~$的权值。 题解二分套$~\\text{DAG}~$上差分$~\\text{DP}~$。二分答案，然后对于权值大于等于当前值的点标记为$~1~$反之为$~-1~$。从点$~1~$开始跑$~\\text{DP}~$，如果点$~n~$的结果小于$~0~$，则当前值过大。可以先对$~\\text{DAG}~$先拓扑排序，这样$~\\text{DP}~$过程不需要用递归实现，常数小。总时间复杂度为$~O(n\\log A)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 20;int deg[maxn], a[maxn], cal[maxn];vector&lt;int&gt; adj[maxn], topo;void dfs(int u = 1) &#123; for (auto v : adj[u]) if (!deg[v]++) dfs(v); &#125;void topo_sort() &#123; topo.push_back(1); for (int i = 0; i != (int)topo.size(); ++i) for (auto j : adj[topo[i]]) if (!--deg[j]) topo.push_back(j);&#125;bool check(const int&amp; x, const int&amp; end) &#123; memset(cal, 0xc0, sizeof (cal)); cal[1] = 0; for (auto u : topo) &#123; a[u] &lt; x ? --cal[u] : ++cal[u]; for (auto v : adj[u]) cal[v] = max(cal[v], cal[u]); &#125; return cal[end] &gt;= 0;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); &#125; dfs(); if (!deg[n]) return cout &lt;&lt; -1 &lt;&lt; endl, 0; topo_sort(); int left = 0, right = 0x3f3f3f3f; while (right - left != 1) &#123; int mid = (left + right) &gt;&gt; 1; if (check(mid, n)) left = mid; else right = mid; &#125; cout &lt;&lt; left &lt;&lt; endl;&#125; F. 方差题目大意给定$~n~$个数，问$~m~$个数的最小方差$~\\sigma^2~$是多少，输出$~\\sigma^2m^2~$。数据范围$~1\\leq m\\leq n\\leq10^6,~1\\leq x\\leq10^3~$。 题解先排序，注意到数据范围，桶排（基数排序）的时间复杂度为$~O(n+x)~$。注意到方差计算公式 \\begin{aligned} \\sigma^2 &=\\frac{1}{m}\\sum(a-\\bar{a})^2 \\\\ &=\\frac{1}{m}\\sum a^2-\\bar{a}^2 \\end{aligned}于是答案计算公式为 \\max\\{m\\sum_{i=l}^{r}a_i^2-(\\sum_{i=l}^{r}a_i)^2\\}滑窗即可。总时间复杂度为$~O(n+x)~$。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;long long a[1 &lt;&lt; 20];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i ^ n; ++i) cin &gt;&gt; a[i]; sort(a, a + n); long long cal1 = 0, cal2 = 0; for (int i = 0; i ^ m; ++i) cal1 += a[i] * a[i], cal2 += a[i]; long long res = cal1 * m - cal2 * cal2; for (int i = m; i ^ n; ++i) &#123; cal1 += a[i] * a[i] - a[i - m] * a[i - m]; cal2 += a[i] - a[i - m]; res = min(res, cal1 * m - cal2 * cal2); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"http://yoursite.com/categories/刷题笔记/"}],"tags":[]},{"title":"Educational Codeforces Round 60 (Rated for Div. 2)","slug":"Educational Codeforces Round 60 (Rated for Div. 2)","date":"2019-02-24T12:46:50.771Z","updated":"2019-04-18T10:27:35.911Z","comments":true,"path":"2019/02/24/Educational Codeforces Round 60 (Rated for Div. 2)/","link":"","permalink":"http://yoursite.com/2019/02/24/Educational Codeforces Round 60 (Rated for Div. 2)/","excerpt":"","text":"Educational Codeforces Round 60 (Rated for Div. 2) A. Best Subsegment题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; int x = * max_element(a.begin(), a.end()); int res = 0, cnt = 0; for (auto aa : a) &#123; if (aa ^ x) res = max(res, cnt), cnt = 0; else ++cnt; &#125; cout &lt;&lt; max(res, cnt) &lt;&lt; endl;&#125; B. Emotes题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; vector&lt;long long&gt; a(n); long long max1 = 0, max2 = 0; while (n--) &#123; long long a; cin &gt;&gt; a; if (a &gt; max2) max2 = a; if (max1 &lt; max2) swap(max1, max2); &#125; cout &lt;&lt; m / (k + 1) * (max1 * k + max2) + m % (k + 1) * max1 &lt;&lt; endl;&#125; C. Magic Ship题目大意要让一艘船从$~(x_1,~y_1)~$走到$~(x_2,~y_2)~$，每天可以选择上下左右或者不走。但是还有给定的周期为$~n~$的风速影响，每天船的最终移动为当前的风速与船速的选择之和。问到达目的地的最短时间或达不到。 题解将船速和风速分开考虑。那么第$~k~$天能到达目的地，当且仅当$~{\\mid x_2-x_3\\mid+\\mid y_2-y_3\\mid}\\leq k~$。其中$~(x_3,~y_3)~$为如果这$~k~$天船本身静止依靠风速所到达的地点。那么就可以二分天数得出答案了。总时间复杂度为$~O(n+\\log\\max)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;long long, long long&gt; pll;#define mp make_pair#define ff first#define ss secondinline pll operator + (const pll&amp; x, const pll&amp; y) &#123;return mp(x.ff + y.ff, x.ss + y.ss);&#125;inline pll operator - (const pll&amp; x, const pll&amp; y) &#123;return mp(x.ff - y.ff, x.ss - y.ss);&#125;inline pll operator * (const pll&amp; x, const long long&amp; y) &#123;return mp(x.ff * y, x.ss * y);&#125;const long long INF = 0x3f3f3f3f3f3f3f3f;const int maxn = 1e5 + 5;int n;pll wind[maxn], p1, p2;inline bool check(const long long&amp; step) &#123; pll tmp = wind[n] * (step / n) + wind[step % n] - p2; return abs(tmp.ff) + abs(tmp.ss) &lt;= step;&#125;int main() &#123; cin &gt;&gt; p1.ff &gt;&gt; p1.ss &gt;&gt; p2.ff &gt;&gt; p2.ss &gt;&gt; n; p2 = p2 - p1; map&lt;char, pll&gt; cal; cal['U'] = mp(0LL, 1LL); cal['D'] = mp(0LL, -1LL); cal['L'] = mp(-1LL, 0LL); cal['R'] = mp(1LL, 0LL); for (int i = 1; i &lt;= n; ++i) &#123; char ch; cin &gt;&gt; ch; wind[i] = wind[i - 1] + cal[ch]; &#125; long long left = 0, right = INF; while (right - left ^ 1) &#123; long long mid = left + right &gt;&gt; 1; if (check(mid)) right = mid; else left = mid; &#125; cout &lt;&lt; (right ^ INF ? right : -1) &lt;&lt; endl;&#125; D. Magic Gems题目大意观察样例可知题目等价于询问有多少长度为$~N~$的$~01~$序列使得每段连续的$~0~$的长度都是$~M~$的倍数。数据范围$~1\\leq N\\leq10^{18},~2\\leq M\\leq100~$。 题解显然有答案序列的转移式$~res_N=res_{N-1}+res_{N-M}~$。那么转化为矩阵快速幂问题可以在$~O(M^3\\log N)~$的时间复杂内解决。当然也存在$~O(M^2\\log N)~$与$~O(M\\log M\\log N)~$的算法。 代码（$~O(M^3\\log N)~$）1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;int base[100][100], mat[100][100], tmp[100][100], m;inline void mul(int C[][100], int A[][100], int B[][100]) &#123; for (int i = 0; i ^ m; ++i) for (int j = 0; j ^ m; ++j) &#123; C[i][j] = 0; for (int k = 0; k ^ m; ++k) C[i][j] = add(C[i][j], mul(A[i][k], B[k][j])); &#125;&#125;int main() &#123; long long n; cin &gt;&gt; n &gt;&gt; m; base[0][0] = base[0][m - 1] = mat[0][0] = 1; for (int i = 1; i ^ m; ++i) base[i][i - 1] = mat[i][i] = 1; while (n) &#123; if (n &amp; 1) &#123; mul(tmp, mat, base); memcpy(mat, tmp, sizeof (tmp)); &#125; mul(tmp, base, base); memcpy(base, tmp, sizeof (tmp)); n &gt;&gt;= 1; &#125; cout &lt;&lt; mat[0][0] &lt;&lt; endl;&#125; 代码（$~O(M^2\\log N)~$）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef vector&lt;int&gt; vi;const int mod = 1e9 + 7;inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;vi linear_calc(vi&amp; c, long long n) &#123; int size = c.size(); if (size == 1) &#123; int ret = 1; for (int a = c.front(); n; n &gt;&gt;= 1) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); &#125; return vi(1, ret); &#125; vector&lt;vi&gt; base(size &lt;&lt; 1, vi(size, 0)), pow(64, vi(size, 0)); base[0][0] = 1; for (int i = 1; i ^ size &lt;&lt; 1; ++i) for (int j = 0; j ^ size; ++j) base[i][j] = add(mul(base[i - 1].back(), c[j]), j ? base[i - 1][j - 1] : 0); if (n &lt; (size &lt;&lt; 1)) return base[n]; pow[0][1] = 1; for (int i = 1; i ^ 64; ++i) &#123; vi tmp(size &lt;&lt; 1, 0); for (int j = 0; j ^ size; ++j) for (int k = 0; k ^ size; ++k) tmp[j + k] = add(tmp[j + k], mul(pow[i - 1][j], pow[i - 1][k])); for (int j = 0; j ^ size &lt;&lt; 1; ++j) for (int k = 0; k ^ size; ++k) pow[i][k] = add(pow[i][k], mul(tmp[j], base[j][k])); &#125; int index = 62; while ((1LL &lt;&lt; index) &gt; n) --index; vi ret = pow[index]; n ^= 1LL &lt;&lt; index; while (n) &#123; while ((1LL &lt;&lt; index) &gt; n) --index; n ^= 1LL &lt;&lt; index; vi tmp(size &lt;&lt; 1, 0); for (int i = 0; i ^ size; ++i) for (int j = 0; j ^ size; ++j) tmp[i + j] = add(tmp[i + j], mul(ret[i], pow[index][j])); fill(ret.begin(), ret.end(), 0); for (int i = 0; i ^ size &lt;&lt; 1; ++i) for (int j = 0; j ^ size; ++j) ret[j] = add(ret[j], mul(tmp[i], base[i][j])); &#125; return ret;&#125;int main() &#123; long long n; int m; cin &gt;&gt; n &gt;&gt; m; vi base(m, 0); base.front() = base.back() = 1; base = linear_calc(base, n); int res = 0; for (auto x : base) res = add(res, x); cout &lt;&lt; res &lt;&lt; endl;&#125; E. Decypher the String题目大意交互题。现有一个确定但不给出的字符串重排置换，然后给定一个某字符串经过该置换得到的新串。你可以询问任意一个同样长度的字符串，然后返回经过该置换得到的新串。要求在$~3~$次询问以内找出给定串的原串。所有字符串均为小写字母串。数据范围$~1\\leq n\\leq10^4~$。 题解字符集大小为$~26~$。那么考虑这样的一个询问：字符串开头从$~\\text{a}~$开始，每隔$~26^k~$个字符切换到下一个字母。那么就可以得到逆置换下，每个位置所指向的新位置模$~26^{k+1}~$的余数$~x~$再除以$~26^k~$的下取整$~\\lfloor\\frac{x}{26^k}\\rfloor~$的值是多少。所以当$~n\\leq10^4\\leq26^3~$时，做$~3~$次询问就能确定置换。 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str, ask[3], ans[3], res(26 * 26 * 26, '#'); for (char i = 'a'; i &lt;= 'z'; ++i) for (char j = 'a'; j &lt;= 'z'; ++j) for (char k = 'a'; k &lt;= 'z'; ++k) &#123; ask[0].append(1, i); ask[1].append(1, j); ask[2].append(1, k); &#125; cin &gt;&gt; str; int n = str.size(); str.append(26 * 26 * 26 - n, '#'); for (int i = 0; i ^ 3; ++i) &#123; cout &lt;&lt; \"? \" &lt;&lt; ask[i].substr(0, n) &lt;&lt; endl; cin &gt;&gt; ans[i]; ans[i].append(ask[i], n, 26 * 26 * 26 - n); &#125; for (int i = 0; i ^ 26 * 26 * 26; ++i) res[26 * 26 * (ans[0][i] - 'a') + 26 * (ans[1][i] - 'a') + (ans[2][i] - 'a')] = str[i]; cout &lt;&lt; \"! \" &lt;&lt; res.substr(0, n) &lt;&lt; endl;&#125; F. Crisp String题目大意给定一个长度为$~n~$由前$~p~$个小写字母组成的字符串，以及一个$~p\\times p~$的$~01~$对称矩阵。定义一个字符串是$~\\text{crisp}~$的，当且仅当字符串中所有相邻的字符对在矩阵中对应的值是$~1~$，保证给定字符串是$~\\text{crisp}~$的。每一步操作可以选择一个还有的字母，将字符串中所有该字母删除。在保证每一步操作后字符串依然是$~\\text{crisp}~$的条件下，问字符串最短长度。数据范围$~1\\leq n\\leq10^5,~1\\leq p\\leq17~$。 题解状压$~\\text{DP}~$。按位储存当前状态下还有那些字母存在，那么只需要考虑每个状态的合法性即可。对于每对字母$~(i,~j)~$，可以线性对字符串扫描一遍，算出恰好使得$~i~$与$~j~$相邻所需要删除的状态。然后再对所有状态$~\\text{DP}~$，得出在每个状态下$~i~$与$~j~$是否相邻。总时间复杂度为$~O(np^2+p^32^p)~$。代码所写的常数比较大，也存在$~O(np+p^32^p)~$的做法。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int n, p, A[17][17], cnt[17], cal[1 &lt;&lt; 17], res = maxn, a[maxn];bool check[1 &lt;&lt; 17], adj[17][17][1 &lt;&lt; 17], vis[1 &lt;&lt; 17];void dfs(int mask) &#123; if (vis[mask]) return; vis[mask] = true; for (int i = 0; i != p; ++i) for (int j = 0; j != p; ++j) if (mask &amp; 1 &lt;&lt; i &amp;&amp; mask &amp; 1 &lt;&lt; j &amp;&amp; !A[i][j] &amp;&amp; adj[i][j][((1 &lt;&lt; p) - 1) ^ mask]) return; res = min(res, cal[mask]); for (int i = 0; i != p; ++i) if (mask &amp; 1 &lt;&lt; i) dfs(mask ^ 1 &lt;&lt; i);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); string str; cin &gt;&gt; n &gt;&gt; p &gt;&gt; str; for (int i = 0; i != p; ++i) for (int j = 0; j != p; ++j) cin &gt;&gt; A[i][j]; for (int i = 0; i != n; ++i) ++cnt[a[i] = str[i] - 'a']; for (int i = 1; i != (1 &lt;&lt; p); ++i) cal[i] = cal[i ^ (i &amp; -i)] + cnt[__builtin_ctz(i)]; for (int i = 0; i != p; ++i) for (int j = 0; j != p; ++j) &#123; bool check = false; for (int k = 0, l; k != n; ++k) &#123; if (a[k] == j) &#123; if (check) adj[i][j][l] = adj[j][i][l] = true; check = false; &#125; if (a[k] == i) &#123; check = true; l = 0; &#125; if (a[k] != i &amp;&amp; a[k] != j) l |= 1 &lt;&lt; a[k]; &#125; &#125; for (int i = 0; i != p; ++i) for (int j = 0; j != p; ++j) for (int k = 1; k != (1 &lt;&lt; p); ++k) for (int l = 0; l != p; ++l) if (k &amp; 1 &lt;&lt; l) adj[i][j][k] |= adj[i][j][k ^ 1 &lt;&lt; l]; dfs((1 &lt;&lt; p) - 1); cout &lt;&lt; res &lt;&lt; endl;&#125; G. Recursive Queries题目大意给定一个全排列$~p_1,~p_2,~\\dots,~p_n~$，定义 f(l,~r)=\\begin{cases} (r-l+1)+f(l,~m_{lr}-1)+f(m_{lr}+1,~r) &\\text{$l\\leq r$} \\\\ 0 &\\text{$l>r$} \\end{cases}其中$~m_{lr}~$表示$~p_l,~\\dots,~p_r~$中最大值的角标。一共问$~q~$组$~f(l,~r)~$。数据范围$~1\\leq n\\leq10^6,~1\\leq q\\leq10^6~$。 题解定义 fl(l,~r)=(m_{lr}-l)+fl(l,~m_{lr}-1)+fl(m_{lr}+1,~r) \\\\ fr(l,~r)=(r-m_{lr})+fr(l,~m_{lr}-1)+fr(m_{lr}+1,~r)则有 f(l,~r)=(r-l+1)+fl(l,~r)+fr(l,~r)先计算$~fl(l,~r)~$。令 g(i)=\\min\\{j\\mid p_k\\leq p_i,~\\forall~k\\in[j,~i]\\}这一步可以通过单调栈线性处理。此时$~[l,~r]~$中每个点$~i~$作为计算过程中的$~m_{lr}~$时对于$~fl(l,~r)~$的贡献为$~i-\\max(l,~g(i))~$。即 fl(l,~r)=\\sum_{i=l}^{r}i-\\max(l,~g(i))在固定$~r~$的条件下，$~fl(l,~r)~$可以视为关于$~l~$的分段线性函数。将询问离线，然后对右端点$~r~$从小到大扫一遍，每次对当前的分段线性函数增加$~r-\\max(l,~g(r))~$。如何维护分段线性函数？考虑分段线性函数中的斜率$~k~$和截距$~b~$。当$~l&lt; g(r)~$时，可视为$~b~$增加$~r-g(r)~$。反之$~b~$增加$~r~$，而$~k~$减少$~1~$。于是需要一个支持区间修改和单点查询的数据结构，用差分树状数组即可。对于$~fr(l,~r)~$的计算，将所有数据翻转后等价于计算$~fl(l,~r)~$，总时间复杂度为$~O((n+q)\\log n)~$。不推荐使用递归线段树，大常数加上递归复杂度基本会$~\\text{TLE}~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 20;int p[maxn], l[maxn], r[maxn], sta[maxn], sta_size, cal[maxn];long long res[maxn], bit1[maxn], bit2[maxn];vector&lt;int&gt; query[maxn];#define lowbit(x) ((x) &amp; -(x))inline void modify(long long bit[], const int&amp; p, const long long&amp; a) &#123; for (int i = p; i &lt; maxn; i += lowbit(i)) bit[i] += a;&#125;inline long long pre_sum(long long bit[], const int&amp; p) &#123; long long ret = 0; for (int i = p; i; i ^= lowbit(i)) ret += bit[i]; return ret;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; p[i]; for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; l[i]; for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; r[i], query[r[i]].push_back(i); for (int i = 1; i &lt;= n; ++i) &#123; while (sta_size &amp;&amp; p[sta[sta_size]] &lt; p[i]) --sta_size; cal[i] = sta[sta_size] + 1; sta[++sta_size] = i; &#125; for (int i = 1; i &lt;= n; ++i) &#123; modify(bit1, 1, i - cal[i]); modify(bit1, i + 1, -i); modify(bit1, cal[i], cal[i]); modify(bit2, cal[i], 1); modify(bit2, i + 1, -1); for (auto x : query[i]) res[x] += pre_sum(bit1, l[x]) - pre_sum(bit2, l[x]) * l[x]; &#125; reverse(p + 1, p + n + 1); sta_size = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (sta_size &amp;&amp; p[sta[sta_size]] &lt; p[i]) --sta_size; cal[i] = sta[sta_size] + 1; sta[++sta_size] = i; query[i].clear(); &#125; for (int i = 1; i &lt;= m; ++i) &#123; r[i] = n + 1 - r[i]; query[n + 1 - l[i]].push_back(i); &#125; memset(bit1, 0, sizeof (bit1)); memset(bit2, 0, sizeof (bit2)); for (int i = 1; i &lt;= n; ++i) &#123; modify(bit1, 1, i - cal[i]); modify(bit1, i + 1, -i); modify(bit1, cal[i], cal[i]); modify(bit2, cal[i], 1); modify(bit2, i + 1, -1); for (auto x : query[i]) res[x] += pre_sum(bit1, r[x]) - pre_sum(bit2, r[x]) * r[x]; &#125; for (int i = 1; i ^ m; ++i) cout &lt;&lt; res[i] - l[i] - r[i] + n + 2 &lt;&lt; ' '; cout &lt;&lt; res[m] - l[m] - r[m] + n + 2 &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 539 (Div. 2) (TBC)","slug":"Codeforces Round 539 (Div. 2) (TBC)","date":"2019-02-19T14:59:25.560Z","updated":"2019-05-25T13:16:25.633Z","comments":true,"path":"2019/02/19/Codeforces Round 539 (Div. 2) (TBC)/","link":"","permalink":"http://yoursite.com/2019/02/19/Codeforces Round 539 (Div. 2) (TBC)/","excerpt":"","text":"Codeforces Round #539 (Div. 2) A. Sasha and His Trip题目大意水题。 题解水题。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, v; cin &gt;&gt; n &gt;&gt; v; cout &lt;&lt; (n &gt; v ? (n - v + 1) * (n - v) / 2 + v - 1 : n - 1) &lt;&lt; endl;&#125; B. Sasha and Magnetic Machines题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; sort(a.begin(), a.end()); int cal = 0; for (int i = 2; i &lt;= a.back(); ++i) for (int j = n - 1; j; --j) if (a[j] % i == 0) cal = min(cal, (i - 1) * (a.front() - a[j] / i)); cout &lt;&lt; accumulate(a.begin(), a.end(), 0) + cal &lt;&lt; endl;&#125; C. Sasha and a Bit of Relax题目大意给定一个长度为$~n~$的序列，问有多少个偶数长度的连续子序列满足前一半的$~\\text{xor}~$和等于后一半的$~\\text{xor}~$和。数据范围$~2\\leq n\\leq3\\cdot10^5,~0\\leq a&lt; 2^{20}~$。 题解条件其实等价于这个区间的$~\\text{xor}~$和为$~0~$。注意到数据范围，只需要开一个$~cnt~$数组记录前缀$~\\text{xor}~$和，然从前往后扫的过程中更新答案和$~cnt~$即可。时间复杂度为$~O(n)~$，空间复杂度$~O(a)~$。当然用$~\\text{map}~$来储存$~cnt~$也可以，这样的时间复杂度为$~O(n\\log n)~$，空间复杂度为$~O(n)~$。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;int a[maxn], cnt[1 &lt;&lt; 20][2];int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i], ++cnt[a[i] ^= a[i - 1]][i &amp; 1]; long long res = 0; for (int i = 1; i &lt;= n; ++i) &#123; res += cnt[a[i - 1]][i &amp; 1 ^ 1]; --cnt[a[i]][i &amp; 1]; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. Sasha and One More Name题目大意给定一个回文串，需要切$~k~$刀将其拆成$~k+1~$个连续字串，使得存在一种重新组合是个不同于原串的回文串。输出$~k~$的最小值或不存在。数据范围$~1\\leq{\\mid s\\mid}\\leq5000~$。 题解显然如果前$~\\frac{\\mid s\\mid}{2}~$个字符一样，则$~k~$不存在。否则存在一个前缀和后缀，将它们交换后可以得到一个新的回文串，于是$~1\\leq k\\leq2~$。暴力枚举判断即可，时间复杂度为$~O(n^2)~$。但是这题可以进一步优化，如果$~k=1~$，由对称性，不妨设在切在前半段，则所切的那一刀必然得到一个偶数长度的回文前缀的前一半，且剩下的后缀也是回文串（或空串）。运用$~\\text{Manacher}~$算法可以在线性时间内处理出每个中心所对应的最长回文串。那怎么判断这样的做法得到的新串是否和原串不一样呢？最朴素的方式是运用$~\\text{ex-KMP}~$算法。另一种只需要判断切的这一刀的左边，也就是这个回文前缀的的前一半，是否也是个回文串。如果是，则得到的新串必然和原串一样，这个可以自行证明。不论是否运用$~\\text{ex-KMP}~$算法，总时间复杂度均为$~O(n)~$。 代码（$~O(n^2)~$）123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;#define all(o) o.begin(), o.end()int main() &#123; string str; cin &gt;&gt; str; string sub = str.substr(0, str.size() &gt;&gt; 1); if (*max_element(all(sub)) == *min_element(all(sub))) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; bool flag = false; while (!sub.empty()) &#123; string tmp = str.substr(sub.size()) + sub; string pmt = tmp; reverse(all(pmt)); if (tmp == pmt &amp;&amp; str != tmp) return cout &lt;&lt; 1 &lt;&lt; endl, 0; sub.pop_back(); &#125; cout &lt;&lt; 2 &lt;&lt; endl;&#125; 代码（$~O(n)~$）12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e3 + 5;char str[maxn], tmp[maxn &lt;&lt; 1];int len[maxn &lt;&lt; 1];int manacher(char str[], int n, char tmp[], int len[]) &#123; int l = n + 1 &lt;&lt; 1, ret = 1; tmp[0] = '$', tmp[1] = '#'; for (int i = 0; i ^ n; ++i) tmp[i + 1 &lt;&lt; 1] = str[i], tmp[i + 1 &lt;&lt; 1 ^ 1] = '#'; len[1] = 1; for (int i = 2, mid = 1, right = 1; i ^ l; ++i) if ((i &gt; right) | (i + (len[i] = len[(mid &lt;&lt; 1) - i]) &gt; right)) &#123; for (len[mid = i] = 1; tmp[i - len[i]] == tmp[i + len[i]]; ++len[i]); ret = max(ret, len[i] - 1); right = i + len[i] - 1; &#125; return ret;&#125;bool is_palindrome(int left, int right) &#123;return right - left + 2 == len[left + right + 2];&#125;int main() &#123; cin &gt;&gt; str; int n = strlen(str); if (*max_element(str, str + (n &gt;&gt; 1)) == *min_element(str, str + (n &gt;&gt; 1))) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; manacher(str, n, tmp, len); for (int i = 0; i ^ n &gt;&gt; 1; ++i) if (!is_palindrome(0, i) &amp;&amp; is_palindrome(0, i &lt;&lt; 1 ^ 1) &amp;&amp; is_palindrome(i + 1 &lt;&lt; 1, n - 1)) return cout &lt;&lt; 1 &lt;&lt; endl, 0; cout &lt;&lt; 2 &lt;&lt; endl;&#125; F. Sasha and Interesting Fact from Graph Theory题目大意多少棵节点编号为$~1,~2,~\\dots,~n~$，边权范围为$~[1,~m]~$的树，满足连接$~a~$与$~b~$的简单路径的边权之和为$~m~$。数据范围$~2\\leq n\\leq10^6,~1\\leq m\\leq10^6~$。 题解有编号生成树计数问题离不开$~\\text{Pru2fer}~$序列。一棵大小为$~n~$的无根树的$~\\text{Pru2fer}~$序列定义为：每次删去编号最小的叶节点并记录唯一与之相邻的编号，直到还剩$~2~$个点所构成的长度为$~n-2~$的序列。容易证明不同无根树的$~\\text{Pru2fer}~$序列一定不同。相反的对于每个长度为$~n-2~$数据范围为$~[1,~n]~$的序列，可以唯一构造出一无根棵树，过程自行思考。于是得到了一个$~n~$阶完全图的无根生成树与$~\\text{Pru2fer}~$序列的双射。所以$~n~$阶完全图的无根生成树个数为$~n^{n-2}~$，这也就是$~\\text{Cayley}~$公式。显然$~a~$和$~b~$的值并不影响答案。暴力枚举连接$~a~$与$~b~$的简单路径上的点的个数$~x\\in[2,~\\min(n,~m+1)]~$。先考虑边权部分，对于路径上$~x-1~$条边的边权，这是个很普通的组合数学问题，答案为$~\\binom{m-1}{x-1}~$。对于路径外$~n-x~$条边的边权，没有任何限制，答案为$~m^{n-x}~$。对于路径上的点的组合，答案为$~A_{n-2}^{x-2}=\\frac{(n-2)!}{(n-x)!}~$。现在问题剩下的部分等价于给定一条$~x~$点的路径的生成树计数问题。不妨设这些点为$~n,~n-1,~\\dots,~n-x+1~$。那么这棵树的的$~\\text{Pru2fer}~$序列的后$~x-2~$项必为$~n-x+2,~n-x+3,~\\dots,~n~$，且倒数第$~x-1~$项必然在$~[n-x+1,~n]~$之中。有了这些限制，合法的$~\\text{Pru2fer}~$序列数量为$~x\\cdot n^{n-x-1}~$，也就是对应生成树的数量。最终答案公式为 \\sum_{x=2}^{\\min(n,~m+1)}\\frac{x\\cdot(n-2)!}{n\\cdot(n-x)!}(nm)^{n-x}\\binom{m-1}{x-1}如果线性预处理完所有数组，时间复杂度可优化至$~O(n+m)~$。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;const int maxn = 1 &lt;&lt; 20;int inv[maxn], fact[maxn], finv[maxn], pownm[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int mul(const int&amp; a, const int&amp; b, const int&amp; c) &#123;return mul(mul(a, b), c);&#125;inline int mul(const int&amp; a, const int&amp; b, const int&amp; c, const int&amp; d) &#123;return mul(mul(a, b), mul(c, d));&#125;inline int bino(const int&amp; a, const int&amp; b) &#123;return mul(fact[a], finv[b], finv[a - b]);&#125;inline void init(int n = maxn) &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ n; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125;&#125;int main() &#123; init(); int n, m, a, b; cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b; pownm[0] = 1; pownm[1] = mul(n, m); int nm = mul(n, m); for (int i = 1; i ^ maxn; ++i) pownm[i] = mul(pownm[i - 1], nm); int res = 0; for (int x = 2; x &lt;= min(n, m + 1); ++x) res = add(res, mul(mul(pownm[n - x], x, inv[n], bino(m - 1, x - 2)), fact[n - 2], finv[n - x])); cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 539 (Div. 1) (TBC)","slug":"Codeforces Round 539 (Div. 1) (TBC)","date":"2019-02-18T15:01:19.237Z","updated":"2019-05-25T13:16:21.425Z","comments":true,"path":"2019/02/18/Codeforces Round 539 (Div. 1) (TBC)/","link":"","permalink":"http://yoursite.com/2019/02/18/Codeforces Round 539 (Div. 1) (TBC)/","excerpt":"","text":"Codeforces Round #539 (Div. 1) A. Sasha and a Bit of Relax题目大意给定一个长度为$~n~$的序列，问有多少个偶数长度的连续子序列满足前一半的$~\\text{xor}~$和等于后一半的$~\\text{xor}~$和。数据范围$~2\\leq n\\leq3\\cdot10^5,~0\\leq a&lt; 2^{20}~$。 题解条件其实等价于这个区间的$~\\text{xor}~$和为$~0~$。注意到数据范围，只需要开一个$~cnt~$数组记录前缀$~\\text{xor}~$和，然从前往后扫的过程中更新答案和$~cnt~$即可。时间复杂度为$~O(n)~$，空间复杂度$~O(a)~$。当然用$~\\text{map}~$来储存$~cnt~$也可以，这样的时间复杂度为$~O(n\\log n)~$，空间复杂度为$~O(n)~$。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;int a[maxn], cnt[1 &lt;&lt; 20][2];int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i], ++cnt[a[i] ^= a[i - 1]][i &amp; 1]; long long res = 0; for (int i = 1; i &lt;= n; ++i) &#123; res += cnt[a[i - 1]][i &amp; 1 ^ 1]; --cnt[a[i]][i &amp; 1]; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; B. Sasha and One More Name题目大意给定一个回文串，需要切$~k~$刀将其拆成$~k+1~$个连续字串，使得存在一种重新组合是个不同于原串的回文串。输出$~k~$的最小值或不存在。数据范围$~1\\leq{\\mid s\\mid}\\leq5000~$。 题解显然如果前$~\\frac{\\mid s\\mid}{2}~$个字符一样，则$~k~$不存在。否则存在一个前缀和后缀，将它们交换后可以得到一个新的回文串，于是$~1\\leq k\\leq2~$。暴力枚举判断即可，时间复杂度为$~O(n^2)~$。但是这题可以进一步优化，如果$~k=1~$，由对称性，不妨设在切在前半段，则所切的那一刀必然得到一个偶数长度的回文前缀的前一半，且剩下的后缀也是回文串（或空串）。运用$~\\text{Manacher}~$算法可以在线性时间内处理出每个中心所对应的最长回文串。那怎么判断这样的做法得到的新串是否和原串不一样呢？最朴素的方式是运用$~\\text{ex-KMP}~$算法。另一种只需要判断切的这一刀的左边，也就是这个回文前缀的的前一半，是否也是个回文串。如果是，则得到的新串必然和原串一样，这个可以自行证明。不论是否运用$~\\text{ex-KMP}~$算法，总时间复杂度均为$~O(n)~$。 代码（$~O(n^2)~$）123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;#define all(o) o.begin(), o.end()int main() &#123; string str; cin &gt;&gt; str; string sub = str.substr(0, str.size() &gt;&gt; 1); if (*max_element(all(sub)) == *min_element(all(sub))) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; bool flag = false; while (!sub.empty()) &#123; string tmp = str.substr(sub.size()) + sub; string pmt = tmp; reverse(all(pmt)); if (tmp == pmt &amp;&amp; str != tmp) return cout &lt;&lt; 1 &lt;&lt; endl, 0; sub.pop_back(); &#125; cout &lt;&lt; 2 &lt;&lt; endl;&#125; 代码（$~O(n)~$）12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e3 + 5;char str[maxn], tmp[maxn &lt;&lt; 1];int len[maxn &lt;&lt; 1];int manacher(char str[], int n, char tmp[], int len[]) &#123; int l = n + 1 &lt;&lt; 1, ret = 1; tmp[0] = '$', tmp[1] = '#'; for (int i = 0; i ^ n; ++i) tmp[i + 1 &lt;&lt; 1] = str[i], tmp[i + 1 &lt;&lt; 1 ^ 1] = '#'; len[1] = 1; for (int i = 2, mid = 1, right = 1; i ^ l; ++i) if ((i &gt; right) | (i + (len[i] = len[(mid &lt;&lt; 1) - i]) &gt; right)) &#123; for (len[mid = i] = 1; tmp[i - len[i]] == tmp[i + len[i]]; ++len[i]); ret = max(ret, len[i] - 1); right = i + len[i] - 1; &#125; return ret;&#125;bool is_palindrome(int left, int right) &#123;return right - left + 2 == len[left + right + 2];&#125;int main() &#123; cin &gt;&gt; str; int n = strlen(str); if (*max_element(str, str + (n &gt;&gt; 1)) == *min_element(str, str + (n &gt;&gt; 1))) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; manacher(str, n, tmp, len); for (int i = 0; i ^ n &gt;&gt; 1; ++i) if (!is_palindrome(0, i) &amp;&amp; is_palindrome(0, i &lt;&lt; 1 ^ 1) &amp;&amp; is_palindrome(i + 1 &lt;&lt; 1, n - 1)) return cout &lt;&lt; 1 &lt;&lt; endl, 0; cout &lt;&lt; 2 &lt;&lt; endl;&#125; D. Sasha and Interesting Fact from Graph Theory题目大意多少棵节点编号为$~1,~2,~\\dots,~n~$，边权范围为$~[1,~m]~$的树，满足连接$~a~$与$~b~$的简单路径的边权之和为$~m~$。数据范围$~2\\leq n\\leq10^6,~1\\leq m\\leq10^6~$。 题解有编号生成树计数问题离不开$~\\text{Pru2fer}~$序列。一棵大小为$~n~$的无根树的$~\\text{Pru2fer}~$序列定义为：每次删去编号最小的叶节点并记录唯一与之相邻的编号，直到还剩$~2~$个点所构成的长度为$~n-2~$的序列。容易证明不同无根树的$~\\text{Pru2fer}~$序列一定不同。相反的对于每个长度为$~n-2~$数据范围为$~[1,~n]~$的序列，可以唯一构造出一无根棵树，过程自行思考。于是得到了一个$~n~$阶完全图的无根生成树与$~\\text{Pru2fer}~$序列的双射。所以$~n~$阶完全图的无根生成树个数为$~n^{n-2}~$，这也就是$~\\text{Cayley}~$公式。显然$~a~$和$~b~$的值并不影响答案。暴力枚举连接$~a~$与$~b~$的简单路径上的点的个数$~x\\in[2,~\\min(n,~m+1)]~$。先考虑边权部分，对于路径上$~x-1~$条边的边权，这是个很普通的组合数学问题，答案为$~\\binom{m-1}{x-1}~$。对于路径外$~n-x~$条边的边权，没有任何限制，答案为$~m^{n-x}~$。对于路径上的点的组合，答案为$~A_{n-2}^{x-2}=\\frac{(n-2)!}{(n-x)!}~$。现在问题剩下的部分等价于给定一条$~x~$点的路径的生成树计数问题。不妨设这些点为$~n,~n-1,~\\dots,~n-x+1~$。那么这棵树的的$~\\text{Pru2fer}~$序列的后$~x-2~$项必为$~n-x+2,~n-x+3,~\\dots,~n~$，且倒数第$~x-1~$项必然在$~[n-x+1,~n]~$之中。有了这些限制，合法的$~\\text{Pru2fer}~$序列数量为$~x\\cdot n^{n-x-1}~$，也就是对应生成树的数量。最终答案公式为 \\sum_{x=2}^{\\min(n,~m+1)}\\frac{x\\cdot(n-2)!}{n\\cdot(n-x)!}(nm)^{n-x}\\binom{m-1}{x-1}如果线性预处理完所有数组，时间复杂度可优化至$~O(n+m)~$。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;const int maxn = 1 &lt;&lt; 20;int inv[maxn], fact[maxn], finv[maxn], pownm[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int mul(const int&amp; a, const int&amp; b, const int&amp; c) &#123;return mul(mul(a, b), c);&#125;inline int mul(const int&amp; a, const int&amp; b, const int&amp; c, const int&amp; d) &#123;return mul(mul(a, b), mul(c, d));&#125;inline int bino(const int&amp; a, const int&amp; b) &#123;return mul(fact[a], finv[b], finv[a - b]);&#125;inline void init(int n = maxn) &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ n; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125;&#125;int main() &#123; init(); int n, m, a, b; cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b; pownm[0] = 1; pownm[1] = mul(n, m); int nm = mul(n, m); for (int i = 1; i ^ maxn; ++i) pownm[i] = mul(pownm[i - 1], nm); int res = 0; for (int x = 2; x &lt;= min(n, m + 1); ++x) res = add(res, mul(mul(pownm[n - x], x, inv[n], bino(m - 1, x - 2)), fact[n - 2], finv[n - x])); cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 533 (Div. 2)","slug":"Codeforces Round 533 (Div. 2)","date":"2019-02-17T15:28:40.484Z","updated":"2019-02-17T17:28:11.095Z","comments":true,"path":"2019/02/17/Codeforces Round 533 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/02/17/Codeforces Round 533 (Div. 2)/","excerpt":"","text":"Codeforces Round #533 (Div. 2) A. Salem and Sticks题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; int t = 0, cost = 0x7fffffff; for (int i = 1; i &lt;= 100; ++i) &#123; int now = 0; for (auto aa : a) now += max(abs(aa - i) - 1, 0); if (now &lt; cost) t = i, cost = now; &#125; cout &lt;&lt; t &lt;&lt; ' ' &lt;&lt; cost &lt;&lt; endl;&#125; B. Zuhair and Strings题目大意水题。 题解水题。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, k; string str; cin &gt;&gt; n &gt;&gt; k &gt;&gt; str; vector&lt;int&gt; cnt(128, 0), cal(128, 0); if (++cnt[str.front()] == k) ++cal[str.front()], --cnt[str.front()]; for (int i = 1; i ^ n; ++i) &#123; if (str[i] ^ str[i - 1]) cnt[str[i]] = 1; else ++cnt[str[i]]; if (cnt[str[i]] == k) ++cal[str[i]], cnt[str[i]] = 0; &#125; int res = 0; for (int i = 'a'; i &lt;= 'z'; ++i) res = max(res, cal[i]); cout &lt;&lt; res &lt;&lt; endl;&#125; C. Ayoub and Lost Array题目大意问有多少个长度为$~n~$且取值为$~[l,~r]~$的序列满足总和是$~3~$的倍数。数据范围$~1\\leq n\\leq2\\cdot10^5,~1\\leq l\\leq r\\leq10^9~$。 题解动态规划。递推出到每一位上满足总和模$~3~$的余数为$~0,~1,~2~$的序列分别由多少个。这个过程可以用矩阵快速幂优化，总时间复杂度为$~O(\\log n)~$。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;inline void mul(int C[][3], int A[][3], int B[][3]) &#123; for (int i = 0; i ^ 3; ++i) for (int j = 0; j ^ 3; ++j) &#123; C[i][j] = 0; for (int k = 0; k ^ 3; ++k) C[i][j] = add(C[i][j], mul(A[i][k], B[k][j])); &#125;&#125;int main() &#123; init(); int n, l, r; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; int dp[3]; for (int i = 0; i ^ 3; ++i) dp[i] = (r - i + 3) / 3 - (l - i + 2) / 3; int base[3][3] = &#123;&#123;dp[0], dp[2], dp[1]&#125;, &#123;dp[1], dp[0], dp[2]&#125;, &#123;dp[2], dp[1], dp[0]&#125;&#125;; int mat[3][3] = &#123;0&#125;, tmp[3][3]; for (int i = 0; i ^ 3; ++i) mat[i][i] = 1; while (n) &#123; if (n &amp; 1) &#123; mul(tmp, mat, base); memcpy(mat, tmp, sizeof (tmp)); &#125; mul(tmp, base, base); memcpy(base, tmp, sizeof (tmp)); n &gt;&gt;= 1; &#125; cout &lt;&lt; mat[0][0] &lt;&lt; endl;&#125; D. Kilani and the Game题目大意给定一个$~n\\times m~$的网格图和$~p~$种颜色的初始位置以及扩散速度$~s~$。每回合每种颜色可以按曼哈顿距离扩散至空白处。问最终每种颜色的大小。数据范围$~1\\leq m\\leq1000,~1\\leq m\\leq1000,~1\\leq p\\leq9,~1\\leq s\\leq10^9~$。 题解裸$~\\text{BFS}~$，具体实现见代码。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;#define mp make_pair#define ff first#define ss secondint main () &#123; int n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; vector&lt;int&gt; speed(p), res(p, 0); vector&lt;queue&lt;pii&gt;&gt; que(p); for (auto&amp; s : speed) cin &gt;&gt; s; vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(m, false)); for (int i = 0; i ^ n; ++i) for (int j = 0; j ^ m; ++j) &#123; char ch; cin &gt;&gt; ch; if (ch ^ '.') &#123; vis[i][j] = true; if (ch ^ '#') &#123; ++res[ch - '1']; que[ch - '1'].push(mp(i, j)); &#125; &#125; &#125; vector&lt;pii&gt; v(4); v[0] = mp(-1, 0); v[1] = mp(1, 0); v[2] = mp(0, -1); v[3] = mp(0, 1); bool flag = true; while (flag) &#123; flag = false; for (int i = 0; i ^ p; ++i) for (int j = 0; j ^ speed[i]; ++j) &#123; if (que[i].empty()) break; flag = true; queue&lt;pii&gt; tmp; while (!que[i].empty()) &#123; for (auto d : v) &#123; int x = que[i].front().ff + d.ff; int y = que[i].front().ss + d.ss; if (!~x || !~y || x == n || y == m || vis[x][y]) continue; vis[x][y] = true; ++res[i]; tmp.push(mp(x, y)); &#125; que[i].pop(); &#125; que[i] = tmp; &#125; &#125; for (int i = 0; i ^ p - 1; ++i) cout &lt;&lt; res[i] &lt;&lt; ' '; cout &lt;&lt; res.back() &lt;&lt; endl;&#125; E. Helping Hiasat题目大意有$~m~$个字符串，现给出若干个字符串集合，要求选出最多的字符串使得每个集合里至多选一个。数据范围$~1\\leq n\\leq10^5,~1\\leq m\\leq40,~1\\leq{\\mid s\\mid}\\leq40~$。 题解显然可以通过$~\\text{map}~$之类的手段化为一个图上最大独立集的问题。而它的补图是个最大团问题。用$~\\text{Bron-Kerbosch}~$算法可以在$~O(3^\\frac{m}{3})~$的时间复杂度内解决。总时间复杂度为$~O(n\\log\\mid s\\mid+3^\\frac{m}{3})~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;#define count1_64 __builtin_popcountll#define low0_64 __builtin_ctzllconst int maxn = 40;ull adj[maxn];int res;void bk(ull cur, ull allow, ull forbid) &#123; if (!allow) &#123; if (!forbid) res = max(res, count1_64(cur)); return; &#125; ull tmp = allow &amp; ~adj[low0_64(allow | forbid)]; for (int i = 0; i ^ maxn; ++i) if (1ULL &lt;&lt; i &amp; tmp) &#123; bk(cur ^ 1ULL &lt;&lt; i, allow &amp; adj[i], forbid &amp; adj[i]); allow ^= 1ULL &lt;&lt; i; forbid ^= 1ULL &lt;&lt; i; &#125;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; map&lt;string, int&gt; id; ull now = 0; int id_ = 0; while (n--) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; for (int i = 0; i ^ maxn; ++i) if (now &amp; 1ULL &lt;&lt; i) adj[i] |= now; now = 0; &#125; else &#123; string str; cin &gt;&gt; str; if (id.find(str) == id.end()) id[str] = id_++; now |= 1ULL &lt;&lt; id[str]; &#125; &#125; for (int i = 0; i ^ maxn; ++i) &#123; if (now &amp; 1ULL &lt;&lt; i) adj[i] |= now; adj[i] ^= (1ULL &lt;&lt; m) - 1; &#125; bk(0, (1ULL &lt;&lt; maxn) - 1, 0); cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"2019 Wannafly Winter Camp Day1 Div1","slug":"2019 Wannafly Winter Camp Day1 Div1","date":"2019-02-16T14:43:44.646Z","updated":"2019-02-16T14:46:50.403Z","comments":true,"path":"2019/02/16/2019 Wannafly Winter Camp Day1 Div1/","link":"","permalink":"http://yoursite.com/2019/02/16/2019 Wannafly Winter Camp Day1 Div1/","excerpt":"","text":"A. 机器人题目大意水题。 题解水题。注意特殊情况讨论。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, r, m, k, s; cin &gt;&gt; n &gt;&gt; r &gt;&gt; m &gt;&gt; k &gt;&gt; s; int left[2] = &#123;n, n&#125;, right[2] = &#123;0&#125;; while (r--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; left[y] = min(left[y], x); right[y] = max(right[y], x); &#125; vector&lt;bool&gt; flag(n + 1, false); flag[1] = flag[n] = true; while (m--) &#123; int pos; cin &gt;&gt; pos; flag[pos] = true; &#125; int ll = min(left[0], left[1]), rr = max(right[0], right[1]); int lll = ll, rrr = rr; while (!flag[lll]) --lll; while (!flag[rrr]) ++rrr; int res; if (right[1]) &#123; res = k; if (s &lt; ll) &#123; lll = left[1]; while (!flag[lll]) --lll; res += rrr - min(s, lll); &#125; else if (s &gt; rr) &#123; rrr = right[1]; while (!flag[rrr]) ++rrr; res += max(s, rrr) - lll; &#125; else &#123; res += rrr - lll; &#125; &#125; else &#123; if (s &lt; ll) res = rrr - s; else if (s &gt; rr) res = s - lll; else if (ll == rr) res = 0; else res = rrr - lll; &#125; cout &lt;&lt; (res &lt;&lt; 1) &lt;&lt; endl;&#125; B. 吃豆豆题目大意在$~n\\times m~$的网格图上，对于格子$~(i,~j)~$，在$~T[i][j]~$的整数倍秒时会由糖果在上面。现给定起点和终点，每秒可以选择上下左右或者不动，然后可以取走当前格子上的糖果，如果存在的话。问要获得$~C~$个糖果的最短时间。数据范围$~1\\leq n\\leq10,~1\\leq m\\le10,~1\\leq T\\leq10,~1\\leq C\\leq10^{18}~$。 题解动态规划，记录$~dp[i][j][k]~$表示第$~0~$秒在$~j~$点，第$~i~$秒在$~k~$点最多能得到多少颗糖果，这里$~j~$和$~k~$的范围是$~[0,~nm)~$。枚举$~i~$到$~\\gcd(1,~2,~\\dots,~10)=2520~$即可，因为第$~2520x~$秒在$~j~$点$~2520x+i~$秒在$~k~$点最多能得到的糖果数也为$~dp[i][j][k]~$。这里我们可以将$~dp[i]~$看作一个$~nm\\times nm~$的矩阵，将正常的矩阵乘法中的数值乘法变为加法，数值乘法变为取$~\\max~$。于是对于从$~0~$秒到第$~2520x~$秒的最多糖果矩阵，即为$~dp[2520]^x~$。由于可以原地不动，所以从$~(xs,~ys)~$到$~(xt,~yt)~$经过$~t~$秒所能得到的最多糖果数是单调递增的。用带余除法分解$~t=2520x+y~$，于是通过倍增可以求出$~x~$，然后二分$~y~$可以算出最小的$~t~$值。总时间复杂度为$~O(12600n^4+n^6\\log C)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int STEP = 2520;const int mat_size = 10000 * sizeof (__int128);int T[100];__int128 dp0[100][100], dp1[100][100], dp[STEP + 1][100], mat[64][100][100], now[100][100], tmp[100][100], cal[100];inline void update(__int128&amp; x, const __int128&amp; y) &#123;x &lt; y ? (x = y) : 0;&#125;inline void mul(__int128 C[][100], __int128 A[][100], __int128 B[][100], int size) &#123; for (int i = 0; i ^ size; ++i) for (int j = 0; j ^ size; ++j) &#123; C[i][j] = -1; for (int k = 0; k ^ size; ++k) if (~A[i][k] &amp;&amp; ~B[k][j]) update(C[i][j], A[i][k] + B[k][j]); &#125;&#125;inline void mul(__int128 C[], __int128 A[][100], __int128 B[], int size) &#123; for (int i = 0; i ^ size; ++i) &#123; C[i] = -1; for (int j = 0; j ^ size; ++j) if (~A[i][j] &amp;&amp; ~B[j]) update(C[i], A[i][j] + B[j]); &#125;&#125;void cout128(__int128 x) &#123; if (x &gt; 9) cout128(x / 10); cout &lt;&lt; int(x % 10);&#125;int main() &#123; int n, m; long long C; cin &gt;&gt; n &gt;&gt; m &gt;&gt; C; int size = n * m; for (int i = 0; i ^ size; ++i) cin &gt;&gt; T[i]; int xss, yss, xtt, ytt; cin &gt;&gt; xss &gt;&gt; yss &gt;&gt; xtt &gt;&gt; ytt; int ss = xss * m + yss - m - 1, tt = xtt * m + ytt - m - 1; for (int i = 0; i ^ 100; ++i) for (int j = 0; j ^ 100; ++j) if (i ^ j) dp0[i][j] = -1; for (int step = 1; step &lt;= STEP; ++step) &#123; for (int xs = 0; xs ^ n; ++xs) for (int ys = 0; ys ^ m; ++ys) &#123; int s = xs * m + ys; for (int xt = 0; xt ^ n; ++xt) for (int yt = 0; yt ^ m; ++yt) &#123; int t = xt * m + yt; dp1[s][t] = dp0[s][t]; if (xt) update(dp1[s][t], dp0[s][t - m]); if (yt) update(dp1[s][t], dp0[s][t - 1]); if (xt ^ n - 1) update(dp1[s][t], dp0[s][t + m]); if (yt ^ m - 1) update(dp1[s][t], dp0[s][t + 1]); if (~dp1[s][t]) dp1[s][t] += !(step % T[t]); &#125; dp[step][s] = dp1[s][tt]; &#125; memcpy(dp0, dp1, sizeof (dp0)); &#125; for (int i = 1; i &lt;= STEP; ++i) if (dp[i][ss] &gt;= C) return cout &lt;&lt; i &lt;&lt; endl, 0; memcpy(mat[0], dp0, mat_size); for (int i = 1; i ^ 64; ++i) mul(mat[i], mat[i - 1], mat[i - 1], size); int up = 63; while (mat[up][ss][tt] &gt;= C) --up; memcpy(now, mat[up], mat_size); __int128 X = 1LL &lt;&lt; up; for (int k = up - 1; ~k; --k) &#123; mul(tmp, now, mat[k], size); if (tmp[ss][tt] &lt; C) &#123; X ^= 1LL &lt;&lt; k; memcpy(now, tmp, mat_size); &#125; &#125; int l = 0, r = STEP; while (r - l ^ 1) &#123; int mid = l + r &gt;&gt; 1; mul(cal, now, dp[mid], size); if (cal[ss] &lt; C) l = mid; else r = mid; &#125; cout128(STEP * X + r); cout &lt;&lt; endl;&#125; C. 拆拆拆数题目大意将$~A~$和$~B~$分别拆成尽量小的$~n~$组，然后组成$~n~$对，使得每对互质。 题解首先猜想$~n\\leq 2~$，下面通过奇偶性对于$~\\gcd(A,~B)&gt;1~$的情况考虑构造。如果$~2\\nmid A,~2\\nmid B~$，则拆成$~(2,~A-2),~(B-2,~2)~$是显然满足题意的。剩下的情况不妨设$~2\\mid A~$，则$~(3,~A-3),~(B-2,~2)~$和$~(3,~A-3),~(B-4,~4)~$中必有一组是全部互质的。此时只有$~B=5~$的时候会产生非法情况。此时拆成$~(5,~A-5),~(3,~2)~$即可。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; long long A, B; cin &gt;&gt; A &gt;&gt; B; if (__gcd(A, B) == 1) &#123; cout &lt;&lt; 1 &lt;&lt; '\\n' &lt;&lt; A &lt;&lt; ' ' &lt;&lt; B &lt;&lt; '\\n'; continue; &#125; cout &lt;&lt; 2 &lt;&lt; '\\n'; if (A &amp; B &amp; 1) &#123; cout &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; B - 2 &lt;&lt; '\\n' &lt;&lt; A - 2 &lt;&lt; ' ' &lt;&lt; 2 &lt;&lt; '\\n'; &#125; else if (A &amp; 1) &#123; if (A == 5) cout &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; B - 5 &lt;&lt; '\\n' &lt;&lt; 3 &lt;&lt; ' ' &lt;&lt; 5 &lt;&lt; '\\n'; else if (A % 3 != 2) cout &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; B - 3 &lt;&lt; '\\n' &lt;&lt; A - 2 &lt;&lt; ' ' &lt;&lt; 3 &lt;&lt; '\\n'; else cout &lt;&lt; 4 &lt;&lt; ' ' &lt;&lt; B - 3 &lt;&lt; '\\n' &lt;&lt; A - 4 &lt;&lt; ' ' &lt;&lt; 3 &lt;&lt; '\\n'; &#125; else &#123; if (B == 5) cout &lt;&lt; A - 5 &lt;&lt; ' ' &lt;&lt; 2 &lt;&lt; '\\n' &lt;&lt; 5 &lt;&lt; ' ' &lt;&lt; 3 &lt;&lt; '\\n'; else if (B % 3 != 2) cout &lt;&lt; A - 3 &lt;&lt; ' ' &lt;&lt; 2 &lt;&lt; '\\n' &lt;&lt; 3 &lt;&lt; ' ' &lt;&lt; B - 2 &lt;&lt; '\\n'; else cout &lt;&lt; A - 3 &lt;&lt; ' ' &lt;&lt; 4 &lt;&lt; '\\n' &lt;&lt; 3 &lt;&lt; ' ' &lt;&lt; B - 4 &lt;&lt; '\\n'; &#125; &#125;&#125; D. 超难的数学题题目大意定义一个十进制数是好的，当且仅当它的十进制表示下存在$~3~$个连续的数字满足中间的严格大于两边的。现要求求出最小的$~n~$满足$~1,~2,~\\dots,~n~$中好数的比例不小于给定的比例$~p~$。 题解设$~f(n)~$为$~[1,~n]~$中好数的个数，则下面想办法构造一个序列$~a~$逼近正确答案。先令$~a_0=122~$为满足$~f=0~$的最大正整数,于是必有$~\\frac{f(a_0)}{a_0}&lt; p~$。若$~\\frac{f(a_i)}{a_i}&lt; p~$，那么考虑如何将$~a_i~$放大为$~a_{i+1}~$来逼近正确答案。为了不超过正确答案，假设$~(a_i,~a_{i+1}]~$内全是好数，那么必有$~\\frac{f(a_i)+a_{i+1}-a_i-1}{a_{i+1}-1}&lt; p~$。同时为了更快的逼近正确答案，有$~\\frac{f(a_i)+a_{i+1}-a_i}{a_{i+1}}\\geq p~$，于是有 a_{i+1}=\\left\\lceil\\frac{a_i-f(a_i)}{1-p}\\right\\rceil若$~\\frac{f(a_i)}{a_i}\\geq p~$，则代表此时已经求出答案$~a_i~$。由于$~a~$是严格单增的，在确保有界的情况下，一定存在$~a_i~$为正解。这个序列的逼近速度取决于$~f~$的分布密度和$~p~$的大小，但是过程是类似于牛顿迭代的思想，所以复杂度可以视为大常数$~C~$。下面计算$~f~$，数位$~\\text{DP}~$即可。记录$~dp[i][j][0/1]~$表示考虑到第$~i~$位还没有达成好数条件且当前是$~j~$左边有$~0/1~$个数字比$~j~$小的情况数量。这里要用到大整数高精度，在$~100~$位以内就能得出答案。总时间复杂度为$~O(100\\cdot10^2\\cdot C\\cdot\\text{BigInteger})~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.io.*;import java.util.*;import java.math.*;public class Main &#123; static BigInteger[] pow10 = new BigInteger[100]; static BigInteger[][][] dp = new BigInteger[100][10][2]; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); double p = in.nextDouble(); BigInteger hunredThousand = new BigInteger(\"100000\"); int pp = (int)(p * 100000 + 0.1); BigInteger ppp = new BigInteger(Integer.toString(pp)); BigInteger a = new BigInteger(\"122\"); initDP(); while (true) &#123; BigInteger f = func(a); if (f.multiply(hunredThousand).compareTo(a.multiply(ppp)) != -1) break; a = a.subtract(f).multiply(hunredThousand).subtract(BigInteger.ONE).divide(hunredThousand.subtract(ppp)).add(BigInteger.ONE); &#125; System.out.println(a.toString()); &#125; static void initDP() &#123; pow10[0] = BigInteger.ONE; pow10[1] = new BigInteger(\"10\"); for (int i = 2; i != 100; ++i) &#123; pow10[i] = pow10[i - 1].multiply(pow10[1]); &#125; &#125; static BigInteger func(BigInteger n) &#123; String str = n.toString(); int size = str.length(); for (int i = 0; i != size; ++i) &#123; for (int j = 0; j != 10; ++j) &#123; for (int k = 0; k != 2; ++k) &#123; dp[i][j][k] = BigInteger.ZERO; &#125; &#125; &#125; BigInteger ret = BigInteger.ZERO; int count = 1; int last = (int)(str.charAt(0) - '0'); for (int i = 1; i != last; ++i) &#123; dp[0][i][0] = dp[0][i][0].add(BigInteger.ONE); &#125; boolean flag = true; for (int i = 1; i != size; ++i) &#123; if (flag) &#123; int now = (int)(str.charAt(i) - '0'); for (int j = 0; j != now; ++j) &#123; if (j &gt; last) &#123; if (count == 1) &#123; dp[i][j][1] = dp[i][j][1].add(BigInteger.ONE); &#125; else &#123; ret = ret.add(pow10[size - i - 1]); &#125; &#125; else &#123; dp[i][j][0] = dp[i][j][0].add(BigInteger.ONE); &#125; &#125; if (now &gt; last) &#123; ++count; &#125; else &#123; count = 1; &#125; if (count == 3) &#123; ret = ret.add(BigInteger.ONE); if (i + 1 != size) &#123; ret = ret.add(new BigInteger(str.substring(i + 1, size))); &#125; flag = false; &#125; last = now; &#125; for (int j = 0; j != 10; ++j) &#123; if (j != 0) &#123; dp[i][j][0] = dp[i][j][0].add(BigInteger.ONE); &#125; for (int k = 0; k != j; ++k) &#123; dp[i][j][1] = dp[i][j][1].add(dp[i - 1][k][0]); ret = ret.add(dp[i - 1][k][1].multiply(pow10[size - i - 1])); &#125; for (int k = j; k != 10; ++k) &#123; dp[i][j][0] = dp[i][j][0].add(dp[i - 1][k][0]).add(dp[i - 1][k][1]); &#125; &#125; &#125; return ret; &#125;&#125; E. 流流流动题目大意当$~i\\not=1~$且是奇数时，与$~3i+1~$连一条边。偶数时与$~\\frac{i}{2}~$连一条边。取点可以得到$~f[i]~$的收益，但是如果一条边的两个端点$~x~$和$~y~$都取了，则会失去$~d[\\min(x,~y)]~$。问最大收益。 题解根据角谷猜想，图一定是一个森林，于是树形$~01\\text{DP}~$即可。时间复杂度为$~O(n)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; adj[101];inline void add(const int&amp; u, const int&amp; v, const int&amp; w) &#123;adj[u].push_back(make_pair(v, w));&#125;inline void biadd(const int&amp; u, const int&amp; v, const int&amp; w) &#123;add(u, v, w); add(v, u, w);&#125;bool vis[101];int f[101], d[101], dp[101][2];void dfs(int u) &#123; vis[u] = true; dp[u][1] = f[u]; for (auto v : adj[u]) if (!vis[v.first]) &#123; dfs(v.first); dp[u][0] += max(dp[v.first][0], dp[v.first][1]); dp[u][1] += max(dp[v.first][0], dp[v.first][1] - v.second); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; f[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; d[i]; for (int i = 2; i &lt;= n; ++i) &#123; if (i &amp; 1 &amp;&amp; i * 3 + 1 &lt;= n) biadd(i, i * 3 + 1, d[i]); if (!(i &amp; 1)) biadd(i, i &gt;&gt; 1, d[i &gt;&gt; 1]); &#125; int res = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; dfs(i); res += max(dp[i][0], dp[i][1]); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; F.爬爬爬山题目大意问带点权边权的单源最短路。 题解堆优化的带点权的$~\\text{Dijkstra}~$单源最短路，时间复杂度为$~O(m\\log m)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; long long k, h; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; h; vector&lt;long long&gt; cost(n + 1, 0); k += h; for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; h; if (h &gt; k) cost[i] = (h - k) * (h - k); &#125; vector&lt;vector&lt;pair&lt;int, long long&gt;&gt;&gt; adj(n + 1, vector&lt;pair&lt;int, long long&gt;&gt;(0)); while (m--) &#123; int x, y; long long z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; adj[x].push_back(make_pair(y, z)); adj[y].push_back(make_pair(x, z)); &#125; vector&lt;bool&gt; vis(n + 1, false); vector&lt;long long&gt; res(n + 1); priority_queue&lt;pair&lt;long long, int&gt;, vector&lt;pair&lt;long long, int&gt;&gt;, greater&lt;pair&lt;long long, int&gt;&gt;&gt; que; que.push(make_pair(cost[1], 1)); while (true) &#123; auto now = que.top(); que.pop(); if (vis[now.second]) continue; vis[now.second] = true; res[now.second] = now.first; if (now.second == n) break; for (auto next : adj[now.second]) que.push(make_pair(now.first + next.second + cost[next.first], next.first)); &#125; cout &lt;&lt; res[n] &lt;&lt; endl;&#125; G. 双重矩阵题目大意给定一个$~n\\times m~$的矩阵，以它位子矩阵单位构造一个$x\\times y$个该矩阵的大矩阵，问大矩阵最大的子矩阵满足不互质。数据范围$~1\\leq n\\leq100,~1\\leq m\\leq100,~1\\leq x\\leq1000000,~1\\leq y\\leq1000000~$。 题解问$~\\text{WSY}~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using ul = std::uint32_t;using li = std::int32_t;using ll = std::int64_t;using ull = std::uint64_t;using llf = long double;using lf = double;const ul sz = 256;ul data;ul vtrees[201][sz &lt;&lt; 1];ul htree[sz &lt;&lt; 1];ull n, m, x, y;ul gcd(ul a, ul b)&#123; while (a) &#123; a ^= b ^= a ^= b %= a; &#125; return b;&#125;void change(ul tree[], ul pos, ul v)&#123; for (tree[pos |= sz] = v, pos &gt;&gt;= 1; pos; pos &gt;&gt;= 1) &#123; tree[pos] = gcd(tree[pos &lt;&lt; 1 | 1], tree[pos &lt;&lt; 1]); &#125;&#125;ul get(const ul tree[], ul l, ul r)&#123; ul ret = 0; for (l = l - 1 | sz, r = r + 1 | sz; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123; if (~l &amp; 1) &#123; ret = gcd(ret, tree[l ^ 1]); &#125; if (r &amp; 1) &#123; ret = gcd(ret, tree[r ^ 1]); &#125; &#125; return ret;&#125;ull fn(ull t)&#123; return t == n ? x * n : t;&#125;ull fm(ull t)&#123; return t == m ? y * m : t;&#125;int main()&#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; for (ul i = 1; i &lt;= n; ++i) &#123; for (ul j = 1; j &lt;= m; ++j) &#123; std::cin &gt;&gt; data; change(vtrees[j], i, data); change(vtrees[j], i + n, data); change(vtrees[j + m], i, data); change(vtrees[j + m], i + n, data); &#125; &#125; ull ans = 0; for (ul up = 1; up &lt;= n; ++up) &#123; for (ul low = up; low &lt;= up + n - 1; ++low) &#123; for (ul i = 1; i &lt;= m + m; ++i) &#123; change(htree, i, get(vtrees[i], up, low)); &#125; for (ul l = 1, r = 1; l &lt;= m; ++l) &#123; while (r &lt; l) &#123; ++r; &#125; while (r &lt; l + m - 1 &amp;&amp; get(htree, l, r + 1) != 1) &#123; ++r; &#125; if (get(htree, l, r) != 1) &#123; ans = std::max(ans, fn(low - up + 1) * fm(r - l + 1)); &#125; &#125; &#125; &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125; H. 我爱割葱题目大意给定$~n~$棵葱，第$~i~$棵的高度为$~a_i~$。定义在高度$~h~$割区间$~[l,~r]~$是合法的，如果对于任意$~i\\in[l,~r]~$，均满足$~h\\leq a_i~$。割完一刀后将获得下面的部分，且上面的部分不会掉落。现在最多割$~k~$刀，问能获得葱的总长度的最大值。 题解问$~\\text{WSY}~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;using ul = std::uint32_t;using li = std::int32_t;using ll = std::int64_t;using ull = std::uint64_t;using llf = long double;using lf = double;const ul sz = 128;ul a[102];ul least[102][102];ul n, k;ul tree[256];std::vector&lt;std::pair&lt;ul, bool&gt;&gt; paras;std::vector&lt;ul&gt; stack;ul segid[102][102];ul valid[1000001];ul idval[101];ul ans[101][101][101];bool already[101][101][101];class segment &#123;public: ul l = 0, r = 0; segment(ul a, ul b): l(a), r(b) &#123; &#125; segment()=default;&#125;;std::vector&lt;segment&gt; sons[102][102];segment bigson[102][102];segment bro[102][102];std::vector&lt;std::vector&lt;segment&gt;&gt; segstack(1);segment idseg[101];void getbroandbigson(ul l, ul r)&#123; if (!sons[l][r].size()) &#123; return; &#125; bigson[l][r] = sons[l][r][0]; for (ul i = 0; i != sons[l][r].size(); ++i) &#123; if (i) &#123; bro[sons[l][r][i - 1].l][sons[l][r][i - 1].r] = sons[l][r][i]; &#125; getbroandbigson(sons[l][r][i].l, sons[l][r][i].r); &#125;&#125;ul search(ul l, ul r, ul c, ul k)&#123; if (!l || !r || !k) &#123; return 0; &#125; if (already[segid[l][r]][valid[c]][k]) &#123; return ans[segid[l][r]][valid[c]][k]; &#125; already[segid[l][r]][valid[c]][k] = true; ul temp1 = 0; for (ul sonk = 0; sonk &lt;= k; ++sonk) &#123; temp1 = std::max(temp1, search(bro[l][r].l, bro[l][r].r, c, k - sonk) + search(bigson[l][r].l, bigson[l][r].r, c, sonk)); &#125; ul temp2 = 0; for (ul sonk = 0; sonk &lt; k; ++sonk) &#123; temp2 = std::max(temp2, search(bro[l][r].l, bro[l][r].r, c, k - 1 - sonk) + search(bigson[l][r].l, bigson[l][r].r, least[l][r], sonk)); &#125; temp2 += (r - l + 1) * (least[l][r] - c); return ans[segid[l][r]][valid[c]][k] = std::max(temp1, temp2);&#125;void change(ul tree[], ul pos, ul val)&#123; for (tree[pos |= sz] = val, pos &gt;&gt;= 1; pos; pos &gt;&gt;= 1) &#123; tree[pos] = std::min(tree[pos &lt;&lt; 1 | 1], tree[pos &lt;&lt; 1]); &#125;&#125;ul get(const ul tree[], ul l, ul r)&#123; ul ret = 1e6 + 1; for (l = l - 1 | sz, r = r + 1 | sz; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123; if (~l &amp; 1) &#123; ret = std::min(ret, tree[l ^ 1]); &#125; if (r &amp; 1) &#123; ret = std::min(ret, tree[r ^ 1]); &#125; &#125; return ret;&#125;int main()&#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; k; for (ul i = 1; i &lt;= n; ++i) &#123; std::cin &gt;&gt; a[i]; change(tree, i, a[i]); &#125; ul cnt = 1; for (ul l = 1; l &lt;= n; ++l) &#123; for (ul r = l; r &lt;= n; ++r) &#123; least[l][r] = get(tree, l, r); if (least[l][r] &gt; a[l - 1] &amp;&amp; least[l][r] &gt; a[r + 1]) &#123; paras.push_back(std::pair&lt;ul, bool&gt;(l, false)); paras.push_back(std::pair&lt;ul, bool&gt;(r, true)); segid[l][r] = cnt; valid[least[l][r]] = cnt; idseg[cnt] = segment(l, r); idval[cnt] = least[l][r]; ++cnt; &#125; &#125; &#125; std::sort(paras.begin(), paras.end()); for (const auto&amp; para : paras) &#123; if (para.second) &#123; ul l = stack.back(); ul r = para.first; stack.pop_back(); sons[l][r] = std::move(segstack.back()); segstack.pop_back(); segstack.back().push_back(segment(l, r)); &#125; else &#123; stack.push_back(para.first); segstack.push_back(std::vector&lt;segment&gt;()); &#125; &#125; getbroandbigson(1, n); std::cout &lt;&lt; search(1, n, 0, k) &lt;&lt; std::endl; return 0;&#125; I. 起起落落题目大意给定一个序列$~p~$，定义一个奇数长度且至少为$~3~$的子序列$~p_{a_1},~p_{a_2},~\\dots,~p_{a_m}~$是持续下降的，如果对于任意$~i~$为偶数，均满足$~p_{a_{i-1}}&gt;p_{a_{i+1}}&gt;p_{a_i}~$。计算出有多少个持续下降子序列。数据范围$~1\\leq n\\leq100000~$。 题解问$~\\text{WJR}~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;const int mod = 1e9 + 7;int n;int a[maxn],t[maxn],e;int pos(int x)&#123; return lower_bound(t+1,t+1+e,x) - t;&#125;struct SEG&#123; int seg[maxn*5],lazy[maxn*5],g[maxn*5]; int lson(int v) &#123; return v &lt;&lt; 1; &#125; int rson(int v) &#123; return v &lt;&lt; 1 | 1; &#125; void init()&#123; memset(seg,0,sizeof seg); memset(lazy,0,sizeof seg); memset(g,0,sizeof g); &#125; void pushdown(int v)&#123; lazy[lson(v)] += lazy[v]; lazy[rson(v)] += lazy[v]; lazy[v] = 0; &#125; void change(int l,int r,int ql,int qr,int v,int val)&#123; if(l &gt; qr||r &lt; ql) return; if(l == r) &#123; lazy[v] = 0; g[v] = val; return; &#125; pushdown(v); int mid = (l + r ) &gt;&gt; 1; change(l,mid,ql,qr,lson(v),val); change(mid+1,r,ql,qr,rson(v),val); pushup(v); &#125; void pushup(int v)&#123; seg[v] = (seg[lson(v)] + 1ll * g[lson(v)] * lazy[lson(v)] % mod) % mod; seg[v] += (seg[rson(v)] + 1ll * g[rson(v)] * lazy[rson(v)] % mod) % mod; seg[v] %= mod; g[v] = (g[lson(v)] + g[rson(v)]) % mod; &#125; void update(int l,int r,int ql,int qr,int v,int val) &#123; if(qr &lt; ql) return; if(ql &lt;= l&amp;&amp;r &lt;= qr) &#123; lazy[v] += val; return; &#125; if(l &gt; qr||r &lt; ql) return; pushdown(v); int mid = (l + r) &gt;&gt; 1; if(l &lt;= mid) update(l,mid,ql,qr,lson(v),val); if(r &gt; mid) update(mid+1,r,ql,qr,rson(v),val); pushup(v); &#125; int sum(int l,int r,int ql,int qr,int v) &#123; if(qr &lt; ql) return 0; if(ql &lt;= l&amp;&amp;r &lt;= qr)&#123; return (seg[v] + 1ll * g[v] * lazy[v] % mod) % mod; &#125; if(r &lt; ql||l &gt; qr) return 0; pushdown(v); int res = 0,mid = (l + r) &gt;&gt; 1; if(l &lt;= mid) res += sum(l,mid,ql,qr,lson(v)); if(r &gt; mid) res = (res + sum(mid+1,r,ql,qr,rson(v))) % mod; pushup(v); return res; &#125;&#125;f;int main() &#123; scanf(\"%d\",&amp;n); for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;a[i]); memcpy(t,a,sizeof a); e = n; sort(t+1,t+1+e); e = unique(t+1,t+1+e) - (t+1); f.init(); int ans = 0; for(int i = n;i &gt;= 1;i--) &#123; int v = pos(a[i]); int temp = f.sum(1,e,1,v-1,1); ans = (ans + temp) % mod; f.update(1,e,v+1,e,1,1); f.change(1,e,v,v,1,(temp + 1) % mod); &#125; printf(\"%d\\n\",ans); return 0;&#125; J. 夺宝奇兵有$~n~$个人，他们总共有$~m~$个宝物。现已知每个宝物在谁手上和它的售价，问最少花多少钱买可以使得自己的宝物数量严格大于任何人的宝物数量。 题解先对所有人所持有的宝物排序，然后暴力枚举交易结束后其他人宝物数量的最大值。在这个过程中维护一棵权值线段树，这样每次枚举过程中树上二分即可得到相应的最小花费。我的代码是使用二分权值树状数组，复杂度多一层$~O(\\log m)~$，但是常数比权值线段树递归写法小很多，也很方便。权值线段树或权值树状数组二分写法的时间复杂度为$~o((n+m)\\log m)~$，下面代码的时间复杂度为$~O((n+m)\\log^2m)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;long long num[maxn], bit2[maxn];vector&lt;int&gt; have[maxn], flr[maxn];int cnt[maxn], bit1[maxn];#define lowbit(x) (x &amp; -x)int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; struct Input &#123; long long a; int c; &#125;; vector&lt;Input&gt; input(m + 1); for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; input[i].a &gt;&gt; input[i].c; sort(input.begin(), input.end(), [](Input a, Input b) &#123;return a.a &lt; b.a;&#125;); for (int i = 1; i &lt;= m; ++i) &#123; num[i] = input[i].a; have[input[i].c].push_back(i); flr[have[input[i].c].size()].push_back(input[i].c); &#125; long long tot = 0; for (int i = 1; i &lt;= n; ++i) sort(have[i].begin(), have[i].end(), greater&lt;long long&gt;()); int up; for (up = 1; flr[up].size(); ++up) cnt[up] = cnt[up - 1] + flr[up].size(); for (int i = 1; i &lt;= m; ++i) for (int j = i; j &lt; maxn; j += lowbit(j)) ++bit1[j], bit2[j] += num[i]; long long res = 0x3f3f3f3f3f3f3f3f; for (int i = up; cnt[up - 1] - cnt[i - 1] &lt;= i &amp;&amp; i; --i) &#123; int rem = i - cnt[up - 1] + cnt[i - 1]; for (auto j : flr[i]) &#123; int idx = have[j][i - 1]; tot += num[idx]; for (int k = idx; k &lt; maxn; k += lowbit(k)) --bit1[k], bit2[k] -= num[idx]; &#125; long long now = tot; if (rem) &#123; int l = 0, r = maxn; while (r - l ^ 1) &#123; int mid = l + r &gt;&gt; 1, sum = 0; for (int k = mid; k; k -= lowbit(k)) sum += bit1[k]; if (sum &lt; rem) l = mid; else r = mid; &#125; for (int k = r; k; k -= lowbit(k)) now += bit2[k]; &#125; res = min(res, now); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; K. 星球大战题目大意给定一个$~n~$个点$~m~$条边的简单连通图，定义两点间的距离为连接连点的简单路径的最小值。现给定邪恶势力的起点位置，需要找到一个正义势力的起点位置，使得势力扩散后最终邪恶势力的数量最少。对于每个点，如果它离邪恶势力的距离严格小于离正义势力的距离，则最终会变为邪恶势力，否则变为正义势力或者保持中立。输出邪恶势力最终数量的最小值。 题解问$~\\text{WSY}~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;bits/stdc++.h&gt;using ul = std::uint32_t;using li = std::int32_t;using ll = std::int64_t;using ull = std::uint64_t;using llf = long double;using lf = double;using vul = std::vector&lt;ul&gt;;vul edges[ul(1e5 + 1)];ul father[ul(1e5 + 1)][18];std::vector&lt;ul&gt; sons[ul(1e5 + 1)];ul n, m;std::queue&lt;ul&gt; queue;bool already[ul(1e5 + 1)];std::vector&lt;ul&gt; special;ul disspecial[202][ul(1e5 + 1)];ul dis1[ul(1e5 + 1)];ul left[ul(1e5 + 1)];ul right[ul(1e5 + 1)];std::vector&lt;std::pair&lt;ul, bool&gt;&gt; paras;ul calcfather(ul x, ul lg)&#123; if (!x) &#123; return 0; &#125; if (~father[x][lg]) &#123; return father[x][lg]; &#125; else &#123; return father[x][lg] = calcfather(calcfather(x, lg - 1), lg - 1); &#125;&#125;ul getfather(ul x, ul step)&#123; for (ul lg = 0; step; step &gt;&gt;= 1, ++lg) &#123; if (step &amp; 1) &#123; x = calcfather(x, lg); &#125; &#125; return x;&#125;ul search(ul x, ul cnt) &#123; left[x] = cnt; for (ul son : sons[x]) &#123; cnt = search(son, cnt + 1); &#125; right[x] = cnt; return cnt;&#125;int main()&#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::scanf(\"%u%u\", &amp;n, &amp;m); for (ul i = 1; i &lt;= n; ++i) &#123; for (ul j = 0; j != 18; ++j) &#123; father[i][j] = ~ul(0); &#125; &#125; for (ul i = 0; i != m; ++i) &#123; ul u, v; std::scanf(\"%u%u\", &amp;u, &amp;v); edges[u].push_back(v); edges[v].push_back(u); &#125; queue.push(1); already[1] = true; father[1][0] = 0; while (queue.size()) &#123; ul curr = queue.front(); queue.pop(); for (ul nex : edges[curr]) &#123; if (father[curr][0] == nex) &#123; continue; &#125; if (already[nex]) &#123; special.push_back(curr); special.push_back(nex); continue; &#125; father[nex][0] = curr; sons[curr].push_back(nex); queue.push(nex); already[nex] = true; dis1[nex] = dis1[curr] + 1; &#125; &#125; std::sort(special.begin(), special.end()); special.resize(std::unique(special.begin(), special.end()) - special.begin()); search(1, 1); for (ul i = 0; i != special.size(); ++i) &#123; for (ul j = 1; j &lt;= n; ++j) &#123; disspecial[i][j] = ~ul(0); &#125; queue.push(special[i]); disspecial[i][special[i]] = 0; while (queue.size()) &#123; ul curr = queue.front(); queue.pop(); for (ul nex : edges[curr]) &#123; if (~disspecial[i][nex]) &#123; continue; &#125; disspecial[i][nex] = disspecial[i][curr] + 1; queue.push(nex); &#125; &#125; &#125; ul ans = n; for (ul white = 2; white &lt;= n; ++white) &#123; paras.resize(0); for (ul i = 0; i != special.size(); ++i) &#123; if (dis1[special[i]] &lt; disspecial[i][white]) &#123; continue; &#125; ul temp = getfather(special[i], dis1[special[i]] - disspecial[i][white] &gt;&gt; 1); paras.push_back(std::pair&lt;ul, bool&gt;(left[temp], false)); paras.push_back(std::pair&lt;ul, bool&gt;(right[temp], true)); &#125; ul temp = getfather(white, dis1[white] &gt;&gt; 1); paras.push_back(std::pair&lt;ul, bool&gt;(left[temp], false)); paras.push_back(std::pair&lt;ul, bool&gt;(right[temp], true)); std::sort(paras.begin(), paras.end()); temp = 0; ul st = 0; ul prev = 0; for (const auto&amp; para : paras) &#123; if (!st) &#123; prev = para.first; &#125; if (para.second) &#123; --st; &#125; else &#123; ++st; &#125; if (!st) &#123; temp += para.first - prev + 1; &#125; &#125; ans = std::min(ans, n - temp); &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[]},{"title":"RMQ与LCA与ST表 (TBC)","slug":"RMQ与LCA与ST表 (TBC)","date":"2019-02-14T17:19:26.857Z","updated":"2019-02-15T20:28:53.818Z","comments":true,"path":"2019/02/15/RMQ与LCA与ST表 (TBC)/","link":"","permalink":"http://yoursite.com/2019/02/15/RMQ与LCA与ST表 (TBC)/","excerpt":"","text":"RMQ区间最值查询$~\\text{Range Minimun/Maximun Query}~$，简称$~\\text{RMQ}~$。 线段树线段树是解决$~\\text{RMQ}~$问题最普通的办法，时间复杂度为预处理$~O(n)~$，单次询问$~O(\\log n)~$。支持在线。同时也支持$~O(\\log n)~$的区间修改的动态$~\\text{RMQ}~$问题。下面模板的区间均为左开右闭，角标从$~0~$开始。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const int maxn = 1 &lt;&lt; 17;int a[maxn], seg[maxn &lt;&lt; 1], tag[maxn &lt;&lt; 1];#define mid (begin + end &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (index &lt;&lt; 1 ^ 1)void build(int begin, int end, int index) &#123; if (begin ^ mid) &#123; build(begin, mid, lson); build(mid, end, rson); seg[index] = min(seg[lson], seg[rson]); &#125; else &#123; seg[index] = a[begin]; &#125;&#125;inline void push_down(const int&amp; index) &#123; seg[index] += tag[index]; if (index &lt; maxn)) &#123; tag[lson] += tag[index]; tag[rson] += tag[index]; &#125; tag[index] = 0;&#125;void modify(int begin, int end, int index, int left, int right, int x) &#123; push_down(index); if (begin &gt;= left &amp;&amp; end &lt;= right) &#123; tag[index] += x; return; &#125; if (left &lt; mid) modify(begin, mid, lson, left, right, x); if (right &gt; mid) modify(mid, end, rson, left, right, x); seg[index] = min(seg[lson] + tag[lson], seg[rson] + tag[rson]);&#125;int query(int begin, int end, int index, int left, int right) &#123; push_down(index); if (begin &gt;= left &amp;&amp; end &lt;= right) return seg[index]; if (begin &gt;= right || end &lt;= left) return 0x3f3f3f3f; return min(query(begin, mid, lson, left, right), query(mid, end, rson, left, right));&#125; ST表如果只有静态查询，那么考虑这样一个数组：记$~st[i][j]~$为$~[i,~i+2^j)~$的最值。那么需要$~O(n\\log n)~$的空间。显然$~st[i][0]=a[i]~$。且对于其它项，可以将区间$~[i,~i+2^j)~$二分为$~[i,~i+2^{j-1})~$和$~[i+2^{j-1},~i+2^j)~$，也就是通过$~st[i][j-1]~$和$~st[i+2^{j-1}][j-1]~$来$~O(1)~$地转移。那么对于任意的询问区间$~[l,~r)~$，记$~k=\\lfloor\\log(r-l)\\rfloor~$，均可划分为$~[l,~l+2^k)~$和$~[r-2^k,~r)~$这两个子问题来解决。时间复杂度为预处理$~O(n\\log n)~$，单次询问$~O(1)~$。支持在线。下面模板的角标从$~0~$开始。 12345678910111213141516const int pow2 = 17;const int maxn = 1 &lt;&lt; pow2;int a[maxn], st[maxn][pow2 + 1], log2_floor[maxn], n;void st_init(int n) &#123; log2_floor[0] = -1; for (int i = 1; i &lt;= n; ++i) log2_floor[i] = log2_floor[i &gt;&gt; 1] + 1; for (int i = 0; i ^ n; ++i) st[i][0] = a[i]; for (int i = 1; i &lt;= log2_floor[n]; ++i) for (int j = 0; j + (1 &lt;&lt; i) ^ n; ++j) st[j][i] = min(st[j][i - 1], st[j + (1 &lt;&lt; i - 1)][i - 1]);&#125;inline int rmq(const int&amp; l, const int&amp; r) &#123; int k = log2_floor[r - l]; return min(st[l][k], st[r - (1 &lt;&lt; k)][k]);&#125; LCA最近公共祖先$~\\text{Lowest Common Ancestors}~$，简称$~\\text{LCA}~$。 倍增类似于$~\\text{ST}~$表的$~\\text{DP}~$思想，记$~pa[i][j]~$为节点$~i~$的第$~2^j~$级祖先。为防止溢出，根节点的父亲依然是根节点。现在$~\\text{DFS}~$过程中处理出$~pa[i][0]~$，对于其它项，有$~O(1)~$的转移式 pa[i][j]=pa[pa[i][j-1]][j-1]这里的时间复杂度和空间复杂度均为$~O(\\log n)~$。那么可以用类似快速幂的方式，可以在$~O(\\log n)~$的时间内查询任意点的任意级祖先。查询$~\\text{LCA}~$时，先将较深的点上升到与另一点等高，然后在保持两点不一样的条件下，将两个点上升至$~\\text{LCA}~$的两个儿子处。时间复杂度为预处理$~O(n\\log n)~$，单次查询$~O(\\log n)~$。支持在线。 123456789101112131415161718192021const int pow2 = 17;const int maxn = 1 &lt;&lt; pow2;vector&lt;int&gt; adj[maxn];int pa[maxn][pow2], dep[maxn];void dfs(int u = 1, int p = 1, int d) &#123; dep[u] = d; pa[u][0] = p; for (int i = 1; i ^ pow2; ++i) pa[u][i] = pa[pa[u][i - 1]][i - 1]; for (auto v : adj[u]) if (v ^ p) dfs(v, u, d + 1);&#125;int lca(int u, int v) &#123; if (dep[u] &gt; dep[u]) swap(u, v); for (int k = dep[v] - dep[u], i = 0; k; k &gt;&gt;= 1, ++i) if (k &amp; 1) u = pa[u][i]; if (u == v) return u; for (int i = pow2 - 1; ~i; --i) if (pa[u][i] ^ pa[v][i]) &#123; u = pa[u][i]; v = pa[v][i]; &#125; return pa[u][0];&#125; ST表首先引入一个叫欧拉序的概念，在$~\\text{DFS}~$序的基础上，将回溯过程中经过的点也加入到序列之中，则构成了欧拉序。容易证明，序列的长度为$~2n-1~$，且一个节点是叶节点当且仅当它只在欧拉序中出现一次。那么对于非叶节点$~u~$，它在欧拉序中出现至少$~2~$次，那么节点$~v~$是$~u~$的后代，当且仅当$~v~$在欧拉序中，被$~2~$个$~u~$包含。于是对于欧拉序上两个点的$~\\text{LCA}~$问题，可以等价于这两个节点构成的闭区间的$~\\text{LCA}~$问题，且$~\\text{LCA}~$必出现在这个闭区间之中。和$~\\text{RMQ}~$问题一样，这类问题是保偏序的。所以可以用$~\\text{ST}~$表来支持$~O(n\\log n)~$的预处理和$~O(1)~$的单次在线查询。 1234567891011121314151617181920212223242526272829303132const int pow2 = 17;const int maxn = 1 &lt;&lt; pow2;vector&lt;int&gt; adj[maxn];int st[maxn &lt;&lt; 1][pow2 + 1], dep[maxn], euler[maxn], log2_floor[maxn &lt;&lt; 1];int euler_clock;void dfs(int u = 1, int p = 0) &#123; st[++euler_clock][0] = u; euler[u] = euler_clock; for (auto v : adj[u]) if (v ^ p) &#123; dep[v] = dep[u] + 1; dfs(v, u); st[++euler_clock][0] = u; &#125;&#125;inline bool cmp(const int&amp; x, const int&amp; y) &#123;return dep[x] &lt; dep[y];&#125;inline int upper(const int&amp; x, const int&amp; y) &#123;return cmp(x, y) ? x : y;&#125;void lca_init() &#123; log2_floor[0] = -1; for (int i = 1; i &lt;= euler_clock; ++i) log2_floor[i] = log2_floor[i &gt;&gt; 1] + 1; for (int i = 1; i &lt;= log2_floor[euler_clock]; ++i) for (int j = 1; j + (1 &lt;&lt; i) ^ euler_clock + 1; ++j) st[j][i] = upper(st[j][i - 1], st[j + (1 &lt;&lt; i - 1)][i - 1]);&#125;inline int lca(int u, int v) &#123; if (u == v) return u; u = euler[u]; v = euler[v]; if (u &gt; v) swap(u, v); int temp = log2_floor[++v - u]; return upper(st[u][temp], st[v - (1 &lt;&lt; temp)][temp]);&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"RMQ","slug":"RMQ","permalink":"http://yoursite.com/tags/RMQ/"},{"name":"LCA","slug":"LCA","permalink":"http://yoursite.com/tags/LCA/"},{"name":"ST表","slug":"ST表","permalink":"http://yoursite.com/tags/ST表/"}]},{"title":"Codeforces Global Round 1 (TBC)","slug":"Codeforces Global Round 1 (TBC)","date":"2019-02-14T16:32:50.817Z","updated":"2019-02-14T16:51:29.557Z","comments":true,"path":"2019/02/15/Codeforces Global Round 1 (TBC)/","link":"","permalink":"http://yoursite.com/2019/02/15/Codeforces Global Round 1 (TBC)/","excerpt":"","text":"Codeforces Global Round 1 A. Parity题目大意问一个$~k~$位$~b~$进制数的奇偶性。 题解水题。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int b, k, a; cin &gt;&gt; b &gt;&gt; k; b &amp;= 1; int res = 0; while (--k) &#123; cin &gt;&gt; a; res ^= a &amp; 1 &amp; b; &#125; cin &gt;&gt; a; res ^= a &amp; 1; if (res) cout &lt;&lt; \"odd\" &lt;&lt; endl; else cout &lt;&lt; \"even\" &lt;&lt; endl;&#125; B. Tape题目大意要求使用$~k~$个区间覆盖$~n~$个点，输出区间长度总和的最小值。 题解水题。贪心。差分序列排序即可。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; vector&lt;int&gt; b(n), d(n, 0); for (auto&amp; in : b) cin &gt;&gt; in; for (int i = 1; i ^ n; ++i) d[i] = b[i] - b[i - 1] - 1; sort(d.begin(), d.end()); int res = b.back() - b.front() + 1; for (int i = n - k + 1; i ^ n; ++i) res -= d[i]; cout &lt;&lt; res &lt;&lt; endl;&#125; C. Meaningless Operations题目大意定义$~f(a)=\\max{\\gcd(a\\oplus b,~a\\odot b)\\mid0&lt; b&lt; a}~$其中$~\\oplus~$和$~\\odot~$分别是位运算中的异或$~\\text{xor}~$和与$~\\text{and}~$。一共$~q~$次询问，输出对应的$~f(a)~$。数据范围$~1\\leq q\\leq10^3,~2\\leq a\\leq2^{25}-1~$。 题解可以发现将$~a~$二进制表示后，如果不全为$~1~$，则$~f(a)~$即为全为$~1~$的数值（取$~b~$为$~a~$的补位）。否则$~f(a)~$为$~a~$的最大非$~a~$因子。具体证明过程可自行考虑。那么只需要预处理所有$~2^n-1~$即可。用$~\\text{map}~$储存预处理数值并用$~\\text{__builtin}~$优化位运算，总时间复杂度为$~O(\\sqrt{a}+q\\log a)~$。当然也可以打表后用数组储存答案，时间复杂度可以优化至$~O(q)~$。 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; map&lt;int, int&gt; res; for (int i = 2; i &lt;= 25; ++i) &#123; int x = (1 &lt;&lt; i) - 1; for (int j = 3, k = sqrt(x + 0.1); j &lt;= k; ++j) if (!(x % j)) &#123; res[x] = x / j; break; &#125; if (res.find(x) == res.end()) res[x] = 1; &#125; int q; cin &gt;&gt; q; while (q--) &#123; int a; cin &gt;&gt; a; int x = (1 &lt;&lt; 32 - __builtin_clz(a)) - 1; if (x ^ a) cout &lt;&lt; x &lt;&lt; endl; else cout &lt;&lt; res[x] &lt;&lt; endl; &#125;&#125; D. Jongmah题目大意麻将模拟，问最多能凑出多少副顺子或者刻子。 题解动态规划。每个数字如果作为顺子计算，那么只有$~3~$种位置供选择。而若某一位置上这个数字作为顺子出现的次数大于$~2~$，那么对于$~3k~$个一样的顺子，可以化为$~3k~$个刻子。那么对于每一个数字，它前$~2~$个数字的状态总数则是$~3\\times3=9~$种，每次转移要计算$~3~$次，这样总时间复杂度为$~O(3^3m)~$。可以用滚动数组优化空间。 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; cnt(m, 0); while (n--) &#123; int a; cin &gt;&gt; a; ++cnt[--a]; &#125; int dp[2][3][3] = &#123;0&#125;; for (int i = 0; i ^ m; ++i) &#123; memset(dp[i &amp; 1 ^ 1], 0, 9 * sizeof (int)); for (int j = 0; j ^ 3; ++j) for (int k = 0; k ^ 3; ++k) for (int l = 0; l ^ 3; ++l) if (j + k + l &lt;= cnt[i]) dp[i &amp; 1 ^ 1][k][l] = max(dp[i &amp; 1 ^ 1][k][l], dp[i &amp; 1][j][k] + l + (cnt[i] - j - k - l) / 3); &#125; cout &lt;&lt; dp[m &amp; 1][0][0] &lt;&lt; endl;&#125; E. Magic Stones题目大意对于一个长度为$~n~$的序列，可以对非端点元素如下操作：将$~c_i~$变为$~c_{i+1}+c_{i-1}-c_i~$。现给定两个序列$~c~$和$~t~$，问$~c~$能否经过若干次操作变成$~t~$。 题解考虑差分序列，不难发现每次操作则是交换差分序列相邻的两个元素。只需要将差分序列排序比较即可。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), b(n); for (auto&amp; in : a) cin &gt;&gt; in; for (auto&amp; in : b) cin &gt;&gt; in; for (int i = n - 1; i; --i) a[i] -= a[i - 1], b[i] -= b[i - 1]; sort(a.begin() + 1, a.end()); sort(b.begin() + 1, b.end()); cout &lt;&lt; (a == b ? \"Yes\" : \"No\") &lt;&lt; endl;&#125; F. Nearest Leaf题目大意编号按照$~\\text{DFS}~$序给出一棵边权树，两点之间的距离定义为简单路径的权值和。每次询问编号$~[l,~r]~$内与$~v~$最近的叶子的距离。数据范围$~3\\leq n\\leq500000,~1\\leq q\\leq500000~$。 题解将问题离线，对于$~v=1~$的询问，叶节点的距离保留，其余距离设为$~\\inf~$，这样可以用一棵最值线段树来询问最短距离。由$~\\text{DFS}~$序的性质，每个节点的子树的编号均为序列上的一个闭区间，那么在$~\\text{DFS}~$的过程中，区间修改，就能对所有的节点进行询问。总时间复杂度为$~O((n+q)\\log n)~$。注意需要快读。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 19;vector&lt;pair&lt;int, long long&gt;&gt; son[maxn];vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; ask[maxn];long long dis[maxn], res[maxn], seg[maxn &lt;&lt; 1], tag[maxn &lt;&lt; 2];bool check[maxn];int n, now, index[maxn];void dfs1(int u) &#123; now = u; for (auto e : son[u]) &#123; dis[e.first] = dis[u] + e.second; dfs1(e.first); &#125; index[u] = now; check[u] = son[u].empty();&#125;#define mid (begin + end &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (index &lt;&lt; 1 ^ 1)void build(int begin, int end, int index) &#123; if (begin ^ mid) &#123; build(begin, mid, lson); build(mid, end, rson); seg[index] = min(seg[lson], seg[rson]); &#125; else &#123; seg[index] = check[end] ? dis[end] : 0x3f3f3f3f3f3f3f3f; &#125;&#125;inline void push_down(const int&amp; index) &#123; seg[index] += tag[index]; tag[lson] += tag[index]; tag[rson] += tag[index]; tag[index] = 0;&#125;long long query(int begin, int end, int index, int left, int right) &#123; push_down(index); if (begin &gt;= left &amp;&amp; end &lt;= right) return seg[index]; if (begin &gt;= right || end &lt;= left) return 0x3f3f3f3f3f3f3f3f; return min(query(begin, mid, lson, left, right), query(mid, end, rson, left, right));&#125;void modify(int begin, int end, int index, int left, int right, long long x) &#123; push_down(index); if (begin &gt;= left &amp;&amp; end &lt;= right) &#123; tag[index] += x; return; &#125; if (left &lt; mid) modify(begin, mid, lson, left, right, x); if (right &gt; mid) modify(mid, end, rson, left, right, x); seg[index] = min(seg[lson] + tag[lson], seg[rson] + tag[rson]);&#125;void dfs2(int u) &#123; for (auto q : ask[u]) res[q.second] = query(0, n, 1, q.first.first - 1, q.first.second); for (auto e : son[u]) &#123; tag[1] += e.second; modify(0, n, 1, e.first - 1, index[e.first], -(e.second &lt;&lt; 1)); dfs2(e.first); tag[1] -= e.second; modify(0, n, 1, e.first - 1, index[e.first], e.second &lt;&lt; 1); &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int q; cin &gt;&gt; n &gt;&gt; q; for (int i = 2; i &lt;= n; ++i) &#123; int p; long long w; cin &gt;&gt; p &gt;&gt; w; son[p].push_back(make_pair(i, w)); &#125; dfs1(1); build(0, n, 1); for (int i = 0; i ^ q; ++i) &#123; int v, l, r; cin &gt;&gt; v &gt;&gt; l &gt;&gt; r; ask[v].push_back(make_pair(make_pair(l, r), i)); &#125; dfs2(1); for (int i = 0; i ^ q; ++i) cout &lt;&lt; res[i] &lt;&lt; '\\n';&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Educational Codeforces Round 59 (Rated for Div. 2) (TBC)","slug":"Educational Codeforces Round 59 (Rated for Div. 2) (TBC)","date":"2019-02-14T10:11:31.136Z","updated":"2019-02-14T11:52:24.786Z","comments":true,"path":"2019/02/14/Educational Codeforces Round 59 (Rated for Div. 2) (TBC)/","link":"","permalink":"http://yoursite.com/2019/02/14/Educational Codeforces Round 59 (Rated for Div. 2) (TBC)/","excerpt":"","text":"Educational Codeforces Round 59 (Rated for Div. 2) A. Digits Sequence Dividing题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int q; cin &gt;&gt; q; while (q--) &#123; int n; string str; cin &gt;&gt; n &gt;&gt; str; if (str.size() == 2 &amp;&amp; str.front() &gt;= str.back()) cout &lt;&lt; \"NO\" &lt;&lt; endl; else cout &lt;&lt; \"YES\" &lt;&lt; endl &lt;&lt; 2 &lt;&lt; endl &lt;&lt; str.front() &lt;&lt; ' ' &lt;&lt; str.substr(1) &lt;&lt; endl; &#125;&#125; B. Digital root题目大意对于任意正整数$~x~$，将其十进制表示下的所有位的数字相加得到新的数字$~\\bar{x}~$，不断操作下去，最终会得到一个个位数，记为$~S(x)~$。问第$~k~$大的满足$~S=x~$的数是多少。 题解水题。不难发现每次操作均满足$~x=\\bar{x}\\mod9~$。于是答案即为$~9(k-1)+x~$。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; while (n--) &#123; long long k, x; cin &gt;&gt; k &gt;&gt; x; cout &lt;&lt; (k - 1) * 9 + x &lt;&lt; endl; &#125;&#125; C. Brutality题目大意给定一个小写字母串和同样长度的数值序列，字符串中每段连续的同字母字串所对应的数值序列中，最多取$~k~$个数，问最大的取值之和。 题解水题。直接模拟，用$~\\text{mulitset}~$或者$~\\text{priority_queue}~$维护均可。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;long long&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; string str; cin &gt;&gt; str; str.push_back('#'); a.push_back(0); ++n; priority_queue&lt;long long&gt; heap; heap.push(a.front()); long long res = 0; int cnt; for (int i = 1; i ^ n; ++i) &#123; if (str[i] ^ str[i - 1]) &#123; cnt = k; while (!heap.empty()) &#123; res += heap.top(); if (!--cnt) break; heap.pop(); &#125; while (!heap.empty()) heap.pop(); &#125; heap.push(a[i]); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. Compression题目大意给定一个$~n\\times n~$的$~01~$矩阵，问$~n~$的最大因子$~x~$，满足把大矩阵划分为$~\\frac{n}{x}\\times\\frac{n}{x}~$个$~x\\times x~$的小矩阵之后，所有的小矩阵均只有一个值。 题解水题？直接对每行每列取$~\\gcd~$即可。没看标解也看不懂标解。所以这场比赛有$~4~$个签到题？ 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5200;bitset&lt;maxn&gt; row[maxn], column[maxn];inline int calc(const bitset&lt;maxn&gt;&amp; bit, const int n) &#123; int last = !bit[0]; int ret = 0, cnt = 0; for (int i = 0; i ^ n; ++i) &#123; if (last ^ bit[i]) &#123; ret = __gcd(ret, cnt); cnt = 0; &#125; ++cnt; last = bit[i]; &#125; return __gcd(ret, cnt);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 0; i ^ n; ++i) &#123; string str; cin &gt;&gt; str; for (int j = 0; j ^ n &gt;&gt; 2; ++j) &#123; int x = isdigit(str[j]) ? str[j] - '0' : str[j] - 'A' + 10; for (int k = 0; k ^ 4; ++k) if (x &amp; 1 &lt;&lt; 3 - k) row[i].flip(j &lt;&lt; 2 ^ k); &#125; &#125; for (int i = 0; i ^ n; ++i) for (int j = 0; j ^ n; ++j) if (row[i][j]) column[j].flip(i); int res = 0; for (int i = 0; i ^ n; ++i) res = __gcd(res, __gcd(calc(row[i], n), calc(column[i], n))); cout &lt;&lt; res &lt;&lt; endl;&#125; G. Vasya and Maximum Profit题目大意给定两序列$~d_1,~d_2,~\\dots,~d_n~$和$~c_1,~c_2,~\\dots,~c_n~$，其中$~d~$严格单增。并定义 gap(l,~r)=\\begin{cases} \\max_{l\\leq i< r}(d_{i+1}-d_i)^2 &\\text{$l< r$} \\\\ 0 &\\text{$l=r$} \\end{cases}对于区间$~[l,~r]~$的价值，计算公式为 (r-l+1)a-\\sum_{i=l}^{r}c_i-gap(l,~r)问最大价值。 题解首先预处理$~(d_{i+1}-d_i)^2~$数组。考虑每个区间所对应的$~gap~$在该数组中的位置。用单调栈可以线性预处理出$~(d_{i+1}-d_i)^2~$在该数组中，左右边第一个比它大的位置。那么对于取到$~gap(l,~r)=(d_{i+1}-d_i)^2~$的区间$~[l,~r]~$。可以$~O(1)~$地确认区间的左右边界。暴力枚举每个$~(d_{i+1}-d_i)^2~$，接下来就是一个线段树维护区间求和的最大值问题了，在普通区间求和线段树的基础上，每个节点还需要维护包含左端点的最大区间和和包含右端点的最大区间和。总时间复杂度为$~O(n\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;long long d[maxn], c[maxn], del[maxn];pair&lt;int, int&gt; seg[maxn];struct Node &#123; long long sum, left, right;&#125; tree[maxn &lt;&lt; 2];#define mid (begin + end &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (index &lt;&lt; 1 ^ 1)void build(int begin, int end, int index) &#123; if (begin == end) &#123; if ((tree[index].sum = c[begin]) &gt; 0) tree[index].left = tree[index].right = c[begin]; return; &#125; build(begin, mid, lson); build(mid + 1, end, rson); tree[index].sum = tree[lson].sum + tree[rson].sum; tree[index].left = max(tree[lson].left, tree[lson].sum + tree[rson].left); tree[index].right = max(tree[rson].right, tree[rson].sum + tree[lson].right);&#125;long long query_sum(int left, int right, int begin, int end, int index) &#123; if (left &gt; end || right &lt; begin) return 0; if (left &lt;= begin &amp;&amp; right &gt;= end) return tree[index].sum; return query_sum(left, right, begin, mid, lson) + query_sum(left, right, mid + 1, end, rson);&#125;long long query_left(int left, int right, int begin, int end, int index) &#123; if (left &gt; end || right &lt; begin) return 0xc0c0c0c0c0c0c0c0; if (left &lt;= begin &amp;&amp; right &gt;= end) return tree[index].left; return max(query_left(left, right, begin, mid, lson), query_sum(left, right, begin, mid, lson) + query_left(left, right, mid + 1, end, rson));&#125;long long query_right(int left, int right, int begin, int end, int index) &#123; if (left &gt; end || right &lt; begin) return 0xc0c0c0c0c0c0c0c0; if (left &lt;= begin &amp;&amp; right &gt;= end) return tree[index].right; return max(query_right(left, right, mid + 1, end, rson), query_sum(left, right, mid + 1, end, rson) + query_right(left, right, begin, mid, lson));&#125;int main() &#123; int n; long long a; cin &gt;&gt; n &gt;&gt; a; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; d[i] &gt;&gt; c[i], c[i] = a - c[i]; build(1, n, 1); for (int i = 1; i ^ n; ++i) del[i] = (d[i + 1] - d[i]) * (d[i + 1] - d[i]); stack&lt;int&gt; tmp; for (int i = 1; i ^ n; ++i) &#123; while (!tmp.empty() &amp;&amp; del[tmp.top()] &lt; del[i]) &#123; seg[tmp.top()].second = i; tmp.pop(); &#125; tmp.push(i); &#125; while (!tmp.empty()) &#123; seg[tmp.top()].second = n; tmp.pop(); &#125; for (int i = n - 1; i; --i) &#123; while (!tmp.empty() &amp;&amp; del[tmp.top()] &lt; del[i]) &#123; seg[tmp.top()].first = i + 1; tmp.pop(); &#125; tmp.push(i); &#125; while (!tmp.empty()) &#123; seg[tmp.top()].first = 1; tmp.pop(); &#125; long long res = 0; for (int i = 1; i &lt;= n; ++i) res = max(res, c[i]); for (int i = 1; i ^ n; ++i) res = max(res, query_right(seg[i].first, i, 1, n, 1) + query_left(i + 1, seg[i].second, 1, n, 1) - del[i]); cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"JOISC 2014 Day3 电压","slug":"JOISC 2014 Day3 电压","date":"2019-02-14T08:46:58.469Z","updated":"2019-10-01T10:44:24.550Z","comments":true,"path":"2019/02/14/JOISC 2014 Day3 电压/","link":"","permalink":"http://yoursite.com/2019/02/14/JOISC 2014 Day3 电压/","excerpt":"","text":"LOJ2881 题目大意给定一个$~N~$个点$~M~$条边的无自环但可能有重边不连通的图，问有多少条边满足：存在一种点的二染色，使得其余其它$~M-1~$条边的端点均被二染色，但该边为单染色。数据范围$~2\\leq N\\leq10^5,~1\\leq M\\leq2\\times10^5~$。 题解一条边满足题意当且仅当图中的所有奇环均包含该边且所有偶环均不包含该边。考虑$~\\text{DFS}~$生成树，记链为以树上某点和它某祖先的简单路径。那么途中的所有环均由这棵$~\\text{DFS}~$树上的一条链和不在树上的一条边组成。这样树上满足题意的边为奇环链的交减去偶环链的并，树外若也有边满足题意当且仅当改图只有一个奇环链。链交和链并可以用两个树上差分解决。在$~\\text{DFS}~$过程中点$~u~$的相邻点$~v~$已经遍历过，且不是通过$~u~$的父亲遍历到$~u~$的那条边，那么$~v~$必为$~u~$的祖先或后代。若为祖先，则确定了一个环，通过$~u~$和$~v~$的深度可以确定环的奇偶性。如果是奇环，则在点$~u~$的链交差分数组上加$~1~$，在点$~v~$的链并差分数组上减$~1~$。那么最后在自下往上的遍历过程中展开差分，对于权值等于奇环链数量的点，它连向它父亲的边必在链交之中。同理对链并的差分数组同样操作，判断时对于正权值的点，它连向它父亲的边必在链并之中。这样最后的总复杂度为$~O(N+M)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;vector&lt;int&gt; adj[maxn];bool vis[maxn], check[maxn], use[maxn], flag;int dep[maxn], even[maxn], odd[maxn], cnt, tot, cal;void dfs1(int u, int p) &#123; vis[u] = true; for (auto v : adj[u]) &#123; if (vis[v]) &#123; if (v == p &amp;&amp; !check[u]) &#123; check[u] = true; continue; &#125; if (dep[u] &lt; dep[v]) continue; if ((dep[u] ^ dep[v]) &amp; 1) &#123; ++even[u]; --even[v]; &#125; else &#123; if (flag) exit((cout &lt;&lt; 0 &lt;&lt; endl, 0)); ++cnt; ++odd[u]; --odd[v]; &#125; &#125; else &#123; ++tot; dep[v] = dep[u] + 1; dfs1(v, u); &#125; &#125;&#125;void dfs2(int u) &#123; use[u] = true; for (auto v : adj[u]) if (!use[v]) &#123; dfs2(v); even[u] += even[v]; odd[u] += odd[v]; &#125; if (even[u]) --tot; else if (odd[u] == cnt) ++cal;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; int res; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; cnt = cal = 0; dfs1(i, 0); dfs2(i); if (cnt) &#123; flag = true; res = cal; if (cnt == 1) ++res; &#125; &#125; if (!flag) res = tot; cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"http://yoursite.com/categories/刷题笔记/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"DFS树","slug":"DFS树","permalink":"http://yoursite.com/tags/DFS树/"},{"name":"树上差分","slug":"树上差分","permalink":"http://yoursite.com/tags/树上差分/"}]},{"title":"Codeforces Round 536 (Div. 2)","slug":"Codeforces Round 536 (Div. 2)","date":"2019-02-13T16:33:05.954Z","updated":"2019-02-13T16:33:11.033Z","comments":true,"path":"2019/02/14/Codeforces Round 536 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/02/14/Codeforces Round 536 (Div. 2)/","excerpt":"","text":"Codeforces Round #536 (Div. 2) A. Lunar New Year and Cross Counting题目大意水题。 题解水题。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;char mat[1 &lt;&lt; 9][1 &lt;&lt; 9];int main() &#123; memset(mat, '.', sizeof (mat)); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) cin &gt;&gt; mat[i][j]; int res = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (mat[i][j] == 'X' &amp;&amp; mat[i - 1][j - 1] == 'X' &amp;&amp; mat[i - 1][j + 1] == 'X' &amp;&amp; mat[i + 1][j - 1] == 'X' &amp;&amp; mat[i + 1][j + 1] == 'X') ++res; cout &lt;&lt; res &lt;&lt; endl;&#125; B. Lunar New Year and Food Ordering题目大意餐厅有$~n~$种菜，库存为$~a_1,~a_2,~\\dots,~a_n~$，价格为$~c_1,~c_2,~\\dots,~c_n~$。依次来$~m~$个客人，第$~i~$个人会点$~d_i~$个$~t_i~$菜。一份份上菜，如果库存没有了$~t_i~$菜，则选择库存里最便宜的菜继续一份份上，即使最终无法上满$~d_i~$份也要继续上，上不满则客人不付钱。输出每个客人要付多少钱。数据范围$~1\\leq n\\leq10^5,~1\\leq m\\leq10^5~$。 题解对价格排序以后双指针模拟即可。时间复杂度$~O(n\\log n+m)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;long long&gt; c(n); vector&lt;int&gt; a(n), p(n); for (auto&amp; in : a) cin &gt;&gt; in; for (auto&amp; in : c) cin &gt;&gt; in; iota(p.begin(), p.end(), 0); sort(p.begin(), p.end(), [&amp;c] (int x, int y) &#123;return c[x] &lt; c[y];&#125;); int index = 0; while (m--) &#123; int t, d; cin &gt;&gt; t &gt;&gt; d; long long res = 0; if (a[--t] &lt; d) &#123; res += c[t] * a[t]; d -= a[t]; a[t] = 0; while (index ^ n &amp;&amp; a[p[index]] &lt; d) &#123; res += c[p[index]] * a[p[index]]; d -= a[p[index]]; a[p[index++]] = 0; &#125; if (index ^ n) &#123; res += c[p[index]] * d; a[p[index]] -= d; &#125; else &#123; res = 0; &#125; &#125; else &#123; a[t] -= d; res = c[t] * d; &#125; cout &lt;&lt; res &lt;&lt; '\\n'; &#125;&#125; C. Lunar New Year and Number Division题目大意给定偶数个数字，要求划分为若干组，每组至少$~2~$个。记$~s~$为一组的总和，输出最小的$~\\sum s^2~$。 题解贪心。每组$~2~$个共$~\\frac{n}{2}~$组。其中最大值和最小值一组，次大值和次小值一组，以此类推。正确性可用$~\\text{Jensen}~$不等书证明。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;long long&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; sort(a.begin(), a.end()); long long res = 0; for (int i = 0; i ^ n &gt;&gt; 1; ++i) res += (a[i] + a[n - 1 - i]) * (a[i] + a[n - 1 - i]); cout &lt;&lt; res &lt;&lt; endl;&#125; D. Lunar New Year and a Wander题目大意给定一个$~n~$个点简单连通通图。从$~1~$开始遍历所有的点，根据每个点第一次经过的顺序，可以得到一个$~1,~2,~\\dots,~n~$的全排列。输出字典序最小的全排列。 题解类似$~\\text{Dijstra}~$或$~\\text{Prim}~$的思想，每次取与当前联通快相邻的编号最小的点即可。 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;vector&lt;int&gt; adj[maxn];bool vis[maxn];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; set&lt;int&gt; que; que.insert(1); vector&lt;int&gt; res; while (!que.empty()) &#123; int now = *que.begin(); vis[now] = true; res.push_back(now); que.erase(now); for (auto next : adj[now]) if (!vis[next]) que.insert(next); &#125; cout &lt;&lt; res.front(); for (int i = 1; i ^ res.size(); ++i) cout &lt;&lt; ' ' &lt;&lt; res[i]; cout &lt;&lt; endl;&#125; E. Lunar New Year and Red Envelopes题目大意再$~[1,~n]~$时间段内有$~k~$个红包，每个红包的出现时间段为$~[s,~t]~$，大小为$~w~$。且如果抢了它，则在$~[s,~d]~$以内无法再抢红包，其中$~s\\leq t\\leq d~$。现在$~\\text{Bob}~$抢红包的策略是如果当前时刻可以抢则会去抢$~w~$最大的那个，如果有多个则去抢$~d~$最大的那个（这个操作没看懂）。然后$~\\text{Alice}~$可以令$~\\text{Bob}~$在最多$~m~$个时刻无法抢红包，问$~\\text{Bob}~$的最小收益。数据范围$~1\\leq n\\leq10^5,~1\\leq k\\leq10^5,~1\\leq m\\leq200~$。 题解首先处理$~\\text{Bob}~$在每个时刻如果能抢红包，他抢的红包所对应的$~w~$和$~d~$是多少。这一步扫描线可以完成，用$~\\text{multiset}~$维护当前时刻所有的红包，然后每个红包在$~s~$秒加入$~t+1~$秒移除。接下来就是个动态规划问题，记$~dp[i][j]~$表示$~\\text{Alice}~$已经打断了$~i~$次在$~j~$时刻的最小收益，具体转移见代码。其中$~[i]~$维度可以滚动优化，总时间复杂度为$~O((n+k)\\log k+mn)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;vector&lt;pair&lt;pair&lt;long long, int&gt;, bool&gt;&gt; sweep[maxn];pair&lt;long long, int&gt; red[maxn];long long dp0[maxn], dp1[maxn];int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; while (k--) &#123; int s, t, d; long long w; cin &gt;&gt; s &gt;&gt; t &gt;&gt; d &gt;&gt; w; sweep[s].push_back(make_pair(make_pair(w, d), true)); sweep[t + 1].push_back(make_pair(make_pair(w, d), false)); &#125; multiset&lt;pair&lt;long long, int&gt;&gt; line; for (int i = 1; i &lt;= n; ++i) &#123; for (auto&amp; now : sweep[i]) &#123; if (now.second) line.insert(now.first); else line.erase(line.find(now.first)); &#125; if (line.empty()) red[i] = make_pair(0, i); else red[i] = *line.rbegin(); &#125; long long res = 0x3f3f3f3f3f3f3f3f; ++m; memset(dp1, 0x3f, sizeof (dp1)); dp1[1] = 0; while (m--) &#123; memcpy(dp0, dp1, sizeof (dp0)); memset(dp1, 0x3f, sizeof (dp1)); for (int i = 1; i &lt;= n; ++i) &#123; dp0[red[i].second + 1] = min(dp0[red[i].second + 1], dp0[i] + red[i].first); dp1[i + 1] = min(dp1[i + 1], dp0[i]); &#125; res = min(res, dp0[n + 1]); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; F. Lunar New Year and a Recursive Sequence题目大意已知一个序列$~f~$的递推公式是 f_i=\\left(\\prod_{j=1}^{k}f_{i-j}^{b_j}\\right)\\mod(p=998244353)现给出$~b_1,~b_2,~\\dots,~b_k~$且$~f_1=f_2=\\dots=f_{k-1}=1,~f_n=m~$，求$~f_k~$。数据范围$~1\\leq k\\leq100,~k&lt; n\\leq10^9,~1\\leq m&lt; p=998244353~$。 题解赤裸裸的线性递推套$~N~$次剩余。在不考虑序列$~f~$的前$~k~$项时，对于任意$~f_i~$，存在唯一的一组$~\\beta_i=(b_{i1},~b_{i2},~\\dots,~b_{ik})~$满足$~f_i=\\prod_{j=1}^{k}f_j^{b_j}\\mod p~$。于是得到了一个$~k~$维线性空间内的一个线性序列$~\\beta~$。由费马小定理，可以对$~\\beta~$每个维度都取模$~p-1~$意义下的值。于是有$~N~$次剩余方程$~f_k^{b_{nk}}=m\\mod p~$。用$~\\text{BSGS}~$算法可在$~O(\\sqrt{p}\\log p)~$内解出。线性递推部分用矩阵快速幂即可打到要求，总时间复杂度为$~O(k^3\\log n+\\sqrt{p}\\log p)~$。或者用$~O(k^2\\log n)~$的线性递推倍增算法优化，总时间复杂度为$~O(k^2\\log n+\\sqrt{p}\\log p)~$。注意线性递推部分是取模$~p-1~$。倍增算法部分还可以用模非质数的$~\\text{NTT}~$优化，总时间复杂度为$~O(k\\log k\\log n+\\sqrt{p}\\log p)~$。 代码（$~O(k^3\\log n+\\sqrt{p}\\log p)~$）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int root = 3;int base[100][100], power[100][100], tmp[100][100];inline int sub(const int&amp; a, const int&amp; b, const int&amp; p = mod) &#123;return a &lt; b ? a - b + p : a - b;&#125;inline int add(const int&amp; a, const int&amp; b, const int&amp; p = mod) &#123;return sub(a, p - b, p);&#125;inline int mul(const int&amp; a, const int&amp; b, const int&amp; p = mod) &#123;return 1LL * a * b % p;&#125;inline int fpow(int a, int n) &#123; int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;int bsgs(int n, int m) &#123; int sqr = sqrt(mod + 0.1); int inv = fpow(n, mod - 2); map&lt;int, int&gt; baby; for (int i = 0; i ^ sqr; ++i) &#123; baby[m] = i; m = mul(m, inv); &#125; n = fpow(n, sqr); int now = 1; for (int i = 0; i &lt;= sqr + 1; ++i) &#123; auto ite = baby.find(now); if (ite != baby.end()) return i * sqr + ite-&gt;second; now = mul(now, n); &#125; return -1;&#125;int get_root(int p) &#123; vector&lt;int&gt; factors; for (int i = 2, x = p - 1; true; ++i) &#123; if (!(x % i)) &#123; factors.push_back(i); while (!(x % i)) x /= i; &#125; if (1LL * i * i &gt; x) &#123; if (x ^ 1) factors.push_back(x); break; &#125; &#125; for (int ret = 1; true; ++ret) &#123; bool flag = true; for (auto f : factors) if (fpow(ret, (p - 1) / f) == 1) &#123; flag = false; break; &#125; if (flag) return ret; &#125; return -1;&#125;int exgcd(int a, int b, long long&amp; x, long long&amp; y) &#123; if (b) &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; return a ? (x = 1, y = 0, a) : -1;&#125;int power_mod(int n, int m, int p) &#123; int root = get_root(p); int y = bsgs(root, m); long long s = 0, t = 0; int d = exgcd(n, p - 1, s, t); if (y % d) return -1; if (s &lt; 0) s = s * y / d % (p - 1) * (2 - p) % (p - 1); else s = s * y / d % (p - 1); return fpow(root, s);&#125;void mul(int C[][100], int A[][100], int B[][100], int size) &#123; for (int i = 0; i ^ size; ++i) for (int j = 0; j ^ size; ++j) &#123; C[i][j] = 0; for (int k = 0; k ^ size; ++k) C[i][j] = add(C[i][j], mul(A[i][k], B[k][j], mod - 1), mod - 1); &#125;&#125;int main() &#123; int k, n, m; cin &gt;&gt; k; for (int i = 0; i ^ k; ++i) cin &gt;&gt; base[0][i], power[i][i] = 1; for (int i = 1; i ^ k; ++i) base[i][i - 1] = 1; cin &gt;&gt; n &gt;&gt; m; for (int t = n - k; t; t &gt;&gt;= 1) &#123; if (t &amp; 1) &#123; mul(tmp, power, base, k); memcpy(power, tmp, sizeof (power)); &#125; mul(tmp, base, base, k); memcpy(base, tmp, sizeof (base)); &#125; cout &lt;&lt; power_mod(power[0][0], m, mod) &lt;&lt; endl;&#125; 代码（$~O(k^2\\log n+\\sqrt{p}\\log p)~$）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;namespace BM &#123; typedef vector&lt;int&gt; vi; const int mod = 998244352; inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125; inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125; inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125; vi bm(vi&amp; c, long long n) &#123; int size = c.size(); if (size == 1) &#123; int ret = 1; for (int a = c.front(); n; n &gt;&gt;= 1) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); &#125; return vi(1, ret); &#125; vector&lt;vi&gt; base(size &lt;&lt; 1, vi(size, 0)), pow(64, vi(size, 0)); base[0][0] = 1; for (int i = 1; i ^ size &lt;&lt; 1; ++i) for (int j = 0; j ^ size; ++j) base[i][j] = add(mul(base[i - 1].back(), c[j]), j ? base[i - 1][j - 1] : 0); if (n &lt; (size &lt;&lt; 1)) return base[n]; pow[0][1] = 1; for (int i = 1; i ^ 64; ++i) &#123; vi tmp(size &lt;&lt; 1, 0); for (int j = 0; j ^ size; ++j) for (int k = 0; k ^ size; ++k) tmp[j + k] = add(tmp[j + k], mul(pow[i - 1][j], pow[i - 1][k])); for (int j = 0; j ^ size &lt;&lt; 1; ++j) for (int k = 0; k ^ size; ++k) pow[i][k] = add(pow[i][k], mul(tmp[j], base[j][k])); &#125; int index = 62; while ((1LL &lt;&lt; index) &gt; n) --index; vi ret = pow[index]; n ^= 1LL &lt;&lt; index; while (n) &#123; while ((1LL &lt;&lt; index) &gt; n) --index; n ^= 1LL &lt;&lt; index; vi tmp(size &lt;&lt; 1, 0); for (int i = 0; i ^ size; ++i) for (int j = 0; j ^ size; ++j) tmp[i + j] = add(tmp[i + j], mul(ret[i], pow[index][j])); fill(ret.begin(), ret.end(), 0); for (int i = 0; i ^ size &lt;&lt; 1; ++i) for (int j = 0; j ^ size; ++j) ret[j] = add(ret[j], mul(tmp[i], base[i][j])); &#125; return ret; &#125;&#125;const int mod = 998244353;const int root = 3;int base[100][100], power[100][100], tmp[100][100];inline int sub(const int&amp; a, const int&amp; b, const int&amp; p = mod) &#123;return a &lt; b ? a - b + p : a - b;&#125;inline int add(const int&amp; a, const int&amp; b, const int&amp; p = mod) &#123;return sub(a, p - b, p);&#125;inline int mul(const int&amp; a, const int&amp; b, const int&amp; p = mod) &#123;return 1LL * a * b % p;&#125;inline int fpow(int a, int n) &#123; int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;int bsgs(int n, int m) &#123; int sqr = sqrt(mod + 0.1); int inv = fpow(n, mod - 2); map&lt;int, int&gt; baby; for (int i = 0; i ^ sqr; ++i) &#123; baby[m] = i; m = mul(m, inv); &#125; n = fpow(n, sqr); int now = 1; for (int i = 0; i &lt;= sqr + 1; ++i) &#123; auto ite = baby.find(now); if (ite != baby.end()) return i * sqr + ite-&gt;second; now = mul(now, n); &#125; return -1;&#125;int get_root(int p) &#123; vector&lt;int&gt; factors; for (int i = 2, x = p - 1; true; ++i) &#123; if (!(x % i)) &#123; factors.push_back(i); while (!(x % i)) x /= i; &#125; if (1LL * i * i &gt; x) &#123; if (x ^ 1) factors.push_back(x); break; &#125; &#125; for (int ret = 1; true; ++ret) &#123; bool flag = true; for (auto f : factors) if (fpow(ret, (p - 1) / f) == 1) &#123; flag = false; break; &#125; if (flag) return ret; &#125; return -1;&#125;int exgcd(int a, int b, long long&amp; x, long long&amp; y) &#123; if (b) &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; return a ? (x = 1, y = 0, a) : -1;&#125;int power_mod(int n, int m, int p) &#123; int root = get_root(p); int y = bsgs(root, m); long long s = 0, t = 0; int d = exgcd(n, p - 1, s, t); if (y % d) return -1; if (s &lt; 0) s = s * y / d % (p - 1) * (2 - p) % (p - 1); else s = s * y / d % (p - 1); return fpow(root, s);&#125;void mul(int C[][100], int A[][100], int B[][100], int size) &#123; for (int i = 0; i ^ size; ++i) for (int j = 0; j ^ size; ++j) &#123; C[i][j] = 0; for (int k = 0; k ^ size; ++k) C[i][j] = add(C[i][j], mul(A[i][k], B[k][j], mod - 1), mod - 1); &#125;&#125;int main() &#123; int k, n, m; cin &gt;&gt; k; for (int i = 0; i ^ k; ++i) cin &gt;&gt; base[0][i], power[i][i] = 1; vector&lt;int&gt; vec; for (int i = k - 1; ~i; --i) vec.push_back(base[0][i]); for (int i = 1; i ^ k; ++i) base[i][i - 1] = 1; cin &gt;&gt; n &gt;&gt; m; vec = BM::bm(vec, n - 1); cout &lt;&lt; power_mod(vec.back(), m, mod) &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 534 (Div. 2)","slug":"Codeforces Round 534 (Div. 2)","date":"2019-02-13T15:11:35.224Z","updated":"2019-02-13T15:11:42.876Z","comments":true,"path":"2019/02/13/Codeforces Round 534 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/02/13/Codeforces Round 534 (Div. 2)/","excerpt":"","text":"Codeforces Round #534 (Div. 2) A. Splitting into digits题目大意水题。 题解水题。 代码12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; n &lt;&lt; endl; while (--n) cout &lt;&lt; 1 &lt;&lt; ' '; cout &lt;&lt; 1 &lt;&lt; endl;&#125; B. Game with string题目大意类似祖玛，两人轮流选择两个一样的相邻字符从字符串中消除，不能操作则失败。 题解模拟。一个字符串的可操作次数是固定的且与操作顺序无关。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; vector&lt;char&gt; chs; int cnt = 0; for (auto ch : str) &#123; if (!chs.empty() &amp;&amp; chs.back() == ch) &#123; ++cnt; chs.pop_back(); &#125; else &#123; chs.push_back(ch); &#125; &#125; if (cnt &amp; 1) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;&#125; C. Grid game题目大意一个$~4\\times4~$的大正方形内要放入若干$~1\\times2~$和$~2\\times1~$的小长方形，不能重叠，但是如果某行或者某列被占满则改行或者该列被清空。现给出小长方形的出现顺序，输出一种可行的放置方案。 题解前$~2~$排专门放竖的，第$~3~$排专门放横的即可。 代码12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; int a = 1, b = 1; for (auto ch : str) &#123; if (ch == '0') &#123; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; a++ &lt;&lt; endl; if (a == 5) a = 1; &#125; else &#123; cout &lt;&lt; 3 &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl; if (b == 1) b = 3; else b = 1; &#125; &#125;&#125; D. Game with modulo题目大意交互题。有个未知数$~a~$，每次只能询问一对数$~(x,~y)~$，如果在模$~a~$意义下满足$~x\\geq y~$，则返回$~x~$，否则返回$~y~$。在至多$~60~$次查询内确定$~a~$的大小。数据范围$~1\\leq a\\leq10^9~$。 题解倍增。如果有$~a&gt;x~$，则通过询问$~(x,~2x)~$得到$~a~$与$~2x~$的大小关系。所以在$~30~$次询问内，可以确认$~a=1~$或者$~a\\in(2^i,~2^{i+1}],~i\\in[0,~30)~$。对于$~a\\in(x,~y]~$，运用同样的思想，询问$~(x,~\\frac{x+y}{2})~$，可以确认$~a~$与$~\\frac{x+y}{2}~$的关系。于是再用至多$~30~$次询问即可得出答案。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;inline bool game() &#123; string str; cin &gt;&gt; str; return str == \"start\";&#125;inline bool query(const int&amp; x, const int&amp; y) &#123; cout &lt;&lt; \"? \" &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; char ch; cin &gt;&gt; ch; return ch == 'y';&#125;inline void solve(const int&amp; res) &#123;cout &lt;&lt; \"! \" &lt;&lt; res &lt;&lt; endl;&#125;int main() &#123; while (game()) &#123; int now = 1; while (query(now, now &lt;&lt; 1)) now &lt;&lt;= 1; if (now == 1) &#123; solve(query(2, 3) ? 2 : 1); continue; &#125; int left = now, right = now &lt;&lt; 1; while (right - left ^ 1) &#123; int mid = left + right &gt;&gt; 1; if (query(left, mid)) left = mid; else right = mid; &#125; solve(right); &#125;&#125; E. Johnny Solving题目大意给定一个$~n~$个点的简单连通图，且每个点的度数至少为$~3~$。再给出一个不大于$~n~$的正整数$~k~$。要求输出一条长度不小于$~\\frac{n}{k}~$的简单路径或者$~k~$个长度不是$~3~$的倍数的环，且每个环有个代表点，代表点不能再其他环内。 题解考虑$~\\text{DFS}~$生成树。如果有点的深度不小于$~\\frac{n}{k}~$，那么可以直接构造出简单路径。否则这棵树必有至少$~k~$个叶节点。考虑每个叶节点，由于每个点的度数至少为$~3~$且根据$~\\text{DFS}~$生成树的性质，这个叶节点必有至少$~2~$条边连向不同的非父亲祖先。这样每个叶节点可以找到$~3~$个环，可以自行证明必存在长度不是$~3~$的倍数的环。此时该叶节点也满足代表元性质，构造完毕。所有过程均为线性，不过我的代码不知道为什么不加剪枝会$~\\text{TLE}~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 18;vector&lt;int&gt; adj[maxn];bool vis[maxn];int fa[maxn], dep[maxn], n, m, k;vector&lt;vector&lt;int&gt;&gt; cycles;void dfs(int u, int d) &#123; vis[u] = true; if ((dep[u] = d) &gt; (n - 1) / k) &#123; cout &lt;&lt; \"PATH\\n\" &lt;&lt; d &lt;&lt; '\\n' &lt;&lt; u; for (int i = fa[u]; i; i = fa[i]) cout &lt;&lt; ' ' &lt;&lt; i; cout &lt;&lt; '\\n'; exit(0); &#125; bool flag = true; for (auto v : adj[u]) if (!vis[v]) &#123; fa[v] = u; dfs(v, d + 1); flag = false; &#125; while (flag) &#123; int index = 0; if (adj[u][index] == fa[u]) ++index; int x = adj[u][index++]; if (adj[u][index] == fa[u]) ++index; int y = adj[u][index]; vector&lt;int&gt; loop(1, u); while (loop.back() ^ x) loop.push_back(fa[loop.back()]); if (loop.size() % 3) &#123; cycles.push_back(loop); break; &#125; loop = vector&lt;int&gt;(1, u); while (loop.back() ^ y) loop.push_back(fa[loop.back()]); if (loop.size() % 3) &#123; cycles.push_back(loop); break; &#125; loop = vector&lt;int&gt;(1, u); if (dep[x] &lt; dep[y]) swap(x, y); loop.push_back(x); while (loop.back() ^ y) loop.push_back(fa[loop.back()]); cycles.push_back(loop); break; &#125; if (cycles.size() == k) &#123; cout &lt;&lt; \"CYCLES\\n\"; for (auto&amp; loop : cycles) &#123; cout &lt;&lt; loop.size() &lt;&lt; '\\n' &lt;&lt; loop.front(); for (int i = 1; i ^ loop.size(); ++i) cout &lt;&lt; ' ' &lt;&lt; loop[i]; cout &lt;&lt; '\\n'; &#125; exit(0); &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; dfs(1, 1);&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"CodeCraft-19 and Codeforces Round 537 (Div. 2)","slug":"CodeCraft-19 and Codeforces Round 537 (Div. 2)","date":"2019-02-11T13:15:42.885Z","updated":"2019-02-13T14:27:29.256Z","comments":true,"path":"2019/02/11/CodeCraft-19 and Codeforces Round 537 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/02/11/CodeCraft-19 and Codeforces Round 537 (Div. 2)/","excerpt":"","text":"CodeCraft-19 and Codeforces Round #537 (Div. 2) A. Superhero Transformation题目大意水题。 题解水题。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int check[128] = &#123;0&#125;; check['a'] = check['e'] = check['i'] = check['o'] = check['u'] = 1; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; if (s1.size() ^ s2.size()) return cout &lt;&lt; \"No\" &lt;&lt; endl, 0; for (int i = 0; i ^ s1.size(); ++i) if (check[s1[i]] ^ check[s2[i]]) return cout &lt;&lt; \"No\" &lt;&lt; endl, 0; cout &lt;&lt; \"Yes\" &lt;&lt; endl;&#125; B. Average Superhero Gang Power题目大意给顶一个序列，最多可以操作$~k~$次，或者移除一个元素，或者是一个元素加$~1~$，且每个元素至多操作$~m~$次。输出该序列最后平均数的最大值。 题解水题。排序后暴力枚举移除操作的次数即可。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;long long a[maxn], pre[maxn];int main() &#123; int n, k, m; scanf(\"%d%d%d\", &amp;n, &amp;k, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); sort(a, a + n + 1); for (int i = 1; i &lt;= n; ++i) pre[i] = pre[i - 1] + a[i]; double res = 0; for (int i = 0; i ^ min(n, m + 1); ++i) res = max(res, 1.0 * (pre[n] - pre[i] + min(1LL * (n - i) * k, 1LL * (m - i))) / (n - i)); printf(\"%f\\n\", res);&#125; C. Creative Snap题目大意需要处理一整段长度为$~2^n~$的数轴，数轴上有$~k~$个物品。对于每个区间可以选择二等分后分别处理或者直接处理。处理区间时，如果区间上有物品，则需要花费$~B\\cdot n_a\\cdot l$，其中$~n_a~$和$~l~$分别是该区间物品数量和长度。否则处理空区间的花费为$~A~$。问最小总花费。数据范围$~1\\leq n\\leq30,~1\\leq k\\leq10^5~$。 题解直接根据题意递归处理即可。考虑一棵完整的线段树，它有$~2^{n+1}~$个节点。但是注意到对于空区间的节点，其子树是不需要考虑的。且最后一层只有$~k~$个非空节点，所以所有需要经过的节点是$~O(nk)~$级别的。对于区间内的数量，可以用$~\\text{lower_bound}~$或$~\\text{upper_bound}~$来计算，总时间复杂度为$~O(nk\\log k)~$。当然你想写线段树动态开点也不是不可以。 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int n, k;long long A, B;vector&lt;int&gt; a;long long solve(int begin, int end) &#123; int size = upper_bound(a.begin(), a.end(), end) - upper_bound(a.begin(), a.end(), begin); if (!size) return A; long long ret = B * size * (end - begin); if (begin + 1 ^ end) ret = min(ret, solve(begin, begin + end &gt;&gt; 1) + solve(begin + end &gt;&gt; 1, end)); return ret;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k &gt;&gt; A &gt;&gt; B; a.resize(k); for (auto&amp; in : a) cin &gt;&gt; in; sort(a.begin(), a.end()); cout &lt;&lt; solve(0, 1 &lt;&lt; n) &lt;&lt; endl;&#125; D. Destroy the Colony题目大意给定一个偶数长度的大小写字符串和$~q~$次询问。每次询问输出有多少种字符串的重排列满足所有一样的字母在同侧且$~x~$和$~y~$位置上的字母也在同侧。数据范围$~1\\leq n\\leq10^5,~1\\leq q\\leq10^5~$。 题解先考虑存在性，则存在一种字母的二划分使得每个划分下的数量总和均为$~\\frac{n}{2}~$。设划分为 \\{a_1,~a_2,~\\dots,~a_k\\}=\\{b_1,~b_2,~\\dots,~b_s,~c_1,~c_2,~\\dots,~c_t\\} \\\\ \\sum_{i=1}^{s}b_i=\\sum_{i=1}^{t}c_i={\\frac{n}{2}}那么这种满足这种划分的重排列数量为 \\frac{(\\frac{n}{2})!}{\\prod_{i=1}^{s}(b_i)!}\\cdot\\frac{(\\frac{n}{2})!}{\\prod_{i=1}^{t}(c_i)!}=\\frac{((\\frac{n}{2})!)^2}{\\prod_{i=1}^{k}(a_i)!}那么只需要考虑有多少种合法的划分方案。注意到最多只有$~52~$种不一样的字母，即$~k\\leq52~$。那么可以用一个$~O(nk)~$的动态规划来算出对于任意$~0\\leq i\\leq n~$，有多少种子集的和为$~i~$。最后考虑询问，这相当于把某对$~a_i~$和$~a_j~$合并后计算，共$~\\binom{k}{2}~$种组合如果每种情况分别动态规划，预处理的时间复杂度为$~O(nk^3)~$，显然会$~\\text{TLE}~$。注意到每次动态规划的元素大部分是相同的，于是可以考虑可持久化动态规划的做法，在基于$~{a_1,~a_2,~\\dots,~a_k}~$的基础上删除$~a_i~$和$~a_j~$。这样每种组合的动态规划时间复杂度为$~O(n)~$，总时间复杂度为$~O(nk^2+q)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;int inv[maxn], fact[maxn], finv[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;void init(int n = maxn) &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ n; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125;&#125;int main() &#123; init(); string str; cin &gt;&gt; str; int size = str.size(); map&lt;char, int&gt; cnt; for (auto ch : str) ++cnt[ch]; vector&lt;int&gt; a, p(128, -1), dp(size + 1, 0); for (auto now : cnt) &#123; p[now.first] = a.size(); a.push_back(now.second); &#125; int base = mul(fact[size &gt;&gt; 1], fact[size &gt;&gt; 1]); dp[0] = 1; for (auto x : a) &#123; base = mul(base, finv[x]); for (int i = size; i &gt;= x; --i) dp[i] = add(dp[i], dp[i - x]); &#125; int res = mul(dp[size &gt;&gt; 1], base); int cal[52][52]; for (int i = 0; i ^ a.size(); ++i) for (int j = i + 1; j ^ a.size(); ++j) &#123; for (int k = a[i]; k &lt;= size; ++k) dp[k] = sub(dp[k], dp[k - a[i]]); for (int k = a[j]; k &lt;= size; ++k) dp[k] = sub(dp[k], dp[k - a[j]]); cal[i][j] = mul(add(dp[size &gt;&gt; 1], dp[size &gt;&gt; 1]), base); for (int k = size; k &gt;= a[i]; --k) dp[k] = add(dp[k], dp[k - a[i]]); for (int k = size; k &gt;= a[j]; --k) dp[k] = add(dp[k], dp[k - a[j]]); &#125; int q; cin &gt;&gt; q; while (q--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; x = p[str[x - 1]]; y = p[str[y - 1]]; if (x &gt; y) swap(x, y); if (x == y) cout &lt;&lt; res &lt;&lt; endl; else cout &lt;&lt; cal[x][y] &lt;&lt; endl; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 538 (Div. 2)","slug":"Codeforces Round 538 (Div. 2)","date":"2019-02-11T11:49:37.328Z","updated":"2019-02-13T14:25:30.110Z","comments":true,"path":"2019/02/11/Codeforces Round 538 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/02/11/Codeforces Round 538 (Div. 2)/","excerpt":"","text":"Codeforces Round #538 (Div. 2) A. Got Any Grapes?题目大意水题。 题解水题。 代码123456789#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int x, y, z, a, b, c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (a &lt; x || a + b &lt; x + y || a + b + c &lt; x + y + z) cout &lt;&lt; \"NO\" &lt;&lt; endl; else cout &lt;&lt; \"YES\" &lt;&lt; endl;&#125; B. Yet Another Array Partitioning Task题目大意定义一个序列的$~\\text{beauty}~$值为前$~m~$大的数值之和。现给定一个大序列，要求划分成$~k~$个连续的序列使得这$~k~$个序列的$~\\text{beauty}~$值总和最大，并输出划分的方案。 题解水题。原序列前$~mk~$大的数值之和就是最大值。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; vector&lt;pair&lt;int, int&gt;&gt; a(n); vector&lt;bool&gt; use(n); for (int i = 0; i ^ n; ++i) cin &gt;&gt; a[i].first, a[i].second = i; sort(a.begin(), a.end()); long long res = 0; for (int i = n - m * k; i ^ n; ++i) res += a[i].first, use[a[i].second] = true; int cnt = 0, tot = 0; cout &lt;&lt; res &lt;&lt; endl; for (int i = 0; i ^ n; ++i) if (use[i] &amp;&amp; ++cnt == m) &#123; cnt = 0; if (++tot == k) cout &lt;&lt; endl; else cout &lt;&lt; i + 1 &lt;&lt; ' '; &#125;&#125; C. Trailing Loves (or L’oeufs?)题目大意问数字$~n!~$在$~b~$进制下有多少个末尾$~0~$。 题解因式分解$~b~$后对所有质数计算$~n!~$中的幂指数。公式 f(n,~p)=\\sum_{i=1}^{\\infty}\\left\\lfloor\\frac{n}{p^i}\\right\\rfloor代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; long long n, b; cin &gt;&gt; n &gt;&gt; b; vector&lt;pair&lt;long long, int&gt;&gt; factors; for (long long p = 2; true; ++p) &#123; if (!(b % p)) &#123; int cnt; for (cnt = 0; !(b % p); ++cnt) b /= p; factors.push_back(make_pair(p, cnt)); &#125; if (p * p &gt; b) &#123; if (b ^ 1) factors.push_back(make_pair(b, 1)); break; &#125; &#125; long long res = 0x7fffffffffffffff; for (auto f : factors) &#123; long long temp = 0; for (long long x = n; x; x /= f.first) temp += x / f.first; res = min(res, temp / f.second); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. Flood Fill题目大意给定一个序列，选择一个起点，每次操作可以将包含起点的等值联通块全部改变为另一数值。问最少操作次数使得序列全部一样。数据范围$~1\\leq n\\leq5000~$。 题解首先对相邻等值的元素去重，于是每次操作可以使得包含起点的等值联通块大小增加$~1~$或者$~2~$。如果能增加$~2~$，说明存在$~2~$个一样的元素在起点的左右。于是只要找到最长回文子序列即可，这是一个区间$~\\text{DP}~$问题，具体实现见代码。时间复杂度为$~O(n^2)~$。 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; str; while (n--) &#123; int c; cin &gt;&gt; c; if (str.empty() || str.back() ^ c) str.push_back(c); &#125; int size = str.size(); vector&lt;vector&lt;int&gt;&gt; dp(size, vector&lt;int&gt;(size, 1)); for (int d = 2; d &lt; size; ++d) for (int l = 0; l + d ^ size; ++l) &#123; if (str[l] ^ str[l + d]) dp[l][l + d] = max(dp[l][l + d - 1], dp[l + 1][l + d]); else dp[l][l + d] = dp[l + 1][l + d - 1] + 2; &#125; cout &lt;&lt; size - 1 - (dp[0][size - 1] &gt;&gt; 1) &lt;&lt; endl;&#125; E. Arithmetic Progression题目大意交互题。现有一个乱序的等差数列，可以有两种询问：问是否存在一个数严格大于$~x~$，或者问第$~i~$个数的值。询问次数不超过$~60~$次，然后输出首项和公差。数据范围$~2\\leq n\\leq10^6~$。 题解通过二分可以在$~30~$次询问内找出最大值也就是末项。然后随机询问$~30~$个数值后与末项的差取$~\\gcd~$。算出的答案为真实的公差的概率等于$~n~$以内随机$~30~$个数互质的概率。注意代码实现尽量接近真正的随机，详见博客链接。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;mt19937 rand_fuck(chrono::steady_clock::now().time_since_epoch().count());int main() &#123; int n; cin &gt;&gt; n; int left = 0, right = 1e9, rem = 60; while (right - left ^ 1) &#123; --rem; int mid = left + right &gt;&gt; 1; cout &lt;&lt; \"&gt; \" &lt;&lt; mid &lt;&lt; endl; int in; cin &gt;&gt; in; if (in) left = mid; else right = mid; &#125; vector&lt;int&gt; p(n); iota(p.begin(), p.end(), 1); shuffle(p.begin(), p.end(), rand_fuck); rem = min(rem, n); int d = 0; for (int i = 0; i ^ rem; ++i) &#123; cout &lt;&lt; \"? \" &lt;&lt; p[i] &lt;&lt; endl; int in; cin &gt;&gt; in; d = __gcd(d, right - in); &#125; cout &lt;&lt; \"! \" &lt;&lt; right - (n - 1) * d &lt;&lt; ' ' &lt;&lt; d &lt;&lt; endl;&#125; F. Please, another Queries on Array?题目大意对序列区间乘以$~x~$或查询区间乘积的欧拉函数值。数据范围$~1\\leq n\\leq4\\cdot10^5,~1\\leq q\\leq2\\cdot10^5,~1\\leq a\\leq300,~1\\leq x\\leq300~$。 题解欧拉函数$~\\varphi(n)~$的定义为小于$~n~$且与$~n~$互质的正整数的数量，是个积性函数。对于$~n~$的所有质因子$~p~$，有如下公式 \\varphi(n)=n\\prod_{p\\mid n}\\frac{p-1}{p}对于乘积的操作可以用一棵区间乘法线段树完成，建树的时间复杂度为$~O(n)~$，单次修改操作或查询的时间复杂度为$~O(\\log^2n)~$。注意到$~x~$和$~a~$的数据范围，可以先预处理出所有可能的质数，事实上只有至多$~62~$个质数。那么对于线段树上的每一个节点，可以用一个$~64~$位的数据类型来储存状态压缩过后的质因子表。总时间复杂度为$~O(n+q\\cdot(\\log^2n+62))~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int fpow(int a, int n) &#123; int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;const int maxn = 1 &lt;&lt; 19;int a[maxn], euler[maxn];long long prime[301], mask;struct Node &#123; int cal, cal_; long long mask, mask_; void tage(const int&amp; x, const long long&amp; p) &#123; cal_ = mul(cal_, x); mask_ |= p; &#125; void calc(const int&amp; n) &#123; cal = mul(cal, fpow(cal_, n)); mask |= mask_; cal_ = 1; mask_ = 0; &#125;&#125; seg[maxn &lt;&lt; 1];#define lson (index &lt;&lt; 1)#define rson (index &lt;&lt; 1 ^ 1)#define mid (begin + end &gt;&gt; 1)void build(int begin, int end, int index) &#123; if (begin ^ mid) &#123; build(begin, mid, lson); build(mid, end, rson); seg[index].cal = mul(seg[lson].cal, seg[rson].cal); seg[index].mask = seg[lson].mask | seg[rson].mask; &#125; else &#123; seg[index].mask = prime[seg[index].cal = a[end]]; &#125; seg[index].cal_ = 1;&#125;void modify(int begin, int end, int index, int left, int right, int x) &#123; if (begin &gt;= left &amp;&amp; end &lt;= right) &#123; seg[index].tage(x, prime[x]); return; &#125; else &#123; seg[index].cal = mul(seg[index].cal, fpow(x, min(end, right) - max(begin, left))); seg[index].mask |= prime[x]; &#125; if (left &lt; mid) modify(begin, mid, lson, left, right, x); if (right &gt; mid) modify(mid, end, rson, left, right, x);&#125;int query(int begin, int end, int index, int left, int right) &#123; if (seg[index].mask_) &#123; if (begin ^ mid) &#123; seg[lson].tage(seg[index].cal_, seg[index].mask_); seg[rson].tage(seg[index].cal_, seg[index].mask_); &#125; seg[index].calc(end - begin); &#125; if (begin &gt;= left &amp;&amp; end &lt;= right) return mask |= seg[index].mask, seg[index].cal; if (end &lt;= left || begin &gt;= right) return 1; return mul(query(begin, mid, lson, left, right), query(mid, end, rson, left, right));&#125;int main() &#123; for (int i = 2, cnt = 0; i &lt;= 300; ++i) if (!prime[i]) &#123; for (int j = i; j &lt;= 300; j += i) prime[j] ^= 1LL &lt;&lt; cnt; euler[cnt++] = mul(i - 1, fpow(i, mod - 2)); &#125; int n, q; cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; build(0, n, 1); while (q--) &#123; string str; cin &gt;&gt; str; if (str.front() == 'M') &#123; int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; modify(0, n, 1, l - 1, r, x); &#125; else &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; mask = 0; int res = query(0, n, 1, l - 1, r); for (int i = 0; i ^ 62; ++i) if (mask &amp; 1LL &lt;&lt; i) res = mul(res, euler[i]); cout &lt;&lt; res &lt;&lt; '\\n'; &#125; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"最长单调子序列","slug":"最长单调子序列","date":"2019-01-18T06:48:52.987Z","updated":"2019-05-29T15:59:10.427Z","comments":true,"path":"2019/01/18/最长单调子序列/","link":"","permalink":"http://yoursite.com/2019/01/18/最长单调子序列/","excerpt":"","text":"最长上升子序列$~\\text{LIS}~$朴素算法动态规划，令$~dp_i~$表示以$~a_i~$结尾的$~\\text{LIS}~$的长度，则有状态转移式 dp_i=\\max\\lbrace~dp_j:~j< i,~a_j< a_i~\\rbrace+1这样的时间复杂度显然是$~O(n^2)~$。 123456789template&lt;typename T&gt;size_t lis(const vector&lt;T&gt;&amp; a) &#123; vector&lt;size_t&gt; dp(a.size()); for (size_t i = 0; i != a.size(); ++i) &#123; for (size_t j = 0; j != i; ++j) if (a[i] &gt;= a[j]) dp[i] = max(dp[i], dp[j]); ++dp[i]; &#125; return *max_element(dp.begin(), dp.end());&#125; 优化算法考虑集合$~S_k=\\lbrace~i:~dp_i=k~\\rbrace~$，它有这样的性质：对任意$~i\\neq j\\in S_k~$，如果$~i&lt; j~$，则必有$~a_i\\geq a_j~$。这是因为如果$~a_i&lt; a_j~$，那么$~dp_j\\geq dp_i+1~$，得出$~j\\not\\in S_k~$矛盾。设$~p_k=\\max S_k~$，这里规定如果$~S_k=\\varnothing~$，则$~p_k~$不存在。这样的序列$~p~$也有性质：对任意$~p_i,p_j~$存在，如果$~i&lt; j~$，则必有$~a_{p_i}&lt; a_{p_j}~$。考虑$~p_j\\in S_j~$，于是有前缀$~a_1,a_2,\\dots,a_{p_j}~$以$~a_{p_j}~$结尾的$~\\text{LIS}~$的长度为$~j~$。设这个$~\\text{LIS}~$的第$~i~$项的角标为$~q~$，显然$~q\\in S_i~$。于是$~p_i=\\max S_i\\geq q~$，结合之前的性质有$~a_{p_i}\\leq a_q&lt; a_{p_j}~$。考虑动态规划同时维护序列$~p~$，于是在状态转移的过程中，由前面第一个性质，只需要考虑$~dp_i~$从$~dp_{p_1},dp_{p_2},\\dots,dp_{p_k}~$转移。注意到第二个性质的单调性，可以通过二分找到$~p_j~$，满足$~a_{p_j}&lt; a_i~$，且$~j=k~$或$~a_{p_{j+1}}\\geq a_i~$。然后用$~i~$更新$~p_{j+1}~$。可以发现根本不需要维护$~dp~$，只需要维护$~p~$即可，最后序列$~p~$的长度就是$~\\text{LIS}~$的长度。因为二分，时间复杂度为$~O(n\\log n)~$。 1234567891011template&lt;typename T&gt;auto lis(const vector&lt;T&gt;&amp; a) &#123; vector&lt;size_t&gt; p; for (size_t i = 0; i != a.size(); ++i) &#123; auto cmp = [&amp;a] (const size_t&amp; x, const size_t&amp; y) &#123; return a[x] &lt; a[y]; &#125;; auto ite = lower_bound(p.begin(), p.end(), i, cmp); if (ite == p.end()) p.emplace_back(i); else *ite = i; &#125; return p.size();&#125; 对每次转移记忆化，可以得到一个$~\\text{LIS}~$的角标。 1234567891011121314151617template&lt;typename T&gt;auto lis(const vector&lt;T&gt;&amp; a) &#123; vector&lt;size_t&gt; p, from(a.size()), ret; if (a.empty()) return ret; for (size_t i = 0; i != a.size(); ++i) &#123; auto cmp = [&amp;a] (const size_t&amp; x, const size_t&amp; y) &#123; return a[x] &lt; a[y]; &#125;; auto ite = lower_bound(p.begin(), p.end(), i, cmp); if (ite == p.begin()) from[i] = -1; else from[i] = *prev(ite); if (ite == p.end()) p.emplace_back(i); else *ite = i; &#125; ret.emplace_back(p.back()); while (~from[ret.back()]) ret.emplace_back(from[ret.back()]); reverse(ret.begin(), ret.end()); return ret;&#125; Dilworth定理序列$~a_1,a_2,\\dots,a_n~$的不增子序列最小划分数等于最长上升子序列长度。 证明设序列$~a~$的不增子序列最小划分数为$~k~$，最长上升子序列长度为$~m~$。任取一条最长上升子序列$~b_1,~b_2,~\\dots,~b_m~$，则它们之中任意两个必然不在同一不增子序列划分中，所以必有$~k\\geq m~$。下面构造$~a~$的不增子序列$~m~$划分。在计算$~m~$的过程中，序列$~p~$的每一次更新都必然满足$~p_j~$不存在或者$~a_{p_j}\\geq a_i~$，那么$~p_j~$的更新链恰好构成$~a~$的一条不增子序列。而$~{\\mid p\\mid}=m~$，也就是说$~p~$有$~m~$条不交的更新链，它们恰好构成$~a~$的一个不增子序列$~m~$划分。于是$~k=m~$。 模板用角标记录，返回最长严格单增子序列和非严格单减子序列划分。 12345678910111213141516171819template&lt;typename T&gt;auto exlis(const vector&lt;T&gt;&amp; a) &#123; vector&lt;size_t&gt; from(a.size()), lis; vector&lt;vector&lt;size_t&gt;&gt; snisp; for (size_t i = 0; i != a.size(); ++i) &#123; auto cmp = [&amp;a] (const vector&lt;size_t&gt;&amp; x, const vector&lt;size_t&gt;&amp; y) &#123; return a[x.back()] &lt; a[y.back()]; &#125;; auto ite = lower_bound(snisp.begin(), snisp.end(), vector&lt;size_t&gt;(1, i), cmp); if (ite == snisp.begin()) from[i] = -1; else from[i] = prev(ite)-&gt;back(); if (ite == snisp.end()) snisp.emplace_back(1, i); else ite-&gt;emplace_back(i); &#125; lis.emplace_back(snisp.back().back()); while (~from[lis.back()]) lis.emplace_back(from[lis.back()]); reverse(lis.begin(), lis.end()); return make_pair(lis, snisp);&#125; 鬼畜版本，返回迭代器。 123456789101112131415161718192021222324252627282930313233template&lt;class Ite&gt;auto exlis(Ite first, Ite last) &#123; auto cmp = [] (const vector&lt;Ite&gt;&amp; v1, const vector&lt;Ite&gt;&amp; v2) &#123; return *v1.back() &lt; *v2.back(); &#125;; /// &lt; or &gt; for increasing or decreasing vector&lt;vector&lt;Ite&gt;&gt; snisp, from; while (first != last) &#123; vector&lt;Ite&gt; cur(1, first); auto ite = lower_bound(snisp.begin(), snisp.end(), cur, cmp); /// lower_bound or upper_bound for strictly or unstrictly auto tmp = ite == snisp.begin() ? last : prev(ite)-&gt;back(); if (ite == snisp.end()) &#123; snisp.emplace_back(cur); from.emplace_back(1, tmp); &#125; else &#123; ite-&gt;emplace_back(first); from.at(ite - snisp.begin()).emplace_back(tmp); &#125; ++first; &#125; vector&lt;Ite&gt; lis; auto mirr(snisp); while (true) &#123; lis.emplace_back(mirr.back().back()); mirr.pop_back(); if (mirr.empty()) break; while (mirr.back().back() != from.back().back()) mirr.back().pop_back(); from.pop_back(); while (mirr.back().size() != from.back().size()) from.back().pop_back(); &#125; reverse(lis.begin(), lis.end()); return make_pair(lis, snisp);&#125; 题目CF1097E代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;auto exlis(const vector&lt;T&gt;&amp; a) &#123; vector&lt;size_t&gt; from(a.size()), lis; vector&lt;vector&lt;size_t&gt;&gt; snisp; for (size_t i = 0; i != a.size(); ++i) &#123; auto cmp = [&amp;a] (const vector&lt;size_t&gt;&amp; x, const vector&lt;size_t&gt;&amp; y) &#123; return a[x.back()] &lt; a[y.back()]; &#125;; auto ite = lower_bound(snisp.begin(), snisp.end(), vector&lt;size_t&gt;(1, i), cmp); if (ite == snisp.begin()) from[i] = -1; else from[i] = prev(ite)-&gt;back(); if (ite == snisp.end()) snisp.emplace_back(1, i); else ite-&gt;emplace_back(i); &#125; lis.emplace_back(snisp.back().back()); while (~from[lis.back()]) lis.emplace_back(from[lis.back()]); reverse(lis.begin(), lis.end()); return make_pair(lis, snisp);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #define endl '\\n' const size_t maxn = 100000; vector&lt;size_t&gt; f; for (size_t i = 0; f.size() &lt;= maxn; ++i) for (size_t j = i; ~j; --j) f.emplace_back(i); size_t T; cin &gt;&gt; T; while (T--) &#123; size_t n; cin &gt;&gt; n; vector&lt;size_t&gt; a(n); vector&lt;vector&lt;size_t&gt;&gt; res; for (auto&amp; aa : a) cin &gt;&gt; aa; while (!a.empty()) &#123; auto tmp = exlis(a); if (tmp.first.size() &gt; f[a.size()]) &#123; vector&lt;size_t&gt; lis; for (const auto&amp; x : tmp.first) lis.emplace_back(a[x]); res.emplace_back(lis); auto ite = tmp.first.begin(); vector&lt;size_t&gt; b; for (size_t i = 0; i != a.size(); ++i) &#123; if (ite != tmp.first.end() &amp;&amp; *ite == i) ++ite; else b.emplace_back(a[i]); &#125; swap(a, b); &#125; else &#123; for (const auto&amp; vec : tmp.second) &#123; vector&lt;size_t&gt; nis; for (const size_t&amp; i : vec) nis.emplace_back(a[i]); res.emplace_back(nis); &#125; a.clear(); &#125; &#125; cout &lt;&lt; res.size() &lt;&lt; endl; for (const auto&amp; vec : res) &#123; cout &lt;&lt; vec.size(); for (const auto&amp; ans : vec) cout &lt;&lt; ' ' &lt;&lt; ans; cout &lt;&lt; endl; &#125; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"LIS","slug":"LIS","permalink":"http://yoursite.com/tags/LIS/"}]},{"title":"Hello 2019 (TBC)","slug":"Hello 2019 (TBC)","date":"2019-01-17T14:07:58.065Z","updated":"2019-02-11T16:21:52.398Z","comments":true,"path":"2019/01/17/Hello 2019 (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Hello 2019 (TBC)/","excerpt":"","text":"Hello 2019 A. Gennady and a Card Game题目大意给$~1~$张匹配扑克牌和$~5~$张手牌，判断是否存在$~1~$张手牌的花色或者数值和匹配牌一样。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str, hand; cin &gt;&gt; str; for (int i = 0; i ^ 5; ++i) &#123; cin &gt;&gt; hand; if (str.front() == hand.front() || str.back() == hand.back()) return cout &lt;&lt; \"YES\" &lt;&lt; endl, 0; &#125; cout &lt;&lt; \"NO\" &lt;&lt; endl;&#125; B. Petr and a Combination Lock题目大意一个$~360^\\circ~$的刻度盘，指针初始在$~0^\\circ~$处。给定每次旋转的度数$~a_1,~a_2,~\\dots,~a_n~$，但是旋转方向不定，判断是否存在一种旋转方式使得最后指针回到$~0^\\circ~$。数据范围$~1\\leq n\\leq15,~1\\leq a\\leq180~$。 题解爆搜即可。时间复杂度为$~O(2^n)~$。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; for (int i = 0; i ^ 1 &lt;&lt; n; ++i) &#123; int sum = 0; for (int j = 0; j ^ n; ++j) sum += i &amp; 1 &lt;&lt; j ? a[j] : 360 - a[j]; if (sum % 360 == 0) return cout &lt;&lt; \"YES\" &lt;&lt; endl, 0; &#125; cout &lt;&lt; \"NO\" &lt;&lt; endl;&#125; C. Yuhao and a Parenthesis题目大意给$~n~$个括号串，问最多多少括号穿有序对连在一起合法，每个串至多使用一次。 题解经典合法括号串问题。合法性考虑前缀和即可。 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;int&gt; cnt1(1 &lt;&lt; 19, 0), cnt2(1 &lt;&lt; 19, 0); int n; cin &gt;&gt; n; int res = 0; while (n--) &#123; string str; cin &gt;&gt; str; int pre = 0; bool flag = true; for (auto ch : str) &#123; ch == '(' ? ++pre : --pre; if (pre &lt; 0) flag = false; &#125; if (flag) &#123; if (pre) ++cnt1[pre]; else ++res; continue; &#125; int suf = -pre; for (auto ch : str) &#123; ch == ')' ? ++pre : --pre; if (pre &gt; 0) break; &#125; if (!pre) ++cnt2[suf]; &#125; res &gt;&gt;= 1; for (int i = 1; i ^ 1 &lt;&lt; 19; ++i) res += min(cnt1[i], cnt2[i]); cout &lt;&lt; res &lt;&lt; endl;&#125; D. Makoto and a Blackboard题目大意定义一种操作，对任何正整数$~x~$，它会等概率随机变为它的一个因子。现给两个数字$~n~$和$~k~$，问$~n~$经过$~k~$次操作后所得到的期望。数据范围$~1\\leq n\\leq10^{15},~1\\leq k\\leq10^4~$。 题解令$~\\xi(x,~y)~$表示$~x~$经过$~y~$次操作对应答案的随机变量，则此题的答案可用$~\\Bbb{E}(\\xi(n,~k))~$。将$~n~$因式分解为$~\\prod_{i=1}^{m}p_i^{\\alpha_i}~$，于是$~\\xi(n,~k)=\\prod_{i=1}^{m}\\xi(p_i^{\\alpha_i},~k)~$，且$~\\xi(p_i^{\\alpha_i},~k)~$之间相互独立。所以答案可以表示为 \\begin{aligned} \\Bbb{E}(\\xi(n,~k)) &=\\Bbb{E}\\left(\\prod_{i=1}^{m}\\xi(p_i^{\\alpha_i},~k)\\right) \\\\ &=\\prod_{i=1}^{m}\\Bbb{E}\\left(\\xi(p_i^{\\alpha_i},~k)\\right) \\\\ \\end{aligned}接下来计算$~\\Bbb{E}\\left(\\eta_k=\\xi(p^\\alpha,~k)\\right)~$。显然$~\\eta~$是个简单随机变量且值域$~\\eta(\\Omega)={1,~p,~\\dots,~p^\\alpha}~$。记$~f(x,~y)=P(\\eta_y=p^x)~$，不难得出$~y=1~$时，有 f(x,~1)=\\frac{1}{\\alpha+1},~0\\leq x\\leq\\alpha那么对于$~y&gt;1~$，有 f(x,~y)=\\sum_{i=x}^{\\alpha}\\frac{f(i,~y-1)}{i+1}直接递推即可。总时间复杂度为$~O(\\sqrt{n}+k\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;const int maxn = 1 &lt;&lt; 14;int inv[maxn], a[64], b[64];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int calc(long long pp, int n, int k) &#123; int p = pp % mod; for (int i = 0; i &lt;= n; ++i) a[i] = inv[n + 1]; b[n + 1] = 0; while (--k) &#123; for (int i = n; ~i; --i) b[i] = add(b[i + 1], mul(a[i], inv[i + 1])); memcpy(a, b, (n + 1) * sizeof (int)); &#125; int ret = 0; for (int i = 0, base = 1; i &lt;= n; ++i) &#123; if (i) base = mul(base, p); ret = add(ret, mul(a[i], base)); &#125; return ret;&#125;int main() &#123; inv[0] = inv[1] = 1; for (int i = 2; i ^ maxn; ++i) inv[i] = mul(inv[mod % i], mod - mod / i); long long n; int k; cin &gt;&gt; n &gt;&gt; k; vector&lt;pair&lt;long long, int&gt;&gt; factors; for (long long p = 2; p * p &lt;= n; ++p) if (n % p == 0) &#123; int cnt = 0; while (n % p == 0) n /= p, ++cnt; factors.push_back(make_pair(p, cnt)); &#125; if (n ^ 1) factors.push_back(make_pair(n, 1)); int res = 1; for (auto factor : factors) res = mul(res, calc(factor.first, factor.second, k)); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; E. Egor and an RPG game题目大意对于一个全排列$~a_1,~a_2,~\\dots,~a_n~$，将其划分为若干个单调子序列，记最少的数量为$~k~$。对于所有长度为$~n~$的全排列，所对应的$~k~$的最大值记为$~f(n)~$。现给出一个全排列$~a_1,~a_2,~\\dots,~a_n~$，输出一种不超过$~f(n)~$的单调子序列划分方式。数据范围$~1\\leq n\\leq10^5~$。 题解考虑全排列$~1,~3,~2,~6,~5,~4,~10,~9,~8,~7~$，显然它至少要划分为$~4~$个单调子序列。所以对于$~\\frac{k(k+1)}{2}\\leq n~$，必有$~f(n)\\geq k~$。那么对于$~\\frac{k(k+1)}{2}&gt;n~$，下面证明存在$~k-1~$个单调子序列划分。考虑当前序列的任意一个$~\\text{LIS}~$，如果$~{\\mid\\text{LIS}\\mid}\\geq k~$，那么将其划分，对于剩余的部分，此时有$~\\frac{k(k-1)}{2}&gt;n-{\\mid\\text{LIS}\\mid}~$，可以数学归纳。如果$~{\\mid\\text{LIS}\\mid}&lt; k~$，那么根据$~\\text{Dilworth}~$定理，可以将序列划分为$~\\mid\\text{LIS}\\mid~$个$~\\text{LDS}~$。这样总时间复杂度为$~O(n\\sqrt n\\log n)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;int&gt; lim; for (int i = 0; i ^ 500; ++i) for (int j = i; ~j; --j) lim.push_back(i); int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; now(n), tmp, to(n + 1); vector&lt;bool&gt; flag(n + 1, true); vector&lt;vector&lt;int&gt;&gt; res; for (auto&amp; in : now) cin &gt;&gt; in; while (!now.empty()) &#123; vector&lt;int&gt; lis; vector&lt;vector&lt;int&gt;&gt; rem; for (auto a : now) &#123; int idx = lower_bound(lis.begin(), lis.end(), a) - lis.begin(); if (idx) to[a] = lis[idx - 1]; else to[a] = a; if (idx == lis.size()) &#123; lis.push_back(a); rem.push_back(vector&lt;int&gt;(1, a)); &#125; else &#123; lis[idx] = a; rem[idx].push_back(a); &#125; &#125; if (lis.size() &gt; lim[now.size()]) &#123; for (int i = lis.size() - 2; ~i; --i) lis[i] = to[lis[i + 1]]; res.push_back(lis); for (auto a : lis) flag[a] = false; tmp.clear(); for (auto a : now) if (flag[a]) tmp.push_back(a); swap(now, tmp); &#125; else &#123; for (auto ans : rem) res.push_back(ans); now.clear(); &#125; &#125; cout &lt;&lt; res.size() &lt;&lt; endl; for (auto arr : res) &#123; cout &lt;&lt; arr.size(); for (auto a : arr) cout &lt;&lt; ' ' &lt;&lt; a; cout &lt;&lt; endl; &#125; &#125;&#125; F. Alex and a TV Show题目大意初始有$~n~$个空的可重集合$~S_1,~S_2,~\\dots,~S_n~$。接下有$~q~$次操作或询问： 把$~S_x~$变为$~{v}~$。 把$~S_x~$变为$~S_y\\bigcup S_z~$。 把$~S_x~$变为$~{\\gcd(a,~b)\\mid a\\in S_y,~b\\in S_z}~$。 输出$~S_x~$中$~v~$的数量模$~2~$。 数据范围$~1\\leq n\\leq10^5,~1\\leq q\\leq10^6,~1\\leq v\\leq7000~$。 题解先考虑这样的计数矩阵$~A_{n\\times7000}~$，其中$~a_{xv}~$表示$~S_x~$中$~v~$的数量。那么会发现操作$~3~$的复杂度为$~O(q^2)~$。于是考虑因子矩阵$~B_{n\\times7000}~$，其中$~b_{xv}~$表示$~S_x~$中$~v~$的倍数的数量。关于$~B~$能否唯一的表示$~A~$，只要存在可逆矩阵$~T~$，使得$~B=AT~$即可。令 t_{ij}=\\begin{cases} 1 &\\text{$j\\mid i$} \\\\ 0 &\\text{$j\\nmid i$} \\\\ \\end{cases}则$~B=AT~$成立（根据$~B~$的定义），且$~T~$是主对角线全为$~1~$的下三角矩阵，必定可逆，于是$~B~$所对应的集族的唯一性得到了保证。事实上$~T^{-1}~$是莫比乌斯函数矩阵 t_{ij}^{-1}=\\begin{cases} \\mu(ij^{-1}) &\\text{$j\\mid i$} \\\\ 0 &\\text{$j\\nmid i$} \\\\ \\end{cases}$~T^{-1}~$的构造过程可以利用容斥的思想，那么$~\\mu~$则是容斥系数。于是操作$~1~$等价于$~b_{x\\small\\bullet}=t_{v\\small\\bullet}~$，操作$~2~$等价于$~b_{x\\small\\bullet}=b_{y\\small\\bullet}+b_{z\\small\\bullet}~$，操作$~3~$等价于$~b_{x\\small\\bullet}=b_{y\\small\\bullet}\\times b_{z\\small\\bullet}~$，询问$~4~$等价于计算$~b_{x\\small\\bullet}\\cdot t_{v\\small\\bullet}^{-1}~$。注意到$~v~$的数据范围以及答案模$~2~$的要求，可以用$~\\text{bitset}~$来模拟集合对应的因子矩阵。总时间复杂度为$~O(v\\log v+\\frac{qv}{\\text{bitset}})~$，注意可能需要$~\\text{fastIO}~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); const int maxn = 1e5 + 5; const int maxv = 7e3 + 5; vector&lt;int&gt; prime, mu(maxv, 0); vector&lt;bool&gt; vis(maxv, false); mu[1] = 1; for (int i = 2; i ^ maxv; ++i) &#123; if (!vis[i]) &#123; prime.push_back(i); mu[i] = -1; &#125; for (auto p : prime) &#123; if (i * p &gt;= maxv) break; vis[i * p] = true; if (i % p) mu[i * p] = -mu[i]; else break; &#125; &#125; vector&lt;bitset&lt;maxv&gt;&gt; factor(maxv), inv(maxv), set(maxn); for (int i = 1; i ^ maxv; ++i) for (int j = i; j &lt; maxv; j += i) &#123; factor[j].flip(i); if (mu[j / i]) inv[i].flip(j); &#125; int n, q; cin &gt;&gt; n &gt;&gt; q; while (q--) &#123; int op, x, y, z, v; cin &gt;&gt; op; if (op == 1) &#123; cin &gt;&gt; x &gt;&gt; v; set[x] = factor[v]; &#125; if (op == 2) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; set[x] = set[y] ^ set[z]; &#125; if (op == 3) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; set[x] = set[y] &amp; set[z]; &#125; if (op == 4) &#123; cin &gt;&gt; x &gt;&gt; v; cout &lt;&lt; ((set[x] &amp; inv[v]).count() &amp; 1 ? '1' : '0'); &#125; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Educational Codeforces Round 58 (Rated for Div. 2)","slug":"Educational Codeforces Round 58 (Rated for Div. 2)","date":"2019-01-17T14:07:58.054Z","updated":"2019-01-17T14:16:45.369Z","comments":true,"path":"2019/01/17/Educational Codeforces Round 58 (Rated for Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Educational Codeforces Round 58 (Rated for Div. 2)/","excerpt":"","text":"Educational Codeforces Round 58 (Rated for Div. 2) A. Minimum Integer题目大意输出不在$~[l,~r]~$内的$~d~$的最小整数倍。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int q; cin &gt;&gt; q; while (q--) &#123; long long l, r, d; cin &gt;&gt; l &gt;&gt; r &gt;&gt; d; cout &lt;&lt; ((d &lt; l ? 0 : r / d) + 1) * d &lt;&lt; endl; &#125;&#125; B. Accordion题目大意输出给定字符串满足左边为$~\\text{[:}~$右边为$~\\text{:]}~$中间为任意（可以没有）数量的$~\\text{|}~$的子序列最大长度。 题解水题。 代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; int left = -1, right = -1, size = str.size(); bool flag = false; for (int i = 0; i ^ size; ++i) &#123; if (str[i] == '[') flag = true; if (str[i] == ':' &amp;&amp; flag) &#123; left = i; break; &#125; &#125; flag = false; for (int i = size - 1; ~i; --i) &#123; if (str[i] == ']') flag = true; if (str[i] == ':' &amp;&amp; flag) &#123; right = i; break; &#125; &#125; if (!~left || !~ right || left &gt;= right) return cout &lt;&lt; -1 &lt;&lt; endl, 0; int res = 4; for (int i = left + 1; i ^ right; ++i) if (str[i] == '|') ++res; cout &lt;&lt; res &lt;&lt; endl;&#125; C. Division and Union题目大意将$~n~$个给定的闭区间划分到两个集合之中，使得在这两个集合之中分别任选一个闭区间，它们不交。输出任意一种划分或者不存在。 题解首先，如果有合法的划分，当且仅当这两个集合分别并起来得到的两个数集不交。于是合法划分不存在当前仅当所有区间并起来还是一个区间。对所有的区间按左端点升序，先将第$~1~$个区间划分给集合$~1~$，然后按顺序看当前区间与第$~1~$个区间是否有交。如果有交则划分给集合$~1~$同时与第$~1~$个区间并起来。如果没有则后面所有的区间都划分给集合$~2~$，这样所有在集合$~2~$区间里的数都大于在集合$~1~$区间里的数。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; seg(n); for (int i = 0; i ^ n; ++i) &#123; cin &gt;&gt; seg[i].first.first &gt;&gt; seg[i].first.second; seg[i].second = i; &#125; sort(seg.begin(), seg.end()); vector&lt;int&gt; res(n); bool flag = true; for (int i = 0, back = seg.front().first.second; i ^ n; ++i) &#123; if (seg[i].first.first &lt;= back) &#123; back = max(back, seg[i].first.second); res[seg[i].second] = 1; &#125; else &#123; flag = false; for (int j = i; j ^ n; ++j) res[seg[j].second] = 2; cout &lt;&lt; res.front(); for (int j = 1; j ^ n; ++j) cout &lt;&lt; ' ' &lt;&lt; res[j]; cout &lt;&lt; endl; break; &#125; &#125; if (flag) cout &lt;&lt; -1 &lt;&lt; endl; &#125;&#125; D. GCD Counting题目大意给定一颗带点值的树，找出最长的简单路径满足路径上所有点值不互质。数据范围$~1\\leq n\\leq2\\cdot10^5,~1\\leq a\\leq2\\cdot10^5~$。 题解对于最长的合法路径，必存在一个质数$~p~$是路径上所有点值的公因数。注意到点值的数据范围，可以先预处理所有数字的所有质因子，这一步的时间复杂度为$~O(a\\log a)~$。树形$~\\text{DP}~$。任取一个点为根节点，考虑在以节点$~u~$为根的子树上经过$~u~$且有公因数$~p~$的最长路径$~cal[u][p]~$。先计算以$~u~$为一个端点，另一端点在子树中且公因数为$~p~$的最长路径路径$~len[u][p]~$。那么对于$~u~$的所有儿子$~v~$，在$~\\text{dfs}~$过程中用$~len[v][p]~$的最大值更新$~len[u][p]~$，最大值和次大值更新$~cal[u][p]~$。为节省空间，注意到$~a~$的不同质因子个数很少，可以用$~\\text{map}~$来维护$~len~$，且不用记录$~cal~$直接更新答案即可。总时间复杂度为$~O(a\\cdot\\log a+n\\cdot\\log a\\cdot\\log\\log a)~$。事实上可以写成$~O((n+a)\\log a)~$，但是没有必要。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;int a[maxn], res, max1[maxn], max2[maxn];vector&lt;int&gt; adj[maxn], prime[maxn];vector&lt;bool&gt; vis(maxn);map&lt;int, int&gt; len[maxn];void dfs(int u, int pa) &#123; for (auto v : adj[u]) if (v ^ pa) dfs(v, u); for (auto p : prime[a[u]]) max1[p] = max2[p] = 0; for (auto v : adj[u]) if (v ^ pa) for (auto p : prime[a[u]]) &#123; max2[p] = max(max2[p], len[v][p]); if (max1[p] &lt; max2[p]) swap(max1[p], max2[p]); &#125; if (a[u] == 1) return; int cal = 0; for (auto p : prime[a[u]]) &#123; cal = max(cal, max1[p] + max2[p]); len[u][p] = max1[p] + 1; &#125; res = max(res, ++cal);&#125;int main() &#123; for (int i = 2; i ^ maxn; ++i) if (!vis[i]) for (int j = i; j &lt; maxn; j += i) &#123; vis[j] = true; prime[j].push_back(i); &#125; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i ^ n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; dfs(1, 0); cout &lt;&lt; res &lt;&lt; endl;&#125; E. Polycarp’s New Job题目大意一共$~n~$次添加或者询问： 加入一个大小为$~x\\times y~$的矩形。 询问是否所有矩形都能被$~h\\times w~$的矩形包含。数据范围$~2\\leq n\\leq5\\cdot10^5,~1\\leq x,~y,~h,~w\\leq10^9~$。 题解首先离散化。注意到矩形可以翻转，不妨让$~x\\geq y,~h\\geq w~$。那么题目变成了平面加点和询问平面内所有点是否都在$~[0,~h]\\times[0,~w]~$或$~[0,~w]\\times[0,~h]~$内。空间范围显然不允许使用二维树状数组，但是可以将询问等价为所有点都在$~[0,~h]\\times[0,~h]~$内且不在$~(w,~\\infty)\\times(w,~\\infty)~$内。那么用两个一维树状数组维护即可。总时间复杂度$~O(n\\log n)~$。数据范围过大，注意$~\\text{IO}~$速度。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; struct Query &#123; char op; int x, y; &#125;; vector&lt;Query&gt; query(n); set&lt;int&gt; num; for (auto&amp; qry : query) &#123; cin &gt;&gt; qry.op &gt;&gt; qry.x &gt;&gt; qry.y; if (qry.x &lt; qry.y) swap(qry.x, qry.y); num.insert(qry.x); num.insert(qry.y); &#125; map&lt;int, int&gt; to; int maxn = 1; for (auto x : num) to[x] = maxn++; vector&lt;int&gt; bit1(maxn, 0), bit2(maxn, 0); #define lowbit(x) (x &amp; -x) int cnt = 0; for (auto qry : query) &#123; qry.x = to[qry.x]; qry.y = to[qry.y]; if (qry.op == '+') &#123; ++cnt; for (int i = qry.x; i &lt; maxn; i += lowbit(i)) ++bit1[i]; for (int i = qry.y; i; i -= lowbit(i)) ++bit2[i]; &#125; else &#123; int sum = 0; for (int i = qry.x; i; i -= lowbit(i)) sum += bit1[i]; for (int i = qry.y + 1; i &lt; maxn; i += lowbit(i)) sum -= bit2[i]; if (sum == cnt) cout &lt;&lt; \"YES\\n\"; else cout &lt;&lt; \"NO\\n\"; &#125; &#125;&#125; F. Trucks and Cities题目大意坐标轴上有$~n~$个城市和$~m~$趟卡车。给定城市坐标$~a~$，卡车的起点$~s~$、终点$~f~$、每公里耗油$~c~$和可中途加油次数$~r~$。问油箱的最小容量。 题解动态规划。记$~dp[r][s][f]~$为最优策略下卡车从$~a_s~$到$~a_f~$最多停靠加油$~r~$次的最长的两次停靠城市距离。那么答案则是$~\\max(dp[r][s][f]\\cdot c)~$。通过枚举最后一次停靠城市$~a_l~$，有状态转移式 dp[r][s][f]=\\min_{s< t< f}\\max(dp[r-1][s][t],~a[f]-a[t])此时总时间复杂度为$~O(n^4)~$显然会$~\\text{tle}~$。但是不难发现在固定$~r~$和$~s~$后，最优转移点$~t~$随着$~f~$递增，所以双指针优化后时间复杂度变为$~O(n^3)~$。但是直接开$~O(n^3)~$的三位数组空间复杂度很危险（擦着边其实可以过），那么对于所有的输入$~(s,~f,~c,~r)~$离线操作，按$~r~$升序，这样$~dp~$的$~r~$维度可以滚动数组实现。总时间复杂度为$~O(n^3+m\\log m)~$，空间复杂度为$~O(n^2+m)~$。 代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; vector&lt;vector&lt;int&gt;&gt; dp0(n + 1, vector&lt;int&gt;(n + 1)); vector&lt;vector&lt;int&gt;&gt; dp1(n + 1, vector&lt;int&gt;(n + 1)); for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; ++j) dp0[i][j] = a[j] - a[i]; struct Query &#123;int s, f, c, r;&#125;; vector&lt;Query&gt; query(m); for (auto&amp; qry : query) cin &gt;&gt; qry.s &gt;&gt; qry.f &gt;&gt; qry.c &gt;&gt; qry.r; sort(query.begin(), query.end(), [](Query a, Query b) &#123;return a.r &lt; b.r;&#125;); long long res = 0; int now = 0; for (auto qry : query) &#123; while (now ^ qry.r) &#123; for (int j = 1; j &lt;= n; ++j) for (int k = j, l = j; k &lt;= n; ++k) &#123; while (l &lt; k &amp;&amp; max(dp0[j][l], a[k] - a[l]) &gt; max(dp0[j][l + 1], a[k] - a[l + 1])) ++l; dp1[j][k] = max(dp0[j][l], a[k] - a[l]); &#125; swap(dp0, dp1); ++now; &#125; res = max(res, 1LL * qry.c * dp0[qry.s][qry.f]); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; G. (Zero XOR Subset)-less题目大意给定数列$~a_1,~a_2,~\\dots,~a_n~$，要划分为若干个连续子序列$~A_1,~A_2,~\\dots,~A_k~$。令每个子序列的$~\\text{xor}~$和记为$~\\alpha_i,~i=1,~2,~\\dots,~k~$，集合$~S={\\alpha_1,~\\alpha_2,~\\dots,~\\alpha_k}~$。问满足$~S~$的所有非空子集的$~\\text{xor}~$和互不相同的最大$~k~$或不存在。数据范围$~1\\leq n\\leq2\\cdot10^5,~0\\leq a\\leq10^9~$。 题解记录$~a_1,~a_2,~\\dots,~a_n~$的前缀$~\\text{xor}~$和$~pre_1,~pre_2,~\\dots,~pre_n~$，显然如果$~pre_n=0~$则答案不存在，反之存在。再考虑合法集合$~S~$，记$~\\alpha_1,~\\alpha_2,~\\dots,~\\alpha_k~$的前缀$~\\text{xor}~$和为$~\\beta_1,~\\beta_2,~\\dots,~\\beta_k~$，则不难发现$~\\bar{S}={\\beta_1,~\\beta_2,~\\dots,~\\beta_k}~$也是合法集合。且根据定义$~\\beta~$也是$~a~$的前缀$~\\text{xor}~$和，所以$~\\bar{S}\\subseteq{pre_1,~pre_2,~\\dots,~pre_n}~$。对于所有正整数，考虑二进制表示的$~01~$向量，可以等价于$~\\Bbb{Z}_2~$上的某向量空间的向量，合法集合可以看作是这个向量空间上的一个线性无关组。这是一个线性基问题，答案是包含$~pre~$的最小空间的维数。时间复杂度为$~O(n\\log a)~$。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), base; cin &gt;&gt; a.front(); for (int i = 1; i ^ n; ++i) cin &gt;&gt; a[i], a[i] ^= a[i - 1]; if (!a.back()) return cout &lt;&lt; -1 &lt;&lt; endl, 0; for (auto e : a) &#123; for (auto v : base) e = min(e, e ^ v); if (e) base.push_back(e); &#125; cout &lt;&lt; base.size() &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Educational Codeforces Round 57 (Rated for Div. 2)","slug":"Educational Codeforces Round 57 (Rated for Div. 2)","date":"2019-01-17T14:07:58.047Z","updated":"2019-01-17T14:09:23.552Z","comments":true,"path":"2019/01/17/Educational Codeforces Round 57 (Rated for Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Educational Codeforces Round 57 (Rated for Div. 2)/","excerpt":"","text":"Educational Codeforces Round 57 (Rated for Div. 2) A. Find Divisible题目大意输出任意一组$~(x,~y)\\in [l,~r]^2~$满足$~x~$整除$~y~$，保证有解。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; l * 2 &lt;&lt; endl; &#125;&#125; B. Substring Removal题目大意给定一个小写字母串，询问有多少子串那满足删去子串后剩余部分仅有$~1~$种字母，保证输入串至少含$~2~$种字母。 题解显然剩余的串必须为单字母构成前缀或后缀，或者字母一样的前后缀。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const int mod = 998244353; int n; string str; cin &gt;&gt; n &gt;&gt; str; int l, r; for (l = 0; l ^ n &amp;&amp; str[l] == str.front(); ++l); for (r = n - 1; ~r &amp;&amp; str[r] == str.back(); --r); if (str.front() == str.back()) cout &lt;&lt; (long long)(l + 1) * (n - r) % mod &lt;&lt; endl; else cout &lt;&lt; l + n - r &lt;&lt; endl;&#125; C. Polygon for the Angle题目大意给一个在$~1^\\circ~$到$~179^\\circ~$之间的整数度数，输出最小的$~n~$满足正$~n~$边形上可以取$~3~$个点构成这个角度。 题解不难得出正$~n~$边形可以得到的角度为$~\\frac{1}{n}\\times180^\\circ,~\\frac{2}{n}\\times180^\\circ,~\\dots,~\\frac{n-2}{n}\\times180^\\circ~$这一结论。考虑分数$~\\frac{ang}{180}~$的最简形式$~\\frac{p}{q}~$，答案即为$~q~$或者$~2q~$（如果$~p=q-1~$）。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int ang; cin &gt;&gt; ang; int gcd = __gcd(ang, 180); cout &lt;&lt; (gcd + ang ^ 180 ? 180 : 360) / gcd &lt;&lt; endl; &#125;&#125; D. Easy Problem题目大意给一个字符串以及删除每个字符的花费$~a_i~$，输出使得字符串不包含$~\\text{hard}~$这一子序列的最小删除花费。 题解动态规划。记$~dp[i][j]~$表示考虑到第$~i~$位，已经构成了$~\\text{hard}~$前$~j~$个字符的最小花费。从左至右模拟即可，时间复杂度为$~O(n)~$。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; string str; cin &gt;&gt; n &gt;&gt; str; vector&lt;long long&gt; a(n); for (auto&amp; arr : a) cin &gt;&gt; arr; vector&lt;vector&lt;long long&gt;&gt; dp(n + 1, vector&lt;long long&gt;(4)); dp[0][0] = 0; dp[0][1] = dp[0][2] = dp[0][3] = 0x3f3f3f3f; for (int i = 1; i &lt;= n; ++i) &#123; dp[i][0] = dp[i - 1][0]; dp[i][1] = dp[i - 1][1]; dp[i][2] = dp[i - 1][2]; dp[i][3] = dp[i - 1][3]; if (str[i - 1] == 'h') &#123; dp[i][0] += a[i - 1]; dp[i][1] = min(dp[i][1], dp[i - 1][0]); &#125; if (str[i - 1] == 'a') &#123; dp[i][1] += a[i - 1]; dp[i][2] = min(dp[i][2], dp[i - 1][1]); &#125; if (str[i - 1] == 'r') &#123; dp[i][2] += a[i - 1]; dp[i][3] = min(dp[i][3], dp[i - 1][2]); &#125; if (str[i - 1] == 'd') &#123; dp[i][3] = dp[i][3] + a[i - 1]; &#125; &#125; cout &lt;&lt; min(min(dp[n][0], dp[n][1]), min(dp[n][2], dp[n][3])) &lt;&lt; endl;&#125; E. The Top Scorer题目大意有$~p~$个人比赛，每人都有未知的非负得分$~a_i~$，但总和$~\\sum_{i=1}^{p}{a_i}=s~$已知。分数最高的一人获胜，如果最高分有多人同分，则他们的获胜概率均等。现已知$~\\text{Hason}~$的分数至少为$~r~$，所有不同的结果出现的概率均等，求他获胜的概率。数据范围$~1\\leq p\\leq 100,~0\\leq r\\leq s\\leq5000~$。 题解先将$~\\text{Hason}~$的分数和总分数减去$~r~$，那么插板法可以算出所有合法的结果数量为 \\binom{p+s-r-1}{p-1}接下来枚举$~\\text{Hason}~$的得分$~i=r,~r+1,~\\dots,~s~$，有$~j=1,~2,~\\dots,~\\lfloor \\frac{s}{i}\\rfloor~$人与他同分（算上$~\\text{Hason}~$他自己），且其余的得分均小于$~i~$的情况。此时$~\\text{Hason}~$获胜的结果数量期望为 \\frac{1}{j}\\binom{p-1}{p-j}f(p-j,~i,~s-ij)其中$~f(x,~y,~z)~$表示$~x~$人得分均小于$~y~$且总和为$~z~$的合法结果数量。对于$~f(x,~y,~z)~$的计算，先考虑在没有$~y~$的限制下，用插板法可以得到答案为$~g(x,~z)=\\binom{x+z-1}{x-1}~$。那么将条件变为$~x~$人，至少有$~w~$人得分不少于$~y~$，且总和为$~z~$，则它的结果数量等于$~\\binom{x}{w}g(x,~z-wy)~$。于是通过容斥，得到$~f(x,~y,~z)~$的计算式 \\begin{aligned} f(x,~y,~z) &=\\sum_{i=0}^{\\min(x,~\\lfloor\\frac{z}{y}\\rfloor)}{(-1)^i\\binom{x}{i}g(x,~z-iy)} \\\\ &=\\sum_{i=0}^{\\min(x,~\\lfloor\\frac{z}{y}\\rfloor)}{(-1)^i\\binom{x}{i}\\binom{x+z-iy-1}{x-1}} \\\\ \\end{aligned}注意特判$~f(x=0,~y,~z)~$的情况。总时间复杂度为$~O(p^2s)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 6e3;int inv[maxn], fact[maxn], finv[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int bino(const int&amp; a, const int&amp; b) &#123;return mul(mul(fact[a], finv[b]), finv[a - b]);&#125;inline int binv(const int&amp; a, const int&amp; b) &#123;return mul(mul(finv[a], fact[b]), fact[a - b]);&#125;inline int calc(const int&amp; n, const int&amp; up, const int&amp; s) &#123; if (!n) return s == 0; int ret = 0; for (int i = 0; i &lt;= n &amp;&amp; i * up &lt;= s; ++i) &#123; int temp = mul(bino(n + s - i * up - 1, n - 1), bino(n, i)); ret = i &amp; 1 ? sub(ret, temp) : add(ret, temp); &#125; return ret;&#125;int main() &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125; int p, s, r; cin &gt;&gt; p &gt;&gt; s &gt;&gt; r; int cnt = 0; for (int i = r; i &lt;= s; ++i) for (int j = 1; j &lt;= p &amp;&amp; i * j &lt;= s; ++j) cnt = add(cnt, mul(mul(calc(p - j, i, s - i * j), inv[j]), bino(p - 1, j - 1))); cout &lt;&lt; mul(cnt, binv(p - r + s - 1, p - 1)) &lt;&lt; endl;&#125; F. Inversion Expectation题目大意给一个不完整的全排列，输出逆序对期望数。数据范围$~1\\leq n\\leq 2\\cdot10^5~$。 题解记总共有$~m~$个未知数，分为$~4~$种情况讨论： 所有已知数与已知数对于逆序对的贡献。即为计算一个序列的逆序对数量，用排序或者树状数组均可实现，时间复杂度为$~O(n\\log n)~$。 所有未知数与未知数对于逆序对的贡献。对于任意一种可能的未知数的排列，将其翻转后原来的逆序对变为顺序对，顺序对变为逆序对。于是任意一对未出现的数字，在所有可能的排列情况种它们一半为顺序对，一半为逆序对。所以$~m~$个未知数相互之间对于逆序对的贡献期望为$~\\binom{m}{2}\\frac{m!}{2}~$。 所有已知数与未知数对于逆序对的贡献。先单独考虑一个已知数$~p_i~$与它左边比它大的未知数对于逆序对的贡献。设它左边有$~left_i~$个未知数，所有未知数种有$~lgreater_{p_i}~$个比$~p_i~$大，那么逆序对的期望则是$~left_i\\cdot lgreater_{p_i}\\cdot m^{-1}~$。同理对于$~p_i~$与它右边比它小的未知数对于逆序对期望则是$~right_j\\cdot rsmaller_{p_j}\\cdot m^{-1}~$。这些都可以在线性时间里处理完。总时间复杂度为$~(n\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 2e5 + 5;int inv[maxn], a[maxn], exist[maxn], blank[maxn], bit[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;#define lowbit(x) (x &amp; -x)int main() &#123; inv[1] = 1; for (int i = 2; i ^ maxn; ++i) inv[i] = mul(inv[mod % i], mod - mod / i); int n; cin &gt;&gt; n; int cnt = 0, res = 0; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; if (~a[i]) &#123; blank[i] = blank[i - 1]; exist[a[i]] = 1; res = add(res, i - cnt - 1); for (int j = a[i]; j; j -= lowbit(j)) res = sub(res, bit[j]); for (int j = a[i]; j &lt; maxn; j += lowbit(j)) ++bit[j]; &#125; else &#123; blank[i] = ++cnt; &#125; &#125; for (int i = 1; i &lt;= n; ++i) exist[i] += exist[i - 1]; res = add(res, mul(mul(cnt, cnt - 1), inv[4])); for (int i = 1; i &lt;= n; ++i) if (~a[i]) res = add(res, mul(add(mul(blank[i], cnt + exist[a[i]] - a[i]), mul(cnt - blank[i], a[i] - exist[a[i]])), inv[cnt])); cout &lt;&lt; res &lt;&lt; endl;&#125; G. Lucky Tickets题目大意问有多少个可以首零的$~n~$（偶数）位数字满足前一半的各位数数字之和与后一半的各位数数字之和一样。限定这个数只能由$~d_1,~d_2,~\\dots,~d_k~$组成。数据范围$~2\\leq n\\leq2\\cdot10^5,~1\\leq k\\leq10~$。 题解考虑所有前$~\\frac{n}{2}~$位数加起来可以得到的总和$~s~$，令$~calc(s)~$为所有满足各位数数字之和位$~s~$的合法的$~\\frac{n}{2}~$位数的数量，则答案为$~\\sum_{s=0}^{5n}calc^2(s)~$。考虑这样一个多项式 f(x)=\\sum_{i=1}^{k}x^{d_i}则$~calc(s)~$即为$~f^\\frac{n}{2}(x)~$的$~s~$次系数。于是$~\\text{NTT}~$即可得出答案。时间复杂度$~O(n\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int root = 3;const int maxn = 1 &lt;&lt; 20;int f[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;#define lowbit(x) (x &amp; -x)inline int fpow(int a, int n) &#123; if (n &lt; 0) n = (2LL - mod) * n % (mod - 1); int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;inline void to_pow2(int&amp; x) &#123;while (x ^ lowbit(x)) x += lowbit(x);&#125;inline void bit_reverse(int f[], int size) &#123; for (int i = 1, j = size &gt;&gt; 1; i ^ size - 1; ++i) &#123; if (i &lt; j) swap(f[i], f[j]); int k = size &gt;&gt; 1; while (j &gt;= k) &#123; j -= k; k &gt;&gt;= 1; &#125; if (j &lt; k) j += k; &#125;&#125;inline void ntt(int f[], int size, int op = 1) &#123; bit_reverse(f, size); for (int i = 2; i &lt;= size; i &lt;&lt;= 1) &#123; int wn = fpow(root, op * (1 - mod) / i); for (int j = 0; j ^ size; j += i) &#123; int w = 1; for (int k = j; k ^ j + (i &gt;&gt; 1); ++k) &#123; int u = f[k]; int v = mul(w, f[k + (i &gt;&gt; 1)]); f[k] = add(u, v); f[k + (i &gt;&gt; 1)] = sub(u, v); w = mul(w, wn); &#125; &#125; &#125; if (!~op) &#123; int inv = fpow(size, -1); for (int i = 0; i ^ size; ++i) f[i] = mul(f[i], inv); &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; while (k--) &#123; int d; cin &gt;&gt; d; f[d] = 1; &#125; int size = n * 5; to_pow2(size); ntt(f, size); for (int i = 0; i ^ size; ++i) f[i] = fpow(f[i], n &gt;&gt; 1); ntt(f, size, -1); int res = 0; for (int i = 0; i ^ size; ++i) res = add(res, mul(f[i], f[i])); cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Educational Codeforces Round 56 (Rated for Div. 2)","slug":"Educational Codeforces Round 56 (Rated for Div. 2)","date":"2019-01-17T14:07:58.042Z","updated":"2019-01-17T14:09:21.495Z","comments":true,"path":"2019/01/17/Educational Codeforces Round 56 (Rated for Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Educational Codeforces Round 56 (Rated for Div. 2)/","excerpt":"","text":"Educational Codeforces Round 56 (Rated for Div. 2) A. Dice Rolling题目大意一个点数为$~2~$至$~7~$的骰子，求任意一种可能的次数使得点数之和为$~x~$。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int x; cin &gt;&gt; x; cout &lt;&lt; (x &gt;&gt; 1) &lt;&lt; endl; &#125;&#125; B. Letters Rearranging题目大意给一个小写字母串，输出任意一种不回文重排列。 题解水题。排序即可。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; string str; cin &gt;&gt; str; sort(str.begin(), str.end()); if (str.front() == str.back()) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; str &lt;&lt; endl; &#125;&#125; C. Mishka and the Last Exam题目大意输出一个长度为$~n~$的数列${a_n}$满足对称位之差为给定的数列$~{b_\\frac{n}{2}}~$。 题解水题。从数列边缘向内部贪心，左边尽量小，右边尽量大。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; n &gt;&gt;= 1; vector&lt;long long&gt; left(n), right(n); for (int i = 0; i ^ n; ++i) &#123; long long b; cin &gt;&gt; b; right[i] = b - (left[i] = (i ? max(left[i - 1], b - right[i - 1]) : 0)); &#125; for (auto res : left) cout &lt;&lt; res &lt;&lt; ' '; long long last = right.front(); reverse(right.begin(), right.end()); right.pop_back(); for (auto res : right) cout &lt;&lt; res &lt;&lt; ' '; cout &lt;&lt; last &lt;&lt; endl;&#125; D. Beautiful Graph题目大意给一个简单图（无重边无自环可能不连通），求点的$~{1,~2,~3}~$染色方案数，使得每条边两边加起来是奇数。 题解考虑染色的奇偶性，显然对于每个点，它相邻的点均与它奇偶性不同。所以如果存在奇环，则答案为$~0~$。跑一遍$~\\text{DFS}~$然后对于每个联通块的方案数乘起来即是答案。时间复杂度为$~O(n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 3e5 + 5;vector&lt;int&gt; adj[maxn];int two[maxn], color[maxn], cnt[2];bool vis[maxn], flag;inline int add(const int&amp; a, const int&amp; b) &#123;return a + b &lt; mod ? a + b : a + b - mod;&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;void dfs(int u, int c = 0) &#123; vis[u] = true; ++cnt[color[u] = c]; for (auto v : adj[u]) &#123; if (vis[v]) flag &amp;= (color[u] ^ color[v]); else dfs(v, !c); &#125;&#125;int main() &#123; two[0] = 1; for (int i = 1; i ^ maxn; ++i) two[i] = add(two[i - 1], two[i - 1]); int t; cin &gt;&gt; t; while (t--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) adj[i].clear(); while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; memset(vis + 1, 0, n * sizeof (bool)); flag = true; int res = 1; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; cnt[0] = cnt[1] = 0; dfs(i); if (flag) res = mul(res, add(two[cnt[0]], two[cnt[1]])); else break; &#125; cout &lt;&lt; (flag ? res : 0) &lt;&lt; endl; &#125;&#125; E. Intersection of Permutations题目大意给定$~1,~\\dots,~n~$的两个全排列$~a~$和$~b~$，和$~q~$个查询或修改操作。查询操作给出$~l_a,~r_a,~l_b,~r_b~$，输出$~a_{[l_a,~r_a]}~$和$~b_{[l_b,~r_b]}~$之间相同同的数字个数。修改操作给出$~x~$和$~y~$，交换$~b_x~$和$~b_y~$。 题解应为$~a~$不会被修改，那么做置换使得$~a_i=i~$，这样对于询问操作，只要输出$~[l_a,~r_a]~$在$~b_{[l_b,~r_b]}~$中出现的次数。考虑二维坐标系上的$~n~$个点$~(b_i,~i),~i=1,~2,~\\dots,~n~$，查询操作等价于输出$~[la,~ra]\\times[lb,~rb]~$内的点的个数；修改操作等价于将$~(b_x,~x)~$和$~(b_y,~y)~$变为$~(b_y,~x)~$和$~(b_x,~y)~$。用树状数组维护$~\\text{treap}~$即可，时间复杂度为$~O(n\\log^2n)~$。由于我不会写$~\\text{treap}~$，所以使用了$~\\text{pb_ds}~$库，常数比较大。 代码（使用$~\\text{pb_ds}~$库）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;using namespace std;using namespace __gnu_pbds;const int maxn = 2e5 + 5;int a[maxn], b[maxn];tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; bit[maxn];#define lowbit(x) (x &amp; -x)int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; int in; cin &gt;&gt; in; a[in] = i; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int in; cin &gt;&gt; in; b[i] = a[in]; for (int j = i; j &lt;= n; j += lowbit(j)) bit[j].insert(b[i]); &#125; while (m--) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; int la, ra, lb, rb; cin &gt;&gt; la &gt;&gt; ra &gt;&gt; lb &gt;&gt; rb; int res = 0; for (int i = rb; i; i -= lowbit(i)) &#123; auto ite = bit[i].upper_bound(ra); if (ite == bit[i].end()) res += bit[i].size(); else res += bit[i].order_of_key(*ite); &#125; for (int i = rb; i; i -= lowbit(i)) &#123; auto ite = bit[i].upper_bound(la - 1); if (ite == bit[i].end()) res -= bit[i].size(); else res -= bit[i].order_of_key(*ite); &#125; for (int i = lb - 1; i; i -= lowbit(i)) &#123; auto ite = bit[i].upper_bound(ra); if (ite == bit[i].end()) res -= bit[i].size(); else res -= bit[i].order_of_key(*ite); &#125; for (int i = lb - 1; i; i -= lowbit(i)) &#123; auto ite = bit[i].upper_bound(la - 1); if (ite == bit[i].end()) res += bit[i].size(); else res += bit[i].order_of_key(*ite); &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; else &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; for (int i = x; i &lt;= n; i += lowbit(i)) bit[i].erase(b[x]); for (int i = y; i &lt;= n; i += lowbit(i)) bit[i].erase(b[y]); swap(b[x], b[y]); for (int i = x; i &lt;= n; i += lowbit(i)) bit[i].insert(b[x]); for (int i = y; i &lt;= n; i += lowbit(i)) bit[i].insert(b[y]); &#125; &#125;&#125; F. Vasya and Array题目大意一个长度为$~n~$的数列由$~1,~\\dots,~k~$组成，部分位置的值已给定。求有多少个数列满足所有长度为$~len~$的区间内至少由$~2~$种不同的数字。 题解动态规划，有点复杂。记$~pre[i][j]~$为区间$~[1,~i]~$中至多有多少$~j~$，从而计算$~fuck[i][j]~$，表示区间$~(i-len,~i]~$是否有可能全部为$~j~$。记$~dp[i][j][0/1]~$为区间$~[1,~i]~$上满足$~a[i]=j~$的合法或非法数量，记求和$~sum[i][0/1]=\\sum_{j=1}^k{dp[i][j][0/1]}~$以及$~cnt[i]=sum[i][0]+sum[i][1]~$。于是有状态转移式 \\begin{aligned} dp[i][j][0] &=sum[i-1][0]+\\begin{cases} sum[i-len][1]-dp[i-len][j][1] &\\text{$flag[i][j]$} \\\\ 0 &\\text{$!flag[i][j]$}\\end{cases} \\\\ dp[i][j][1] &=cnt[i-1]-dp[i][j][0] \\\\ \\end{aligned}所有的状态转移都是$~O(1)~$的，所以时间复杂度与空间复杂度均为$~O(nk)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 1e5 + 5;const int maxk = 105;int a[maxn], pre[maxn][maxk], cnt[maxn], sum[maxn][2], dp[maxn][maxk][2];bool fuck[maxn][maxk];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;int main() &#123; int n, k, len; cin &gt;&gt; n &gt;&gt; k &gt;&gt; len; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; if (~a[i]) pre[i][a[i]] = 1; else for (int j = 1; j &lt;= k; ++j) pre[i][j] = 1; &#125; if (len == 1) return cout &lt;&lt; 0 &lt;&lt; endl, 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= k; ++j) &#123; pre[i][j] += pre[i - 1][j]; if (i &gt;= len &amp;&amp; pre[i][j] - pre[i - len][j] == len) fuck[i][j] = true; &#125; if (~a[1]) &#123; cnt[1] = sum[1][1] = dp[1][a[1]][1] = 1; &#125; else &#123; for (int i = 1; i &lt;= k; ++i) dp[1][i][1] = 1; cnt[1] = sum[1][1] = k; &#125; sum[0][1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (~a[i]) &#123; cnt[i] = cnt[i - 1]; dp[i][a[i]][0] = sum[i - 1][0]; if (fuck[i][a[i]]) dp[i][a[i]][0] = add(dp[i][a[i]][0], sub(sum[i - len][1], dp[i - len][a[i]][1])); dp[i][a[i]][1] = sum[i][1] = sub(cnt[i], sum[i][0] = dp[i][a[i]][0]); &#125; else &#123; for (int j = 1; j &lt;= k; ++j) &#123; dp[i][j][0] = sum[i - 1][0]; if (fuck[i][j]) dp[i][j][0] = add(dp[i][j][0], sub(sum[i - len][1], dp[i - len][j][1])); sum[i][0] = add(sum[i][0], dp[i][j][0]); dp[i][j][1] = sub(cnt[i - 1], dp[i][j][0]); &#125; sum[i][1] = sub(cnt[i] = mul(cnt[i - 1], k), sum[i][0]); &#125; &#125; cout &lt;&lt; sum[n][1] &lt;&lt; endl;&#125; G. Multidimensional Queries题目大意给定$~k~$维空间的$~n~$个点，和$~q~$次修改或查询操作。修改为重新赋值第$~i~$个点，查询为区间$~[l,~r]~$的最大曼哈顿距离。数据范围$~1\\leq n\\leq2\\times10^5,~1\\leq k\\leq5,~1\\leq q\\leq2\\times10^5,~-10^6\\leq a_{ij}\\leq10^6,~$。 题解考虑曼哈顿距离公式 \\begin{aligned} \\sum_{i=1}^{k}\\mid a_{xi}-a_{yi}\\mid &=\\max\\sum_{i=1}^{k}c_i(a_{xi}-a_{yi}) \\\\ &=\\max\\left(\\sum_{i=1}^{k}c_i a_{xi}-\\sum_{i=1}^{k}c_i a_{xi}\\right) \\\\ c_i &=\\pm1 \\\\ \\end{aligned}注意到$~k~$的数据范围很小，上式的系数列的取法共$~2^k~$种，那么建立$~2^{k+1}~$棵线段树维护$~\\sum_{i=1}^{k}c_i a_{xi}~$的最大最小值即可。时间复杂度为$~O((n+q)2^k\\log n)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;int size, seg[maxn &lt;&lt; 2][32][2], a[maxn][32], b[5], idx[maxn], cal[32][2];void build(int begin, int end, int index) &#123; if (begin == end) &#123; for (int i = 0; i ^ size; ++i) seg[index][i][0] = seg[index][i][1] = a[begin][i]; idx[begin] = index; return; &#125; int mid = begin + end &gt;&gt; 1; build(begin, mid, index &lt;&lt; 1); build(mid + 1, end, index &lt;&lt; 1 ^ 1); for (int i = 0; i ^ size; ++i) &#123; seg[index][i][0] = min(seg[index &lt;&lt; 1][i][0], seg[index &lt;&lt; 1 ^ 1][i][0]); seg[index][i][1] = max(seg[index &lt;&lt; 1][i][1], seg[index &lt;&lt; 1 ^ 1][i][1]); &#125;&#125;void push_up(int pos) &#123; int index = idx[pos]; for (int i = 0; i ^ size; ++i) seg[index][i][0] = seg[index][i][1] = a[pos][i]; while (index ^ 1) &#123; index &gt;&gt;= 1; for (int i = 0; i ^ size; ++i) &#123; seg[index][i][0] = min(seg[index &lt;&lt; 1][i][0], seg[index &lt;&lt; 1 ^ 1][i][0]); seg[index][i][1] = max(seg[index &lt;&lt; 1][i][1], seg[index &lt;&lt; 1 ^ 1][i][1]); &#125; &#125;&#125;void push_down(int begin, int end, int index, int l, int r) &#123; if (begin &gt;= l &amp;&amp; end &lt;= r) &#123; for (int i = 0; i ^ size; ++i) &#123; cal[i][0] = min(cal[i][0], seg[index][i][0]); cal[i][1] = max(cal[i][1], seg[index][i][1]); &#125; return; &#125; int mid = begin + end &gt;&gt; 1; if (mid &gt;= l) push_down(begin, mid, index &lt;&lt; 1, l, r); if (mid &lt; r) push_down(mid + 1, end, index &lt;&lt; 1 ^ 1, l, r);&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; size = 1 &lt;&lt; k; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j ^ k; ++j) cin &gt;&gt; b[j]; for (int j = 0; j ^ 1 &lt;&lt; k; ++j) for (int l = 0; l ^ k; ++l) j &amp; (1 &lt;&lt; l) ? a[i][j] += b[l] : a[i][j] -= b[l]; &#125; build(1, n, 1); int q; cin &gt;&gt; q; while (q--) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; int pos; cin &gt;&gt; pos; for (int i = 0; i ^ k; ++i) cin &gt;&gt; b[i]; memset(a[pos], 0, size * sizeof (int)); for (int i = 0; i ^ size; ++i) for (int j = 0; j ^ k; ++j) i &amp; (1 &lt;&lt; j) ? a[pos][i] += b[j] : a[pos][i] -= b[j]; push_up(pos); &#125; else &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; for (int i = 0; i ^ size; ++i) cal[i][0] = ~(1 &lt;&lt; 31), cal[i][1] = 1 &lt;&lt; 31; push_down(1, n, 1, l, r); int res = 0; for (int i = 0; i ^ size; ++i) res = max(res, cal[i][1] - cal[i][0]); cout &lt;&lt; res &lt;&lt; endl; &#125; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 532 (Div. 2)","slug":"Codeforces Round 532 (Div. 2)","date":"2019-01-17T14:07:58.033Z","updated":"2019-02-07T13:04:13.353Z","comments":true,"path":"2019/01/17/Codeforces Round 532 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round 532 (Div. 2)/","excerpt":"","text":"Codeforces Round #532 (Div. 2) A. Roman and Browser题目大意给定一个长度为$~n~$的$~\\pm1~$串，在不考虑所有角标模$~k~$结果一样的位置上的值，问剩下的和的绝对值的最大值。 题解水题。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n), b(k, 0); for (auto&amp; in : a) cin &gt;&gt; in; int sum = accumulate(a.begin(), a.end(), 0), res = 0; for (int i = 0; i ^ n; ++i) b[i % k] += a[i]; for (auto x : b) res = max(res, abs(sum - x)); cout &lt;&lt; res &lt;&lt; endl;&#125; B. Build a Contest题目大意在可重集合里加入$~m~$个数字，每次加入时如果集合里$~1,~2,~\\dots,~n~$都至少有$~1~$个，则都删去$~1~$个然后输出$~1~$，否则输出$~0~$。数据范围$~1\\leq n,~m\\leq10^5~$。 题解直接暴力地维护这个集合时间复杂度为$~O(nm)~$显然会$~\\text{TLE}~$。不做删除操作，而是开$~2~$个数组维护集合：数组$~tot[i]~$表示有多少种数字在集合里至少有$~i~$个；数组$~cnt[i]~$表示数字$~i~$在集合里出现的次数。那么每加入一个数字$~a~$则更新$~cnt[a]~$和$~tot[cnt[a]]~$，输出$~1~$当且仅当$~tot[cnt[a]]=n~$。总时间复杂度为$~O(m)~$。 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; tot(m, 0), cnt(n, 0); int now = 0; while (m--) &#123; int a; cin &gt;&gt; a; ++tot[cnt[a - 1]++]; if (tot[now] == n) &#123; cout &lt;&lt; 1; ++now; &#125; else &#123; cout &lt;&lt; 0; &#125; &#125; cout &lt;&lt; endl;&#125; C. NN and the Optical Illusion题目大意一个中心圆和$~n~$个外圆外切，外圆半径一样且外切构成一个环，给出中心圆半径$~r~$，输出外圆半径$~R~$。 题解平面几何。答案是$~\\frac{r}{\\csc\\frac{\\pi}{n}-1}~$。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; double n, r; cin &gt;&gt; n &gt;&gt; r; printf(\"%.7f\\n\", r / (1 / sin(acos(-1) / n) - 1));&#125; D. Dasha and Chess题目大意交互题。初始在$~999\\times999~$的国际象棋棋盘上有$~\\text{NN}~$的$~1~$个$~\\text{king}~$和$~\\text{Dasha}~$的$~666~$个$~\\text{rook}~$。由$~\\text{NN}~$先走，规则和国际象棋的$~\\text{king}~$一样但是不能走到任意一个$~\\text{rook}~$所在的位置上（不能不动）。如果$~\\text{NN}~$走完后按国际象棋规则被将军，则获胜。这里的$~\\text{rook}~$的规则是任意闪现到空的位置上且不能将军（可以不动）。要求不能超过$~2000~$回合，否则$~\\text{NN}~$失败。 题解别问为什么，先让$~\\text{king}~$走到中心点$~(500,~500)~$。根据抽屉原理，四个角落必有一角落的$~\\text{rook}~$数量不超过$~166~$，于是在某两个方向上的$~\\text{rook}~$数量之和至少是$~500~$，走斜线必然胜利。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;bool vis[1 &lt;&lt; 10][1 &lt;&lt; 10];pair&lt;int, int&gt; chess[667];void query(int x, int y) &#123; vis[chess-&gt;first][chess-&gt;second] = false; if (vis[chess-&gt;first + x][chess-&gt;second + y]) vis[chess-&gt;first][chess-&gt;second += y] = true; else vis[chess-&gt;first += x][chess-&gt;second += y] = true; cout &lt;&lt; chess-&gt;first &lt;&lt; ' ' &lt;&lt; chess-&gt;second &lt;&lt; endl; int k; cin &gt;&gt; k &gt;&gt; x &gt;&gt; y; if (!~k) exit(0); vis[chess[k].first][chess[k].second] = false; vis[chess[k].first = x][chess[k].second = y] = true;&#125;int main() &#123; for (int i = 0; i ^ 667; ++i) &#123; cin &gt;&gt; chess[i].first &gt;&gt; chess[i].second; vis[chess[i].first][chess[i].second] = true; &#125; while (chess-&gt;first &lt; 500) query(1, 0); while (chess-&gt;first &gt; 500) query(-1, 0); while (chess-&gt;second &lt; 500) query(0, 1); while (chess-&gt;second &gt; 500) query(0, -1); int up_left = 0, down_left = 0, up_right = 0, down_right = 0; for (int i = 1; i ^ 1000; ++i) for (int j = 1; j ^ 1000; ++j) if (vis[i][j]) &#123; if (i &lt; 500 &amp;&amp; j &lt; 500) ++up_left; if (i &gt; 500 &amp;&amp; j &lt; 500) ++down_left; if (i &lt; 500 &amp;&amp; j &gt; 500) ++up_right; if (i &gt; 500 &amp;&amp; j &gt; 500) ++down_right; &#125; int minn = min(min(up_left, down_left), min(up_right, down_right)); if (minn == up_left) while(true) query(1, 1); if (minn == down_left) while(true) query(-1, 1); if (minn == up_right) while(true) query(1, -1); if (minn == down_right) while(true) query(-1, -1);&#125; E. Andrew and Taxi题目大意给一个$~n~$个点$~m~$条边的无自环带边权有向图，通过将边的方向翻转使得新图是一个$~\\text{DAG}~$。问所有翻转的边的边权的最大值最小是多少。 题解对答案二分，那么所有当前二分值以下的边都可以选择翻转或者不翻转。这时如果存在一种变为$~\\text{DAG}~$的翻转方式，当且仅当将所有二分值以下的边删除之后的图是$~\\text{DAG}~$。判断是否有环即可，由于还需要输出翻转的方案，所以用拓扑排序。总时间复杂度为$~O((n+m)\\log c)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;vector&lt;int&gt; adj[maxn];bool vis[maxn];int n, m, deg[maxn], topo[maxn];pair&lt;pair&lt;int, int&gt;, int&gt; edge[maxn];bool topo_sort(int lim) &#123; memset(deg, 0, sizeof (deg)); for (int i = 0; i ^ maxn; ++i) adj[i].clear(); for (int i = 1; i &lt;= m; ++i) if (edge[i].second &gt; lim) &#123; adj[edge[i].first.first].push_back(edge[i].first.second); ++deg[edge[i].first.second]; &#125; queue&lt;int&gt; que; for (int i = 0; i ^ maxn; ++i) if (!deg[i]) que.push(i); int rk = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); topo[u] = rk++; for (auto v : adj[u]) if (!--deg[v]) que.push(v); &#125; return rk == maxn;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; edge[i].first.first &gt;&gt; edge[i].first.second &gt;&gt; edge[i].second; int l = -1, r = 0x3f3f3f3f; while (r - l ^ 1) &#123; int m = l + r &gt;&gt; 1; if (topo_sort(m)) r = m; else l = m; &#125; topo_sort(r); vector&lt;int&gt; res; for (int i = 1; i &lt;= m; ++i) if (topo[edge[i].first.first] &gt; topo[edge[i].first.second]) res.push_back(i); cout &lt;&lt; r &lt;&lt; ' ' &lt;&lt; res.size() &lt;&lt; endl; for (auto out : res) &#123; cout &lt;&lt; out; out == res.back() ? cout &lt;&lt; endl : cout &lt;&lt; ' '; &#125;&#125; F. Ivan and Burgers题目大意给定数列$~c_1,~c_2,~\\dots,~c_n~$和$~q~$次询问，问在$~c_l,~c_{l+1},~\\dots,~c_r~$中取若干个数所得到的最大$~\\text{xor}~$和。数据范围$~1\\leq n,~q\\leq5\\cdot10^5,~0\\leq c\\leq10^6~$。 题解显然是个线性基问题，可以用线段树维护，但是递归写法的线段树常数很大会$~\\text{TLE}~$，所以选择常数小的$~\\text{CDQ}~$分治写法。总时间复杂度为$~O((n+q)\\log n\\log c)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 19;int c[maxn];pair&lt;int, int&gt; seg[maxn];struct Vec &#123; vector&lt;int&gt; base; Vec() &#123;base.clear();&#125; Vec(const vector&lt;int&gt;&amp; vec) &#123;base = vec;&#125; bool push(int e) &#123; for (auto v : base) e = min(e, e ^ v); if (e) base.push_back(e); return e; &#125; int max() &#123; int ret = 0; for (auto v : base) ret = std::max(ret, ret ^ v); return ret; &#125; void join(const Vec&amp; vec) &#123;for (auto v : vec.base) push(v);&#125; Vec operator + (const Vec&amp; vec) const &#123; Vec ret(base); ret.join(vec); return ret; &#125; void clear() &#123;base.clear();&#125;&#125;res[maxn], vec[maxn], tmp;void cdq(auto&amp; que,int l, int r) &#123; if (l == r) &#123; for (auto i : que) res[i].push(c[l]); return; &#125; int m = l + r &gt;&gt; 1; tmp.clear(); for (int i = m; i &gt;= l; --i) &#123; tmp.push(c[i]); vec[i] = tmp; &#125; tmp.clear(); for (int i = m + 1; i &lt;= r; ++i) &#123; tmp.push(c[i]); vec[i] = tmp; &#125; vector&lt;int&gt; left, right; for (auto i : que) &#123; if (seg[i].second &lt;= m) left.push_back(i); else if (seg[i].first &gt; m) right.push_back(i); else res[i] = vec[seg[i].first] + vec[seg[i].second]; &#125; que.clear(); cdq(left, l, m); cdq(right, m + 1, r);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; int q; cin &gt;&gt; q; vector&lt;int&gt; que(q); iota(que.begin(), que.end(), 0); for (int i = 0; i ^ q; ++i) cin &gt;&gt; seg[i].first &gt;&gt; seg[i].second; cdq(que, 1, n); for (int i = 0; i ^ q; ++i) cout &lt;&lt; res[i].max() &lt;&lt; '\\n';&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 530 (Div. 2)","slug":"Codeforces Round 530 (Div. 2)","date":"2019-01-17T14:07:58.028Z","updated":"2019-02-07T13:04:10.770Z","comments":true,"path":"2019/01/17/Codeforces Round 530 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round 530 (Div. 2)/","excerpt":"","text":"Codeforces Round #530 (Div. 2) A. Snowball题目大意山坡滚雪球，每秒雪球会增加当前高度的质量然后下落$~1~$米。有$~2~$个石头，每撞一次减少对应的质量最小变为$~0~$。输雪球滚到坡底的质量。 题解水题。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int w, h, u1, d1, u2, d2; cin &gt;&gt; w &gt;&gt; h &gt;&gt; u1 &gt;&gt; d1 &gt;&gt; u2 &gt;&gt; d2; if (d1 &lt; d2) &#123; swap(u1, u2); swap(d1, d2); &#125; for (int i = h; i &gt;= d1; --i) w += i; w = max(0, w - u1); for (int i = d1 - 1; i &gt;= d2; --i) w += i; w = max(0, w - u2); for (int i = d2 - 1; i; --i) w += i; cout &lt;&lt; w &lt;&lt; endl;&#125; B. Squares and Segments要画$~n~$个$~1\\times1~$的正方形格子，每一笔的长度只能为$~1~$。对于以画出的横（竖）的的线段，可以垂直（水平）地平移复制。问至少要画多少不复制的线段。 题解即输出$~\\min(a+b),~ab\\geq n~$。 代码1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int sqr = sqrt(n + 0.5); if (sqr * sqr == n) cout &lt;&lt; (sqr &lt;&lt; 1) &lt;&lt; endl; else if (sqr * sqr + sqr &gt;= n) cout &lt;&lt; (sqr &lt;&lt; 1) + 1 &lt;&lt; endl; else cout &lt;&lt; (sqr + 1 &lt;&lt; 1) &lt;&lt; endl;&#125; C. Postcard题目大意给一个小写字母和?*组成的字符串。字符?代表前一个字母可以删除或保留，字符*代表前一个字母可以删除或保留或重复若干次。输出任意由它生成的长度为$~k~$的字符串或不存在。 题解直接模拟。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; int k; cin &gt;&gt; str &gt;&gt; k; int cnt = 0, tot = 0; for (auto ch : str) &#123; if (ch == '?') ++cnt; if (ch == '*') ++tot; &#125; if (k &lt; str.size() - (cnt + tot &lt;&lt; 1) || !tot &amp;&amp; k &gt; str.size() - cnt) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; string res; int rem = k - str.size() + cnt + tot; if (rem &gt; 0) &#123; bool flag = true; for (auto ch : str) &#123; if (isalpha(ch)) res.push_back(ch); if (ch == '*' &amp;&amp; flag) &#123; flag = false; while (rem--) res.push_back(res.back()); &#125; &#125; &#125; else &#123; for (auto ch : str) &#123; if (isalpha(ch)) &#123; res.push_back(ch); &#125; else if (rem) &#123; res.pop_back(); ++rem; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. Sum in the tree题目大意有一颗非负点权树，根的深度为$~1~$。给出根到所有奇数深度的点的链上的点权值之和$~s_u=\\sum_{v\\in L(1,~u)}a_v,~2\\nmid dep_u~$。输出最小的可能的点权之和$~\\sum_{i=1}^{n}a_i~$或不存在。 题解对于偶数度数的点的$~s_u~$值，取所有儿子的最大值，再和它的父亲比较合法性即可。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; son(n + 1); vector&lt;int&gt; p(n + 1); vector&lt;long long&gt; s(n + 1, 0); for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i]; son[p[i]].push_back(i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; if (~s[i] &amp;&amp; i ^ 1 &amp;&amp; s[i] &lt; s[p[p[i]]]) return cout &lt;&lt; -1 &lt;&lt; endl, 0; &#125; queue&lt;int&gt; que; que.push(1); long long res = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (auto v : son[u]) que.push(v); if (!~s[u]) &#123; s[u] = 0x3f3f3f3f3f3f3f3f; for (auto v : son[u]) s[u] = min(s[u], s[v]); if (s[u] == 0x3f3f3f3f3f3f3f3f) s[u] = s[p[u]]; &#125; res += s[u] - s[p[u]]; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; E. Nice table题目大意给一个由$~\\text{ATCG}~$组成的字母矩阵，输出一个同样大小的的字母矩阵满足所有$~2\\times2~$均由$~\\text{ATCG}~$组成，且使的两矩阵尽量相同。 题解对于任意的合法矩阵，若第$~1~$行的字母超过$~2~$个，则不难推断出每列均由$~2~$个字母组成且奇偶性相同的列所用的字母组成一样。于是合法矩阵必满足每行（或列）均由$~2~$个字母组成，且相同的行（或列）所用的字母组成一样。枚举头$~2~$个字母组成的所有情况即可。考验代码能力。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;char&gt; ch&#123;'A', 'T', 'C', 'G'&#125;; vector&lt;int&gt; p(4); iota(p.begin(), p.end(), 0); int n, m; cin &gt;&gt; n &gt;&gt; m; string res, str, tmp(n * m, '#'); for (int i = 0; i ^ n * m; ++i) &#123; char ch; cin &gt;&gt; ch; str += ch; &#125; int same = 0; do &#123; int tot = 0, cnt[2]; for (int i = 0; i ^ n; ++i) &#123; cnt[0] = cnt[1] = 0; for (int j = 0; j ^ m; ++j) for (int k = 0; k ^ 2; ++k) if (str[i * m + j] == ch[p[(i &amp; 1) &lt;&lt; 1 ^ k]]) ++cnt[(j ^ k) &amp; 1]; if (cnt[0] &lt; cnt[1]) for (int j = 0; j ^ m; ++j) tmp[i * m + j] = ch[p[(i &amp; 1) &lt;&lt; 1 ^ j &amp; 1 ^ 1]]; else for (int j = 0; j ^ m; ++j) tmp[i * m + j] = ch[p[(i &amp; 1) &lt;&lt; 1 ^ j &amp; 1]]; tot += max(cnt[0], cnt[1]); &#125; if (same &lt; tot) &#123; same = tot; res = tmp; &#125; tot = 0; for (int j = 0; j ^ m; ++j) &#123; cnt[0] = cnt[1] = 0; for (int i = 0; i ^ n; ++i) for (int k = 0; k ^ 2; ++k) if (str[i * m + j] == ch[p[(j &amp; 1) &lt;&lt; 1 ^ k]]) ++cnt[(i ^ k) &amp; 1]; if (cnt[0] &lt; cnt[1]) for (int i = 0; i ^ n; ++i) tmp[i * m + j] = ch[p[(j &amp; 1) &lt;&lt; 1 ^ i &amp; 1 ^ 1]]; else for (int i = 0; i ^ n; ++i) tmp[i * m + j] = ch[p[(j &amp; 1) &lt;&lt; 1 ^ i &amp; 1]]; tot += max(cnt[0], cnt[1]); &#125; if (same &lt; tot) &#123; same = tot; res = tmp; &#125; &#125; while (next_permutation(p.begin(), p.end())); for (int i = 0; i ^ n; ++i) &#123; for (int j = 0; j ^ m; ++j) cout &lt;&lt; res[i * m + j]; cout &lt;&lt; endl; &#125;&#125; F. Cookies题目大意给定一颗大小为$~n~$的树，根为$~1~$，每个节点上$~i~$有$~x_i~$个饼干，每个饼干要花费$~t_i~$的时间吃掉，经过连接节点$~u\\neq1~$和它父亲的边的时间花费为$~l_u~$。游戏开始前$~\\text{Mitya}~$在根节点，每一回合$~\\text{Mitya}~$走向当前节点的某一儿子，然后$~\\text{Vasya}~$剪去$~\\text{Mitya}~$所在节点与某一儿子的路径。当$~\\text{Mitya}~$选择结束时他必须通过简单路径走回根节点，过程中可以吃路上的饼干。在总时间花费不超过$~T~$的条件下，问$~\\text{Mitya}~$最多能吃多少饼干。数据范围$~2\\leq n\\leq10^5,~1\\leq T\\leq10^{18},~1\\leq x_i\\leq10^6,~1\\leq t_i\\leq10^6,~0\\leq l_i\\leq10^9~$。 题解先不考虑$~\\text{Vasya}~$的选择。对于每个节点$~u~$，计算它到根节点的路径上$~\\text{Mitya}~$最多能吃到的饼干数量$~cal_u~$。显然为了最大化$~cal_u~$，必须先吃路径上花费时间少的饼干。注意到$~t~$的数据范围，那么可以在$~\\text{dfs}~$过程中维护节点$~u~$到根节点的$~L(u,~1)~$这条路径上单位时间花费为$~t~$的饼干数量$~cnt_t~$。于是当前节点的答案就是在$~T-2\\sum_v l_v,~v\\in L(u,~1)~$的范围内最大化$~cnt~$的前缀和。这个过程可以用二分树状数组，线段树二分，或者树状数组二分来维护。在计算出所有的$~cal_i,~1\\leq i\\leq n~$之后，考虑终点在节点$~u~$的子树上时的答案$~res_u~$。若$~u~$为叶节点，则$~res_u=cal_u~$。若$~u~$为非根非叶节点，考虑到$~\\text{Vasya}~$的存在，则$~res_u=\\max(cal_u,~res_v)~$，其中$~res_v~$为$~u~$的所有儿子的次大$~res~$值给根节点$~1~$增加一个$~cal=\\inf~$的儿子，则可以$~\\text{DFS}~$线性地计算出最终答案$~res_1~$。总时间复杂度为：二分树状数组$~O(n\\log^2n)~$，线段树二分$~O(n\\log n)~$，树状数组二分$~O(n\\log n)~$。据说我的树状数组二分写法就是$~\\text{zkw}~$，但是由于$~\\text{Codeforces}~$的玄学优化，上面$~3~$种数据结构速度基本一样。。。 代码（二分树状数组$~O(n\\log^2n)~$）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;const int maxt = 1 &lt;&lt; 20;int p[maxn], t[maxn];bool vis[maxn], cut[maxn];long long x[maxn], l[maxn], cal[maxn], bit1[maxt], bit2[maxt];vector&lt;int&gt; son[maxn];#define lowbit(x) (x &amp; -x)void dfs1(int u, long long rem) &#123; rem -= l[u] &lt;&lt; 1; for (int i = t[u]; i &lt; maxt; i += lowbit(i)) bit1[i] += x[u], bit2[i] += x[u] * t[u]; if (rem &gt; 0) &#123; int l = 0, r = maxt - 1; long long sum = 0; for (int i = r; i; i -= lowbit(i)) cal[u] += bit1[i], sum += bit2[i]; if (sum &gt; rem) &#123; while (r - l ^ 1) &#123; int mid = l + r &gt;&gt; 1; sum = 0; for (int i = mid; i; i -= lowbit(i)) sum += bit2[i]; if (sum &gt; rem) r = mid; else l = mid; &#125; cal[u] = sum = 0; for (int i = l; i; i -= lowbit(i)) cal[u] += bit1[i], sum += bit2[i]; cal[u] += (rem - sum) / r; &#125; &#125; for (auto v : son[u]) dfs1(v, rem); for (int i = t[u]; i &lt; maxt; i += lowbit(i)) bit1[i] -= x[u], bit2[i] -= x[u] * t[u];&#125;long long dfs2(int u) &#123; long long max1 = u ^ 1 ? 0 : 0x3f3f3f3f3f3f3f3f, max2 = 0; for (auto v : son[u]) &#123; long long temp = dfs2(v); if (max2 &lt; temp) max2 = temp; if (max1 &lt; max2) swap(max1, max2); &#125; return max(max2, cal[u]);&#125;int main() &#123; int n; long long T; cin &gt;&gt; n &gt;&gt; T; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; x[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; t[i]; for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i] &gt;&gt; l[i]; son[p[i]].push_back(i); &#125; dfs1(1, T); cout &lt;&lt; dfs2(1) &lt;&lt; endl;&#125; 代码（线段树二分$~O(n\\log n)~$）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;const int maxt = 1 &lt;&lt; 20;int p[maxn], t[maxn];long long x[maxn], l[maxn], cal[maxn], seg1[maxt &lt;&lt; 2], seg2[maxt &lt;&lt; 2];vector&lt;int&gt; son[maxn];void push_up(int begin, int end, int index, int pos, long long del) &#123; seg1[index] += del; seg2[index] += del * pos; if (begin + 1 == end) return; int mid = begin + end &gt;&gt; 1; if (pos &gt; mid) push_up(mid, end, index &lt;&lt; 1 ^ 1, pos, del); else push_up(begin, mid, index &lt;&lt; 1, pos, del);&#125;long long push_down(int begin, int end, int index, long long rem) &#123; if (begin + 1 == end) return min(rem / end, seg1[index]); int mid = begin + end &gt;&gt; 1; return rem &lt; seg2[index &lt;&lt; 1] ? push_down(begin, mid, index &lt;&lt; 1, rem) : seg1[index &lt;&lt; 1] + push_down(mid, end, index &lt;&lt; 1 ^ 1, rem - seg2[index &lt;&lt; 1]); &#125;void dfs1(int u, long long rem) &#123; push_up(0, maxt, 1, t[u], x[u]); if ((rem -= l[u] &lt;&lt; 1) &gt; 0) cal[u] = push_down(0, maxt, 1, rem); for (auto v : son[u]) dfs1(v, rem); push_up(0, maxt, 1, t[u], -x[u]);&#125;long long dfs2(int u) &#123; long long max1 = u ^ 1 ? 0 : 0x3f3f3f3f3f3f3f3f, max2 = 0; for (auto v : son[u]) &#123; long long temp = dfs2(v); if (max2 &lt; temp) max2 = temp; if (max1 &lt; max2) swap(max1, max2); &#125; return max(max2, cal[u]);&#125;int main() &#123; int n; long long T; cin &gt;&gt; n &gt;&gt; T; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; x[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; t[i]; for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i] &gt;&gt; l[i]; son[p[i]].push_back(i); &#125; dfs1(1, T); cout &lt;&lt; dfs2(1) &lt;&lt; endl;&#125; 代码（树状数组二分$~O(n\\log n)~$）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;const int maxt = 1 &lt;&lt; 20;int p[maxn], t[maxn];bool vis[maxn], cut[maxn];long long x[maxn], l[maxn], cal[maxn], bit1[maxt + 1], bit2[maxt + 1];vector&lt;int&gt; son[maxn];#define lowbit(x) (x &amp; -x)void dfs1(int u, long long rem) &#123; for (int i = t[u]; i &lt; maxt; i += lowbit(i)) bit1[i] += x[u], bit2[i] += x[u] * t[u]; int now = maxt; long long temp = (rem -= l[u] &lt;&lt; 1); for (int i = maxt, j = 0; rem &gt; 0; i &gt;&gt;= 1) &#123; if (i == 1) &#123; cal[u] += j &amp; 1 ? min(temp / (j + 1), bit1[j + 1] - bit1[j]) : min(temp / (j ^ 1), bit1[j ^ 1]); break; &#125; if (temp &gt; bit2[i &gt;&gt; 1 ^ j]) &#123; cal[u] += bit1[i &gt;&gt; 1 ^ j]; temp -= bit2[i &gt;&gt; 1 ^ j]; j ^= i &gt;&gt; 1; &#125; &#125; for (auto v : son[u]) dfs1(v, rem); for (int i = t[u]; i &lt; maxt; i += lowbit(i)) bit1[i] -= x[u], bit2[i] -= x[u] * t[u];&#125;long long dfs2(int u) &#123; long long max1 = u ^ 1 ? 0 : 0x3f3f3f3f3f3f3f3f, max2 = 0; for (auto v : son[u]) &#123; long long temp = dfs2(v); if (max2 &lt; temp) max2 = temp; if (max1 &lt; max2) swap(max1, max2); &#125; return max(max2, cal[u]);&#125;int main() &#123; int n; long long T; cin &gt;&gt; n &gt;&gt; T; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; x[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; t[i]; for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i] &gt;&gt; l[i]; son[p[i]].push_back(i); &#125; dfs1(1, T); cout &lt;&lt; dfs2(1) &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 530 (Div. 1) (TBC)","slug":"Codeforces Round 530 (Div. 1) (TBC)","date":"2019-01-17T14:07:58.024Z","updated":"2019-02-07T13:04:08.724Z","comments":true,"path":"2019/01/17/Codeforces Round 530 (Div. 1) (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round 530 (Div. 1) (TBC)/","excerpt":"","text":"Codeforces Round #530 (Div. 1) A. Sum in the tree题目大意有一颗非负点权树，根的深度为$~1~$。给出根到所有奇数深度的点的链上的点权值之和$~s_u=\\sum_{v\\in L(1,~u)}a_v,~2\\nmid dep_u~$。输出最小的可能的点权之和$~\\sum_{i=1}^{n}a_i~$或不存在。 题解对于偶数度数的点的$~s_u~$值，取所有儿子的最大值，再和它的父亲比较合法性即可。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; son(n + 1); vector&lt;int&gt; p(n + 1); vector&lt;long long&gt; s(n + 1, 0); for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i]; son[p[i]].push_back(i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; if (~s[i] &amp;&amp; i ^ 1 &amp;&amp; s[i] &lt; s[p[p[i]]]) return cout &lt;&lt; -1 &lt;&lt; endl, 0; &#125; queue&lt;int&gt; que; que.push(1); long long res = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (auto v : son[u]) que.push(v); if (!~s[u]) &#123; s[u] = 0x3f3f3f3f3f3f3f3f; for (auto v : son[u]) s[u] = min(s[u], s[v]); if (s[u] == 0x3f3f3f3f3f3f3f3f) s[u] = s[p[u]]; &#125; res += s[u] - s[p[u]]; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; B. Nice table题目大意给一个由$~\\text{ATCG}~$组成的字母矩阵，输出一个同样大小的的字母矩阵满足所有$~2\\times2~$均由$~\\text{ATCG}~$组成，且使的两矩阵尽量相同。 题解对于任意的合法矩阵，若第$~1~$行的字母超过$~2~$个，则不难推断出每列均由$~2~$个字母组成且奇偶性相同的列所用的字母组成一样。于是合法矩阵必满足每行（或列）均由$~2~$个字母组成，且相同的行（或列）所用的字母组成一样。枚举头$~2~$个字母组成的所有情况即可。考验代码能力。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;char&gt; ch&#123;'A', 'T', 'C', 'G'&#125;; vector&lt;int&gt; p(4); iota(p.begin(), p.end(), 0); int n, m; cin &gt;&gt; n &gt;&gt; m; string res, str, tmp(n * m, '#'); for (int i = 0; i ^ n * m; ++i) &#123; char ch; cin &gt;&gt; ch; str += ch; &#125; int same = 0; do &#123; int tot = 0, cnt[2]; for (int i = 0; i ^ n; ++i) &#123; cnt[0] = cnt[1] = 0; for (int j = 0; j ^ m; ++j) for (int k = 0; k ^ 2; ++k) if (str[i * m + j] == ch[p[(i &amp; 1) &lt;&lt; 1 ^ k]]) ++cnt[(j ^ k) &amp; 1]; if (cnt[0] &lt; cnt[1]) for (int j = 0; j ^ m; ++j) tmp[i * m + j] = ch[p[(i &amp; 1) &lt;&lt; 1 ^ j &amp; 1 ^ 1]]; else for (int j = 0; j ^ m; ++j) tmp[i * m + j] = ch[p[(i &amp; 1) &lt;&lt; 1 ^ j &amp; 1]]; tot += max(cnt[0], cnt[1]); &#125; if (same &lt; tot) &#123; same = tot; res = tmp; &#125; tot = 0; for (int j = 0; j ^ m; ++j) &#123; cnt[0] = cnt[1] = 0; for (int i = 0; i ^ n; ++i) for (int k = 0; k ^ 2; ++k) if (str[i * m + j] == ch[p[(j &amp; 1) &lt;&lt; 1 ^ k]]) ++cnt[(i ^ k) &amp; 1]; if (cnt[0] &lt; cnt[1]) for (int i = 0; i ^ n; ++i) tmp[i * m + j] = ch[p[(j &amp; 1) &lt;&lt; 1 ^ i &amp; 1 ^ 1]]; else for (int i = 0; i ^ n; ++i) tmp[i * m + j] = ch[p[(j &amp; 1) &lt;&lt; 1 ^ i &amp; 1]]; tot += max(cnt[0], cnt[1]); &#125; if (same &lt; tot) &#123; same = tot; res = tmp; &#125; &#125; while (next_permutation(p.begin(), p.end())); for (int i = 0; i ^ n; ++i) &#123; for (int j = 0; j ^ m; ++j) cout &lt;&lt; res[i * m + j]; cout &lt;&lt; endl; &#125;&#125; C. Construct a tree题目大意给定两个数$~n~$和$~s~$，输出一个大小为$~n~$的树满足所有子树的大小之和为$~s~$或不存在，若存在输出的树必须满足最大分叉$~k~$尽量小。数据范围$~2\\leq n\\leq10^5,~1\\leq s\\leq10^{10}~$。 题解考虑所有节点$~u~$对于$~s~$的贡献，当且仅当子树的根$~v~$为$~u~$的祖先时，$~u~$才会对答案贡献$~1~$。所以$~s=\\sum_{i=1}^{n}dep_i\\in[2n-1,~\\frac{n(n+1)}{2}]~$。对于$~k~$叉树，$~s~$值的下限随着$~k~$增大减小。所以考虑二分，可以得出最小的$~k~$值。先构造出最小的$~k-1~$叉树，然后移动深的点即可。时间复杂度为$~O(n\\log n)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int num[maxn], lim[maxn], dep[maxn], sta[maxn], son[maxn];int main() &#123; int n; long long s; cin &gt;&gt; n &gt;&gt; s; if (1LL * n * (n + 1) &lt; s &lt;&lt; 1 || n &lt;&lt; 1 &gt; s + 1) return cout &lt;&lt; \"No\" &lt;&lt; endl, 0; cout &lt;&lt; \"Yes\" &lt;&lt; endl; if (1LL * n * (n + 1) == s &lt;&lt; 1) &#123; cout &lt;&lt; 1; for (int i = 2; i ^ n; ++i) cout &lt;&lt; ' ' &lt;&lt; i; cout &lt;&lt; endl; return 0; &#125; int l = 1, r = n - 1; while (r - l ^ 1) &#123; int m = l + r &gt;&gt; 1; long long rem = n - 1, cnt = 1, cal = 1; for (int i = 2; rem; ++i) &#123; cnt *= m; if (rem &lt; cnt) cal += rem * i, rem = 0; else cal += cnt * i, rem -= cnt; &#125; cal &gt; s ? (l = m) : (r = m); &#125; int right = r; long long flr = 1; for (int i = 1, tot = 0; tot ^ n; ++i, flr *= l) &#123; if (tot + flr &gt; n) num[i] = n - tot, tot = n; else num[i] = flr, tot += flr; &#125; lim[1] = 1; for (int i = 1; 1LL * lim[i] * r &lt; n &lt;&lt; 1; ++i) lim[i + 1] = lim[i] * r; long long cnt = 0; for (r = 1; num[r]; ++r) cnt += 1LL * r * num[r]; l = 2; cnt -= s; while (cnt) &#123; if (num[l] == lim[l]) ++l; if (!num[r]) --r; if (cnt &lt; r - l) &#123; --num[r]; ++num[r - cnt]; break; &#125; --num[r]; ++num[l]; cnt += l - r; &#125; sta[1] = 1; for (int i = 1, d = 1; i &lt;= n; ++i) &#123; dep[i] = d; if (!--num[d]) sta[++d] = i + 1; &#125; for (int i = 2; i ^ n; ++i) &#123; cout &lt;&lt; sta[dep[i] - 1] &lt;&lt; ' '; if (++son[sta[dep[i] - 1]] == right) ++sta[dep[i] - 1]; &#125; cout &lt;&lt; sta[dep[n] - 1] &lt;&lt; endl;&#125; D. Eels题目大意大鱼吃小鱼，小鱼吃虾米。鱼缸里如果有$~n~$条鱼，则会发生$~n-1~$次生死$~\\text{solo}~$，最终一人吃鸡。小鱼被大鱼吃掉后质量也送给了大鱼，类似于球球大作战。定义质量为$~a\\leq b~$的两条鱼生死$~\\text{solo}~$是危险的，如果$~a\\leq b\\leq2a~$。一个鱼缸的危险值定义为最多可能发生的危险$~\\text{solo}~$次数。最开始鱼缸为空，每次加一条或者减一条质量为$~x~$的鱼，输出每次的危险值。数据范围$~1\\leq q\\leq5\\cdot10^5,~1\\leq x\\leq10^9~$。 题解对所有鱼的质量升序得到$~a_1,~a_2,~\\dots,~a_n~$。定义如果$~a_i&gt;2\\sum_{j&lt; i}a_j~$，则称它为肥鱼（算上第一只$~a_1~$）。设当前鱼缸有$~k~$只肥鱼，则下面证明危险值为$~n-k~$： 对于肥鱼，它一定不会在危险$~\\text{solo}~$中作为大鱼出现，所以危险值的上限为$~n-k~$。 在每次选择最小的两只鱼$~\\text{solo}~$，这样危险$~\\text{solo}~$的总次数为$~n-k~$。所以现在对于每次操作，算出当前的$~k~$值即可。考虑区间$~[1,~2),~[2,~4),~\\dots,~[2^m,~2^{m+1}),~\\dots~$，显然每个区间至多一只肥鱼。那么用$~\\text{multiset}~$来维护每个区间的鱼，这样每次操作就能在$~O(\\log q\\log x)~$内算出$~k~$值。总时间复杂度为$~O(q\\log q\\log x)~$。 注意数据范围过大，可能需要$~\\text{fastIO}~$。 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); multiset&lt;long long&gt; seg[32]; long long sum[32] = &#123;0&#125;; int q, cnt = 0; cin &gt;&gt; q; while (q--) &#123; char op; long long x; cin &gt;&gt; op &gt;&gt; x; int idx = 0; for (int i = 1; i &lt; x; i &lt;&lt;= 1, ++idx); if (op == '+') &#123; seg[idx].insert(x); sum[idx] += x; ++cnt; &#125; else &#123; seg[idx].erase(seg[idx].find(x)); sum[idx] -= x; --cnt; &#125; int res = cnt; long long tot = 0; for (int i = 0; i ^ 32; tot += sum[i++]) if (sum[i] &amp;&amp; *(seg[i].begin()) &gt; tot &lt;&lt; 1) --res; cout &lt;&lt; res &lt;&lt; '\\n'; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 527 (Div. 3) (TBC)","slug":"Codeforces Round 527 (Div. 3) (TBC)","date":"2019-01-17T14:07:58.020Z","updated":"2019-02-07T13:04:06.866Z","comments":true,"path":"2019/01/17/Codeforces Round 527 (Div. 3) (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round 527 (Div. 3) (TBC)/","excerpt":"","text":"Codeforces Round #527 (Div. 3) A. Uniform String题目大意输出任意长度为$~n~$且由前$~k~$个小写字母组成的串，要求出现次数最少的尽量多。 题解水题。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; while (n--) cout &lt;&lt; char('a' + n % k); cout &lt;&lt; endl; &#125;&#125; B. Teams Forming题目大意给$~n~$个数字，每个数字可以加若干次$~1~$，求最少次数使得这$~n~$个数字可以两两配对，每对都一样大。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, a[100]; cin &gt;&gt; n; for (int i = 0; i ^ n; ++i) cin &gt;&gt; a[i]; sort(a, a + n); int res = 0; for (int i = 0; i ^ n; ++i) res += i &amp; 1 ? a[i] : -a[i]; cout &lt;&lt; res &lt;&lt; endl;&#125; C. Prefixes and Suffixes题目大意一个长度为$~n~$的串的$~n-1~$个前缀和后缀打乱顺序给出。输出任意合法的划分，使得存在一个长度为$~n~$的串，它的所有前缀和后缀均和该划分一致。 题解暴力先枚举两个给定串合成的长度为$~n~$的串然后判断。代码的时间复杂度上限是$~O(n^3)~$，但在枚举的过程中最多$~4~$次即可枚举出合法的原串，所以实际时间复杂度为$~O(n^2)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int size = n - 1 &lt;&lt; 1; vector&lt;string&gt; strs(size), fuck[n]; for (auto&amp; str : strs) &#123; cin &gt;&gt; str; fuck[(int)str.size()].push_back(str); &#125; set&lt;string&gt; ggsimida; for (int i = 1; i ^ n; ++i) for (int j = 0; j ^ 2; ++j) for (int k = 0; k ^ 2; ++k) &#123; string now = fuck[i][j] + fuck[n - i][k]; if (ggsimida.find(now) != ggsimida.end()) continue; vector&lt;bool&gt; use(size, false); string res(size, 0); int cal = 0; for (int len = 1; len ^ n; ++len) &#123; string pre(now, 0, len); for (int idx = 0; idx ^ size; ++idx) if (!use[idx] &amp;&amp; strs[idx] == pre) &#123; use[idx] = true; res[idx] = 'P'; ++cal; break; &#125; string suf(now, len, n - len); for (int idx = 0; idx ^ size; ++idx) if (!use[idx] &amp;&amp; strs[idx] == suf) &#123; use[idx] = true; res[idx] = 'S'; ++cal; break; &#125; &#125; if (cal == size) return cout &lt;&lt; res &lt;&lt; endl, 0; ggsimida.insert(now); &#125;&#125; D1. Great Vova Wall (Version 1)题目大意铺砖，宽度为$~n~$，初始每个位置已经铺了一些$~1\\times1~$的砖在最下面。问是否能继续放若干个$~2\\times1~$的砖（横竖均可），使得最后顶面是平的。 题解考虑黑白染色，可以铺平当前仅当黑白数量一致。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int cnt = 0; while (n--) &#123; int a; cin &gt;&gt; a; (n ^ a) &amp; 1 ? ++cnt : --cnt; &#125; if (abs(cnt) &lt; 2) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl;&#125; D2. Great Vova Wall (Version 2)题目大意上一题的基础上禁止竖着放砖。 题解单调栈模拟。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; stack&lt;int&gt; fuck; int shit = 0; while (n--) &#123; int a; cin &gt;&gt; a; shit = max(shit, a); if (fuck.empty()) fuck.push(a); else if (fuck.top() &lt; a) return cout &lt;&lt; \"NO\" &lt;&lt; endl, 0; else if (fuck.top() == a) fuck.pop(); else fuck.push(a); &#125; if (fuck.empty() || fuck.size() == 1 &amp;&amp; fuck.top() == shit) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl;&#125; E. Minimal Diameter ForestF. Tree with Maximum Cost题目大意给定一个大小为$~n~$的有点权树，两点之间的距离定义为最短路径上的边数。定义$~cost(u)=\\sum_{v=1}^n{dist(u,~v)\\cdot a_i}~$，求$~\\min{cost(u)}~$。 题解考虑相邻两个点$~u~$和$~v~$之间的答案转移。删去$~edge(u,~v)~$，则原树被划分为两个子树，记点集分别为$~S_u~$和$~S_v~$。则有等式 \\begin{aligned} res_u+\\sum_{i\\in S_u}{a_i} &=res_v+\\sum_{S_v}{a_i} \\\\ res_u &=res_v+\\sum_{i=1}^n{a_i}-2\\sum_{i\\in S_u}{a_i} \\\\ \\end{aligned}那么任取一点为根，第一遍$~\\text{DFS}~$找出对于所有子树上子树根的$~cost~$和子树的权值之和$~\\sum_{i\\in S_u}{a_i}~$，第二遍$~\\text{DFS}~$更新所有点的答案。时间复杂度为$~O(n)~$。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;long long a[maxn], res[maxn], ans;vector&lt;int&gt; adj[maxn];long long dfs1(int u = 1, int p = 0) &#123; for (auto v : adj[u]) if (v ^ p) res[u] += dfs1(v, u), a[u] += a[v]; return res[u] += a[u];&#125;void dfs2(int u = 1, int p = 0) &#123; ans = max(ans, res[u] = res[p] + a[1] - (a[u] &lt;&lt; 1)); for (auto v : adj[u]) if (v ^ p) dfs2(v, u);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; while (--n) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; res[0] = dfs1(); dfs2(); cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 526 (Div. 2) (TBC)","slug":"Codeforces Round 526 (Div. 2) (TBC)","date":"2019-01-17T14:07:58.013Z","updated":"2019-02-07T13:04:04.119Z","comments":true,"path":"2019/01/17/Codeforces Round 526 (Div. 2) (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round 526 (Div. 2) (TBC)/","excerpt":"","text":"Codeforces Round #526 (Div. 2) A. The Fair Nut and Elevator题目大意有$~N~$个楼层，第$~i~$层住着$~a_i~$个人。每天每人都要坐两次电梯，第一次从第$~i~$层坐电梯到第$~1~$层，第二次从第$~1~$层坐电梯到第$~i~$层。电梯一次只能载一个人且有一个初始位置第$~x~$层。电梯的运行每次必须先从第$~x~$层到起点层，再到终点层，再回到$~x~$层。求$~x~$的最优解使得每天电梯的运行距离最短，输出这个最短距离。 题解水题。贪心。显然$~x=1~$是最优解。输出$~4\\sum a_i(i-1)~$即可。证明略。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int res = 0; for (int i = 0; i ^ n; ++i) &#123; int a; cin &gt;&gt; a; res += a * i; &#125; cout &lt;&lt; (res &lt;&lt; 2) &lt;&lt; endl;&#125; B. Kvass and the Fair Nut题目大意给定$~n~$个数$~v_1,~v_2,~\\dots,~v_n~$，让他们一共减去$~s~$，使得最小值最大，输出这个最小值。 题解贪心。有巨坑。说多都是泪。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; long long s; cin &gt;&gt; n &gt;&gt; s; long long minn = 0x3f3f3f3f3f3f3f3f, sum = 0; for (int i = 0; i ^ n; ++i) &#123; long long v; cin &gt;&gt; v; minn = min(minn, v); sum += v; &#125; if (sum &lt; s) cout &lt;&lt; -1 &lt;&lt; endl; else if (n * minn + s &lt; sum) cout &lt;&lt; minn &lt;&lt; endl; else cout &lt;&lt; (sum - s) / n &lt;&lt; endl;&#125; C. The Fair Nut and String题目大意给定一个小写字母串，求生成的全$~a~$串数量，满足相邻的两个$~a~$在原串中必有一个$~b~$在这两个$~a~$之间。 题解水题。原串中相邻的两个$~b~$之间若有$~n~$个$~a~$，则至多在这$~n~$个$~a~$中选$~1~$个，显然有$~n+1~$种选法（包括不选）。答案则是$~{\\prod(n_i+1)}-1~$，因为要减去空串。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; const int mod = 1e9 + 7; int res = 1, cnt = 1; for (auto ch : str) &#123; if (ch == 'a') ++cnt; if (ch == 'b') res = 1LL * res * cnt % mod, cnt = 1; &#125; cout &lt;&lt; 1LL * res * cnt % mod - 1 &lt;&lt; endl;&#125; D. The Fair Nut and the Best Path题目大意给一个树，有非负整数点权$~w~$和正整数边权$~c~$，一条链的值为$~\\sum{w}-\\sum{c}~$。求出最大的链值（单个点视为退化链也算）。 题解树形$~\\text{DP}~$。任取一个点为树根，每个点记录以它为一个端点，另一个端点为它后代的最大链值$~x~$，对于叶子有$~x=c~$。那么考虑经过点$~u~$且在以$~u~$为根的子树上的链的最大值$~max_u~$，对$~u~$的所有儿子$~v~$的$~x_v~$值与连接它们的边权$~w_v~$做差，加入两个$~x=w=0~$的虚点，则可以用这些差$~x_v-w_v~$的最大值来更新$~x_u~$，最大值和次大值来更新$~max_u~$。于是可以在$~\\text{DFS}~$过程中线性地更新出答案。由于数据范围允许时间复杂度为$~O(n\\log{n})~$，于是可以用排序来简化求最大值和次大值的代码。 已更新简便线性做法。 代码（$~O(n\\log{n})~$）123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;long long c[maxn];vector&lt;pair&lt;int, long long&gt;&gt; adj[maxn];long long dfs(int u = 1, int p = 0) &#123; long long ret = 0; vector&lt;long long&gt; sons(2, 0LL); for (auto son : adj[u]) if (son.first ^ p) &#123; ret = max(ret, dfs(son.first, u)); sons.push_back(c[son.first] - son.second); &#125; sort(sons.begin(), sons.end()); reverse(sons.begin(), sons.end()); c[u] += sons[0]; return max(ret, c[u] + sons[1]);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; while (--n) &#123; int u, v; long long w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; adj[u].push_back(make_pair(v, w)); adj[v].push_back(make_pair(u, w)); &#125; cout &lt;&lt; dfs() &lt;&lt; endl;&#125; 代码（$~O(n)~$）123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;long long c[maxn], dp[maxn], res;vector&lt;pair&lt;int, long long&gt;&gt; adj[maxn];void dfs(int u = 1, int p = 0) &#123; res = max(res, dp[u] = c[u]); for (auto v : adj[u]) if (v.first ^ p) &#123; dfs(v.first, u); res = max(res, dp[u] + dp[v.first] - v.second); dp[u] = max(dp[u], c[u] + dp[v.first] - v.second); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; while (--n) &#123; int u, v; long long w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; adj[u].push_back(make_pair(v, w)); adj[v].push_back(make_pair(u, w)); &#125; dfs(); cout &lt;&lt; res &lt;&lt; endl;&#125; E. The Fair Nut and Strings题目大意找出$~k~$个长度为$~n~$且字典序在$~s~$和$~t~$之间的$~ab~$串，使得不一样的前缀的数量最多，输出最大的不同前缀数。 题解考虑所有$~ab~$串构成的$~\\text{trie}~$树，这显然是一个完全二叉树。再考虑所求的$~k~$个$~ab~$串构成的$~\\text{trie}~$树，则答案是节点数量，且第$~i~$层的节点数量至多为$~\\min{|t_i|-|s_i|,~k}~$个。其中$~|str_i|~$表示字符串$~str~$前$~i~$个字符构成的前缀所对应的二进制数值。自上而下模拟更新答案即可。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, k; string s, t; cin &gt;&gt; n &gt;&gt; k &gt;&gt; s &gt;&gt; t; long long res = 1LL * n * k; for (int i = 0, dif = 0; i ^ n &amp;&amp; (dif = (dif &lt;&lt; 1) + (t[i] == 'b') - (s[i] == 'b')) &lt; k; ++i) res -= k - dif - 1; cout &lt;&lt; res &lt;&lt; endl;&#125; F. Max Mex题目大意给一棵大小为$~n~$的树，所有节点的初始值为$~0,~1,~\\dots,~n-1~$的一个全排列。对于这棵树上的任意一条链$~l~$，$~V(l)~$表示$~l~$上所有点的集合。有$~q~$次修改或查询操作，修改为交换$~2~$个节点的值，查询为输出$~\\max{mex(V(l))}~$。 注：$~mex(S)~$表示不在集合$~S~$中的最小自然数，即$~\\min{x\\in\\Bbb{N}:x\\not\\in S}~$。 题解老子现在不会。据说是线段树维护各值所在点之间的连接关系。","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Avito Cool Challenge 2018 (TBC)","slug":"Avito Cool Challenge 2018 (TBC)","date":"2019-01-17T14:07:57.977Z","updated":"2019-01-17T14:08:58.238Z","comments":true,"path":"2019/01/17/Avito Cool Challenge 2018 (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Avito Cool Challenge 2018 (TBC)/","excerpt":"","text":"Avito Cool Challenge 2018 A. Definite Game题目大意给一个正整数$~n~$，每次减去一个互质的数，输出最小结果。 题解水题。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; (n ^ 2 ? 1 : 2) &lt;&lt; endl;&#125; B. Farewell Party题目大意原本有一个数列$~b_1,~b_2,~\\dots,~b_n~$，先已知每个数在这个数列中有多少个其他的数与它不一样的数列$~a_1,~a_2,~\\dots,~a_n~$，输出任意合法的$~{b_n}~$。 题解如果两个数字$~x~$和$~y~$在$~{b_n}~$中出现的次数一样，则对应的$~{a_n}~$也一样于是考虑$~z~$在$~{a_n}~$中出现的次数$~cnt~$，则必有$~cnt\\mid n-z~$。直接模拟即可。 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; arr(n), cnt(n); vector&lt;stack&lt;int&gt;&gt; res(n); for (auto&amp; a : arr) cin &gt;&gt; a, ++cnt[a]; for (int i = 0, now = 1; i ^ n; ++i) &#123; if (cnt[i] % (n - i)) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; for (int j = 0, tot = cnt[i] / (n - i); j ^ tot; ++j, ++now) for (int k = i; k ^ n; ++k) res[i].push(now); &#125; cout &lt;&lt; \"Possible\" &lt;&lt; endl; int last = arr.back(); arr.pop_back(); for (auto a : arr) &#123; cout &lt;&lt; res[a].top() &lt;&lt; ' '; res[a].pop(); &#125; cout &lt;&lt; res[last].top() &lt;&lt; endl;&#125; C. Colorful Bricks题目大意对连续相邻的$~n~$块砖进行$~m~$染色，使得有$~k~$块砖和左边的不一样（第一块不算），求所有染色可能数量。 题解数学推导发现答案就是$~\\binom{n-1}{k}m(m-1)^k~$。 代码1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 1 &lt;&lt; 11;int inv[maxn], fact[maxn], finv[maxn];inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int fpow(int a, int n) &#123; int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; cout &lt;&lt; mul(mul(mul(mul(fact[n - 1], finv[k]), finv[n - k - 1]), m), fpow(m - 1, k)) &lt;&lt; endl;&#125; D. Maximum Distance题目大意一个给定一个$~n~$个点$~m~$条边的联通图（可以有重边自环），有边权$~w_e~$并给定$~k~$个关键点。对于每条简单路径$~L(u,~v)~$，定义路径的花费$~cost(L(u,~v))=\\max_{e\\in L(u,~v)}{w_e}~$。定义距离$~dist(u,~v)=\\min{cost(L(u,~v))}~$。输出离每个关键点最远的关键点的距离。 题解考虑$~\\text{Kruskal}~$做法的最小生成树，那么$~dist(u,~v)~$即为$~\\text{MST}~$上两点间的路径花费。不难发现这时候关键点的最远距离都一样，为$~\\text{Kruskal}~$构造$~\\text{MST}~$过程中第一个联通所有关键点的边权。为维护关键点的连通性，在并查集的过程中不要按秩合并，而是尽量以关键点为父亲，记录合并关键点连通性的次数，到$~k-1~$次时直接输出答案即可。时间复杂度上限为$~O(n\\log n+m\\log m)~$。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int fa[maxn];int find(const int&amp; a) &#123;return fa[a] ^ a ? (fa[a] = find(fa[a])) : a;&#125;int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) fa[i] = i; vector&lt;bool&gt; vip(n + 1, false); for (int i = 0; i ^ k; ++i) &#123; int x; cin &gt;&gt; x; vip[x] = true; &#125; vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; edge(m); for (auto&amp; e : edge) cin &gt;&gt; e.second.first &gt;&gt; e.second.second &gt;&gt; e.first; sort(edge.begin(), edge.end()); int cnt = 1; for (auto e : edge) &#123; int a = find(e.second.first); int b = find(e.second.second); if (a == b) continue; if (vip[a]) fa[b] = a; else fa[a] = b; if (vip[a] &amp;&amp; vip[b]) if (++cnt == k) &#123; for (int i = 1; i ^ k; ++i) cout &lt;&lt; e.first &lt;&lt; ' '; cout &lt;&lt; e.first &lt;&lt; endl; return 0; &#125; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"区间DP与平行四边形优化","slug":"区间DP与平行四边形优化","date":"2019-01-17T13:54:41.803Z","updated":"2019-02-14T08:59:34.931Z","comments":true,"path":"2019/01/17/区间DP与平行四边形优化/","link":"","permalink":"http://yoursite.com/2019/01/17/区间DP与平行四边形优化/","excerpt":"","text":"区间DP对于询问区间最优解的问题，可以先考虑较小区间的最优解，然后通过合并小区间得到大区间最有解。动态规划状态转移式 dp[i][j]=\\min\\{dp[i][k]+dp[k+1][j]\\}+f[i][j]算法实现过程中通常要用到三层$~\\text{for}~$循环，从外到里分别维护区间宽度$~j-i~$，区间端点$~i~$和区间分割点$~k~$，复杂度为$~O(N^3)~$。 四边形不等式如果$~\\forall~a\\leq b\\leq c\\leq d~$，$~f~$满足 f(a,~c)+f(b,~d)\\leq f(a,~d)+f(b,~c)则称$~f~$满足四边形不等式。 区间包含单调性如果$~\\forall~I_1\\subseteq I_2~$，$~f~$满足f(I_1)\\leq f(I_2)则称$~f~$满足区间包含单调性。 平行四边形优化考虑状态转移过程中的最优转移点，记$~k[i][j]~$为$~dp[i][j]~$的最优转移点，即 dp[i][j]=dp[i][k[i]][j]]+dp[k[i][j]+1][j]+f[i][j]如果$~dp~$和$~f~$都满足四边形不等式和区间包含单调性，则必有 k[i][j-1]\\leq k[i][j]\\leq k[i+1][j]那么缩小状态转移点的区间范围，在更新$~dp[i][j]~$的同时更新$~k[i][j]~$，时间复杂度可以优化至$~O(n^2)~$。区间范围和时间复杂度的证明目前没看懂，先放个百度百科的链接。反正百度到的CSDN和博客园都是抄来抄去那破尿性，更加看不懂，先凑合着用。 题目HDU3506题目大意给定一个大小为$~N~$的环，每次合并相邻区间$~A~$和$~B~$的花费是$~(\\sum A+\\sum B)*(|A|+|B|)~$，求将这个环合并为一个集合的最小总花费。 题解动态规划，记$~dp[i][j]~$为将$~i,~\\dots,~j~$合并的最小花费。注意到这题是环形数组，则可以将数组扩大一倍，令$~a[n+i]=a[i],~i=1,~2,~\\dots,~n-1~$，同时用平行四边形优化。时间复杂度$~O(N^2)~$。 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 11;int dp[maxn][maxn], s[maxn][maxn], pre[maxn];int main() &#123; int n; while (cin &gt;&gt; n) &#123; memset(dp, 0x3f, sizeof (dp)); for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; pre[i], pre[i + n] = pre[i]; for (int i = 1; i ^ n &lt;&lt; 1; ++i) pre[i] += pre[i - 1], dp[i][i] = 0, s[i][i] = i; for (int len = 1; len ^ n; ++len) for (int i = 1; i + len ^ n &lt;&lt; 1; ++i) &#123; int j = i + len; for (int k = s[i][j - 1]; k &lt;= s[i + 1][j]; ++k) if (dp[i][j] &gt; dp[i][k] + dp[k + 1][j] + pre[j] - pre[i - 1]) &#123; s[i][j] = k; dp[i][j] = dp[i][k] + dp[k + 1][j] + pre[j] - pre[i - 1]; &#125; &#125; int res = 0x3f3f3f3f; for (int i = 1; i &lt;= n; ++i) res = min(res, dp[i][i + n - 1]); cout &lt;&lt; res &lt;&lt; endl; &#125;&#125; HDU4632题目大意给定一个字符串，求出所有的回文子序列个数模$~10007~$的答案，时间复杂度要求在$~O(n^2)~$以内。 题解动态规划，记$~dp[i][j]~$为区间$~[i,~j]~$内的回文子序列个数。则根据容斥原理，有状态转移式 dp[i][j]=\\begin{cases} dp[i][j-1]+dp[i+1][j]-dp[i+1][j] &str[i]\\not=str[j] \\\\ dp[i][j-1]+dp[i+1][j]+1 &str[i]=str[j] \\end{cases}代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 10007;const int maxn = 1 &lt;&lt; 10;int dp[maxn][maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;int main() &#123; for (int i = 0; i ^ maxn; ++i) dp[i][i] = 1; int t; cin &gt;&gt; t; for (int cas = 1; cas &lt;= t; ++cas) &#123; string str; cin &gt;&gt; str; int size = (int)str.size(); for (int i = 1; i ^ size; ++i) &#123; if (str[i - 1] ^ str[i]) dp[i - 1][i] = 2; else dp[i - 1][i] = 3; &#125; for (int len = 2; len &lt; size; ++len) for (int i = 0; i + len ^ size; ++i) &#123; int j = i + len; dp[i][j] = add(dp[i + 1][j], dp[i][j - 1]); if (str[i] ^ str[j]) dp[i][j] = sub(dp[i][j], dp[i + 1][j - 1]); else dp[i][j] = add(dp[i][j], 1); &#125; cout &lt;&lt; \"Case \" &lt;&lt; cas &lt;&lt; \": \" &lt;&lt; dp[0][size - 1] &lt;&lt; endl; &#125;&#125; HDU4745题目大意给一个大小为$~N~$的环形数组，要求分别顺时针逆时针一圈以内各选一个子序列，使得子序列一样，求最大的子序列长度。 题解其实差不多就是求最大的回文子序列长度，注意细节，具体看代码。 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 11;int dp[maxn][maxn], a[maxn];int main() &#123; for (int i = 0; i ^ maxn; ++i) dp[i][i] = 1; int n; while (true) &#123; cin &gt;&gt; n; if (!n) break; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i], a[n + i] = a[i]; for (int len = 1; len ^ n; ++len) for (int i = 1; i + len &lt;= n &lt;&lt; 1; ++i) &#123; int j = i + len; if (a[i] == a[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); &#125; int res = 0; for (int i = 1; i &lt;= n; ++i) res = max(res, max(dp[i][i + n - 1], dp[i][i + n - 2] + 1)); cout &lt;&lt; res &lt;&lt; endl; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"区间DP","slug":"区间DP","permalink":"http://yoursite.com/tags/区间DP/"}]},{"title":"斜率优化DP","slug":"斜率优化DP","date":"2019-01-17T13:54:41.798Z","updated":"2019-02-14T09:00:07.811Z","comments":true,"path":"2019/01/17/斜率优化DP/","link":"","permalink":"http://yoursite.com/2019/01/17/斜率优化DP/","excerpt":"","text":"斜率优化DP思想对于状态转移公式满足如下条件的动态规划 dp[i]=\\min_{j","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"斜率DP","slug":"斜率DP","permalink":"http://yoursite.com/tags/斜率DP/"}]},{"title":"队列优化DP","slug":"队列优化DP","date":"2019-01-17T13:54:38.281Z","updated":"2019-02-14T08:59:17.037Z","comments":true,"path":"2019/01/17/队列优化DP/","link":"","permalink":"http://yoursite.com/2019/01/17/队列优化DP/","excerpt":"","text":"队列优化DP思想对于状态转移公式满足如下条件的动态规划 dp[i]=(\\min\\text{or}\\max)\\{f[j]\\}+g[i],~j\\in[\\alpha[i],\\beta[i]]其中$~f~$和$~g~$均可线性时间内求出，且$\\alpha~$和$~\\beta~$单调递增。朴素的做法是直接暴力循环计算状态转移，时间复杂度为$~O(n^2)~$。但是注意到区间$~[\\alpha,~\\beta]~$的单调递增性质，可以用一个叫做单调队列的数据结构来维护区间的最值。 单调队列的性质 可以用双端队列或者双指针数组实现，内部的任意元素$~que[i]~$表示$~f~$的角标。 角标有序储存，即$~que[i]&lt;que[j],~\\forall~i&lt;j~$。 角标对应的数组值单调，即$~f[que[i]]~$单调递增或者单调递减。 单调队列的操作（单调递减队列维护区间最大值） 每次更新区间时，从小到大考虑新加入的角标$~now~$，将所有队列$~que~$中满足$~que[cmp]&lt;que[now]~$的元素$~cmp~$从队列$~que~$中移除。由于单调队列的性质，只需要让$~now~$与队列$~que~$的尾部元素$~last~$比较即可。 将$~now~$放入队列$~que~$尾部，经过上一个操作，单调队列性质依然保持。 将队列$~que~$头部所有不在区间$~[\\alpha,~\\beta]~$的元素$~head~$从队列$~que~$中移除。由于区间$~[\\alpha,~\\beta]~$的单调递增性质，单调队列性质依然保持，且此时$~\\max{f[i]}=f[que[head]]~$。 复杂度计算每个角标$~i~$至多被放入队列$~que~$或者从队列$~que~$中移除一次，所以是线性复杂度$~O(n)~$。 题目HDU3401题目大意炒股，一共$~T~$天，第$~i~$天股票的买价是$~ap[i]~$、最多可以买$~as[i]~$股，卖价是$~bp[i]~$、最多可以卖$~bs[i]~$股，且每两次交易之间相隔必须大于$~W~$天，最大屯股量为$~maxp~$，问最后的最大收益。 题解动态规划，记$~dp[i][j]~$表示在第$~i~$天还剩下$~j~$股的最大收益，则有$~3~$种状态更新 dp[i][j]=\\max\\begin{cases} dp[i-1][j] &\\text{null} \\\\ dp[i-w-1][j-k]-ap[i]*k &\\text{$k\\leq\\min(j,~as[i])$} \\\\ dp[i-w-1][j+k]+bp[i]*k &\\text{$k\\leq\\min(maxp-j~,bs[i])$} \\\\ \\end{cases}这样的时间复杂度为$~O(T\\cdot maxp^2)~$，显然会$~\\text{TLE}~$。但观察$~dp[i][j]~$的第二种状态更新，有 \\begin{aligned} dp[i][j] &=\\max\\alpha[l]-ap[i]*j \\\\ \\alpha[l] &=dp[i-w-1][l]+ap[i]*[l] \\\\ l &\\in[\\max(0,~j-as[i]),~j] \\\\ \\end{aligned}第三种状态更新同理 \\begin{aligned} dp[i][j] &=\\max\\beta[l]-bp[i]*j \\\\ \\beta[l] &=dp[i-w-1][l]+bp[i]*[l] \\\\ l &\\in[j,~\\min(maxp,~j+bs[i])] \\\\ \\end{aligned}于是可以用单调队列来维护$~\\max(\\alpha,\\beta)~$。这样对于每个$~dp[i][j]~$状态转移的平均复杂度为$~O(1)~$，总时间复杂度为$~O(T\\cdot maxp)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1 &lt;&lt; 11;int ap[maxn], bp[maxn], as[maxn], bs[maxn], temp[maxn], dp[maxn &lt;&lt; 1][maxn];int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int n, maxp, w; cin &gt;&gt; n &gt;&gt; maxp &gt;&gt; w; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; ap[i] &gt;&gt; bp[i] &gt;&gt; as[i] &gt;&gt; bs[i]; for (int i = 0; i &lt;= w; ++i) &#123; dp[i][0] = 0; for (int j = 1; j &lt;= maxp; ++j) dp[i][j] = -inf; &#125; deque&lt;int&gt; que; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= maxp; ++j) dp[i + w][j] = dp[i + w - 1][j]; que.clear(); for (int j = 0; j &lt;= maxp; ++j) &#123; temp[j] = dp[i - 1][j] + ap[i] * j; while (!que.empty() &amp;&amp; temp[que.back()] &lt; temp[j]) que.pop_back(); que.push_back(j); while (que.front() &lt; j - as[i]) que.pop_front(); dp[i + w][j] = max(dp[i + w][j], temp[que.front()] - ap[i] * j); &#125; que.clear(); for (int j = 0; j &lt;= maxp; ++j) temp[j] = dp[i - 1][j] + bp[i] * j; for (int j = 0; j ^ bs[i]; ++j) &#123; while (!que.empty() &amp;&amp; temp[que.back()] &lt; temp[j]) que.pop_back(); que.push_back(j); &#125; for (int j = 0; j &lt;= maxp; ++j) &#123; if (j + bs[i] &lt;= maxp) &#123; while (!que.empty() &amp;&amp; temp[que.back()] &lt; temp[j + bs[i]]) que.pop_back(); que.push_back(j + bs[i]); &#125; while (que.front() &lt; j) que.pop_front(); dp[i + w][j] = max(dp[i + w][j], temp[que.front()] - bp[i] * j); &#125; &#125; cout &lt;&lt; dp[n + w][0] &lt;&lt; endl; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"队列DP","slug":"队列DP","permalink":"http://yoursite.com/tags/队列DP/"}]},{"title":"Good Bye 2018 (TBC)","slug":"Good Bye 2018 (TBC)","date":"2019-01-17T12:54:33.346Z","updated":"2019-01-17T14:08:29.227Z","comments":true,"path":"2019/01/17/Good Bye 2018 (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Good Bye 2018 (TBC)/","excerpt":"","text":"Good Bye 2018 A. New Year and the Christmas Ornament题目大意给$~3~$个数$~y,~b,~r~$，求最大的$~sum=a+(a+1)+(a+2)~$，满足$~a\\leq y,~a+1\\leq b,~a+2\\leq r$。 题解水题。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; 3 * min(a + 1, min(b, c - 1)) &lt;&lt; endl;&#125; B. New Year and the Treasure Geolocation题目大意给定$~n~$个坐标和$~n~$个向量，存在一种坐标和向量一一配对的方式，使得$~n~$个坐标为起点经向量所指向的终点一样，输出这个终点。 题解平均坐标即是答案，注意数据范围会爆$~\\text{int}~$。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; long long x = 0, y = 0, a, b; for (int i = 0; i ^ n &lt;&lt; 1; ++i) &#123; cin &gt;&gt; a &gt;&gt; b; x += a; y += b; &#125; cout &lt;&lt; x / n &lt;&lt; ' ' &lt;&lt; y / n &lt;&lt; endl;&#125; C. New Year and the Sphere Transmission题目大意数字$~1,~2,~\\dots,~n~$逆时针排成一圈，起点在$~1~$。逆时针每$~k~$个数取一个，直到恰好回到$~1~$处，所有取的数得到一个总和$~sum(k)~$。将所有可能的$~sum(k)~$从小到达输出。 题解不难发现每$~k~$个数去一个与每$~\\gcd(k,~n)~$个数去一个所得到的总和一样。那么只考虑$~k\\mid n~$的情况。此时 sum(k)=\\sum_{i=0}^{\\frac{n}{k}-1}ik+1=\\frac{1}{2}\\left(\\frac{n(n+2)}{k}-n\\right)枚举$~n~$的因子$~k~$即可，时间复杂度为$~O(\\sqrt{n})~$。对于有序输出答案以及去重，由于数据范围不大，可以用$~\\text{set}~$维护，时间复杂度为$~O(\\sqrt{n}\\log n)~$。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; long long n; cin &gt;&gt; n; set&lt;long long&gt; res; int sqr = sqrt(n + 1); for (int i = 1; i &lt;= sqr; ++i) if (!(n % i)) &#123; res.insert((n + 2) * i - n &gt;&gt; 1); res.insert((n + 2) * n / i - n &gt;&gt; 1); &#125; cout &lt;&lt; 1; res.erase(res.find(1)); for (auto out : res) cout &lt;&lt; ' ' &lt;&lt; out; cout &lt;&lt; endl;&#125; D. New Year and the Permutation Concatenation题目大意序列$~p~$由$~1,~2,~\\dots,~n~$的所有全排列按字典序连在一起，长度为$~n\\cdot n!~$。输出$~p~$中有多少长度为$~n~$的连续子序列满足总和为$~\\frac{n(n+1)}{2}~$。 题解首先每一个原生的全排列一定满足总和为$~\\frac{n(n+1)}{2}~$。接下来不难发现所有符合条件的长度为$~n~$的连续子序列也必定是一个全排，于是答案变成了$~p~$中有多少个全排列。对于非原生的全排列，它必定由一个原生全排列的后缀接上下一个原生全排列的前缀。再注意到原生全排列按字典序排列，于是一对原生全排列要通过前面的后缀加后面的前缀生成新的全排列，必须满足两者的前缀一样。于是对于公共前缀长度不小于$~k~$的相邻原生全排列对，均可通过取前者长度为$~n-k~$的后缀和后者长度为$~k~$的前缀，构造出新的全排列，共计$~\\frac{n!}{(n-k)!}((n-k)!-1)~$个。枚举$~1\\leq k\\leq n-2~$，答案为 n!+\\sum_{k=1}^{n-2}\\frac{n!}{(n-k)!}((n-k)!-1)=n!(n-\\sum_{i=1}^{n-1}\\frac{1}{k!})代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 1 &lt;&lt; 20;int inv[maxn], fact[maxn], finv[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline void init() &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125;&#125;int main() &#123; init(); int n; cin &gt;&gt; n; int res = 0; for (int i = 1; i ^ n; ++i) res = add(res, finv[i]); cout &lt;&lt; mul(fact[n], sub(n, res)) &lt;&lt; endl;&#125; E. New Year and the Acquaintance Estimation题目大意给定$~n~$个点的度数，问是否可以加一个新的度数，使得这$~n+1~$个点能构成一个简单无向图。将所有可能的度数升序输出。 题解题目里已经给出了相关理论的$~\\text{wiki}~$链接。根据$~\\text{Erdo2s-Gallai}~$定理，以$~d_1\\geq d_2\\geq\\dots\\geq d_n~$为度数可以构成简单图的充要条件是$~2\\mid\\sum_{i=1}^{n}d_i~$，且 \\sum_{i=1}^{k}d_i\\leq k(k-1)+\\sum_{i=k+1}^{n}\\min(d_i,~k),~\\forall~1\\leq k\\leq n将$~d~$改为升序，用$~n-k~$代替$~k~$，则不等式变为 \\sum_{i=k+1}^{n}d_i\\leq (n-k)(n-k-1)+\\sum_{i=1}^{k}\\min(d_i,~n-k),~\\forall~0\\leq k< n不难发现答案必为连续的一段且奇偶性相同。先不考虑奇偶性，如果新加的度数$~deg~$不合法，则考虑上式不成立时$~deg~$在上式的左边还是右边。如果在左边，说明$~deg~$过大，反之如果在右边，则$~deg~$过小。左右都出现的话则说明无解。二分$~deg~$即可。时间复杂度$~O(n\\log n)~$或$~O(n\\log^2n)~$均可接受。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 19;long long vec[maxn], deg[maxn], pre[maxn];int size;inline int cal(const long long&amp; rem) &#123; memcpy(deg, vec, size * sizeof (long long)); deg[size - 1] = rem; for (int i = size - 1; i &amp;&amp; deg[i - 1] &gt; deg[i]; --i) swap(deg[i - 1], deg[i]); int pos1 = lower_bound(deg, deg + size, rem) - deg; int pos2 = upper_bound(deg, deg + size, rem) - deg; for (int i = 0; i ^ size; ++i) pre[i + 1] = pre[i] + deg[i]; int pos = 0; bool flag1 = false, flag2 = false; for (int k = size - 1; ~k; --k) &#123; while (pos ^ size &amp;&amp; deg[pos] &lt; size - k) ++pos; if (pre[size] - pre[k] &gt; (size - k) * (size - min(k, pos) - 1LL) + pre[min(k, pos)]) &#123; flag1 |= k &gt; pos1; flag2 |= k &lt; pos2; &#125; &#125; if (flag1 &amp;&amp; flag2) exit((cout &lt;&lt; -1 &lt;&lt; endl, 0) ); return flag1 ? -1 : flag2;&#125;int main() &#123; int n; cin &gt;&gt; n; size = n + 1; int parity = 0; for (int i = 0; i ^ n; ++i) cin &gt;&gt; vec[i], parity ^= vec[i] &amp; 1; sort(vec, vec + n); int left, right; if (!cal(0)) &#123; left = 0; &#125; else &#123; int l = 0, r = n; while (r - l ^ 1) &#123; int mid = l + r &gt;&gt; 1; if (~cal(mid)) r = mid; else l = mid; &#125; left = r; &#125; if (!cal(n)) &#123; right = n; &#125; else &#123; int l = left, r = n; while (r - l ^ 1) &#123; int mid = l + r &gt;&gt; 1; if (cal(mid) ^ 1) l = mid; else r = mid; &#125; right = l; &#125; cout &lt;&lt; (left &amp; 1 ^ parity ? left + 1 : left); for (int i = left + 2; i &lt;= right; ++i) if (!(i &amp; 1 ^ parity)) cout &lt;&lt; ' ' &lt;&lt; i; cout &lt;&lt; endl; return 0;&#125; F. New Year and the Mallard Expedition题目大意有$~3~$种地形和行动方式，分别是草地、水、火山和走、游泳、飞，行动的耗时分别为$~1~$米$~5~$秒、$~1~$米$~3~$秒、$~1~$米$~1~$秒。可以反向行动且随时可以无花费地切换行动方式。走和游泳分别只能在草地和水上使用，飞行可以在任何地形使用，但是飞行需要能量。能量一开始为$~0~$，每走或者游$~x~$米均可获得$~x~$能量，每飞$~x~$米则会消耗$~x~$能量。全路程共计$~n~$段，给出的地形和长度，问最短耗时。 题解现根据各种地形对应的行动方式模拟一遍，算出答案的上界并记录到每一段时能量还剩余多少（有可能需要为了补充能量需而原地打转）。然后从终点向起点模拟，在保证每处剩余能量非负的情况下，先尽量在草地上飞，如果还有能量剩余则在水上飞。需要注意细节。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;long long&gt; len(n + 1, 0), rem(n + 1, 0); for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; len[i]; string str; cin &gt;&gt; str; str = 'A' + str; long long res = 0; bool flag = false; for (int i = 1; i &lt;= n; ++i) &#123; if (str[i] ^ 'L') &#123; rem[i] = rem[i - 1] + len[i]; flag |= str[i] == 'W'; res += len[i] * (str[i] == 'W' ? 3 : 5); &#125; else &#123; if (rem[i - 1] &lt; len[i]) &#123; rem[i] = 0; res += (len[i] - rem[i - 1]) * (flag ? 4 : 6) + rem[i - 1]; &#125; else &#123; rem[i] = rem[i - 1] - len[i]; res += len[i]; &#125; &#125; &#125; long long cnt = 0, minn = 0x3f3f3f3f3f3f3f3f; for (int i = n; i; --i) &#123; minn = min(minn, rem[i]); if (str[i] == 'G') &#123; auto sub = min(minn, len[i] &lt;&lt; 1); res -= sub &lt;&lt; 1; minn -= sub; cnt += sub; &#125; &#125; cout &lt;&lt; res + cnt - rem[n] &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"线性基","slug":"线性基","date":"2019-01-17T07:46:42.873Z","updated":"2019-05-10T05:02:15.369Z","comments":true,"path":"2019/01/17/线性基/","link":"","permalink":"http://yoursite.com/2019/01/17/线性基/","excerpt":"","text":"线性基问题对于非负整数区间$~[0,2^n)~$，可以按二进制$~01~$表示映射到域$~\\Bbb{Z}_2~$上的$~n~$维向量空间$~\\Bbb{Z}_2^n~$。记上述的映射为$~f:[0,~2^n)\\to\\Bbb{Z}_2^n,~x\\mapsto v~$，这里$~v~$是$~x~$在二进制下的$~01~$表示，显然$~f~$是双射。之后的内容中，对于向量$~v\\in\\Bbb{Z}_2^n~$，都用$~f^{-1}(v)\\in[0,2^n)~$来表示。那么对于若干整数的$~\\text{xor}~$运算问题，则转化为向量空间$~\\Bbb{Z}_2^n~$上的加法运算问题，通常称为线性基问题。 线性基向量空间$~\\Bbb{Z}_2^n~$上任意$~n~$个线性无关的向量，称作该向量空间上的一组线性基。显然$~1,2,4,\\dots,2^{n-1}~$是$~\\Bbb{Z}_2^n~$的一组线性基，称作标准线性基。且向量空间$~\\Bbb{Z}_2^n~$的任意一个子空间$~V~$必同构于向量空间$~\\Bbb{Z}_2^m,~0\\leq m\\leq n~$，于是$~{\\mid V\\mid}=2^m~$。 最小生成子空间对于向量空间$~\\Bbb{Z}_2^n~$的一个子集$~A=\\lbrace~a_1,a_2,\\dots,a_m~\\rbrace~$，子空间$~V~$称作$~A~$在$~\\Bbb{Z}_2^n~$上的最小生成子空间，当且仅当$~A\\subseteq V\\subseteq~\\Bbb{Z}_2^n~$，且对于$~\\Bbb{Z}_2^n~$的所有子空间$~W~$满足：如果$~A\\subseteq W~$，则必有$~V\\subseteq W~$。如果$~a_1,~a_2,~\\dots,~a_m~$线性无关，则它们构成$~V~$的一组线性基。于是有推论：对于$~A~$的最小生成子空间$~V~$，满足$~\\dim V\\leq{\\mid A\\mid}~$。 空间的扩张对于向量空间$~\\Bbb{Z}_2^n~$的子空间$~V~$和向量$~a~$，定义$~V(a)=\\lbrace~a+b:~b\\in V\\rbrace\\cup V~$。显然$~V(a)~$是包含$~V~$和$~a~$的最小空间，称$~V(a)~$是$~V~$的扩张。如果$~a\\in V~$，则显然$~V(a)=V~$，称作平凡扩张；否则称作不平凡扩张，且$~\\dim V(a)=\\dim V+1~$。对于不平凡扩张，设$~b_1,~b_2,~\\dots,~b_{\\dim V}~$是$~V~$的一组线性基，因为$~a\\notin V~$，$~a~$无法被$~b_1,~b_2,~\\dots,~b_{\\dim V}~$线性表出，所以$~b_1,~b_2,~\\dots,~b_{\\dim V},~a~$线性无关，它们是$~V(a)~$的一组线性基。 代码实现存储对于任意线性无关组，显然它的最小生成子空间是唯一的。所以可以用$~\\text{vector}~$来储存这个线性无关组来表示一个线性空间。 123456struct Vec &#123; vector&lt;uint64_t&gt; base; Vec() &#123;&#125; void clear() &#123; base.clear(); &#125; size_t size() const &#123; return base.size(); &#125;&#125;; 扩张自行理解。 1234567891011bool add(uint64_t e) &#123; for (const auto&amp; v : base) e = std::min(e, e ^ v); if (e) base.emplace_back(e); return e;&#125;void join(const Vec&amp; vec) &#123; for (const auto&amp; v : vec.base) add(v); &#125;Vec operator + (const Vec&amp; vec) const &#123; Vec ret = *this; ret.join(vec); return ret;&#125; 最值最小值为非$~0~$最小值，其余自行理解。 123456uint64_t min() &#123; return *min_element(base.begin(), base.end()); &#125;uint64_t max() &#123; uint64_t ret = 0; for (const auto&amp; v : base) ret = std::max(ret, ret ^ v); return ret;&#125; 标准化自行理解。 12345void sort() &#123; std::sort(base.begin(), base.end()); for (size_t i = 1; i != base.size(); ++i) for (size_t j = i - 1; ~j; --j) base[i] = std::min(base[i], base[i] ^ base[j]);&#125; 有序查找从$~0~$开始，需要标准化，其余自行理解。 123456uint64_t find_by_rank(const uint64_t&amp; k) &#123; uint64_t ret = 0; for (size_t i = 0; i != base.size(); ++i) if (k &amp; uint64_t(1) &lt;&lt; uint64_t(i)) ret ^= base[i]; return ret;&#125; 模板12345678910111213141516171819202122232425262728293031323334struct Vec &#123; vector&lt;uint64_t&gt; base; Vec() &#123;&#125; void clear() &#123; base.clear(); &#125; size_t size() const &#123; return base.size(); &#125; bool add(uint64_t e) &#123; for (const auto&amp; v : base) e = std::min(e, e ^ v); if (e) base.emplace_back(e); return e; &#125; void join(const Vec&amp; vec) &#123; for (const auto&amp; v : vec.base) add(v); &#125; Vec operator + (const Vec&amp; vec) const &#123; Vec ret = *this; ret.join(vec); return ret; &#125; uint64_t min() &#123; return *min_element(base.begin(), base.end()); &#125; uint64_t max() &#123; uint64_t ret = 0; for (const auto&amp; v : base) ret = std::max(ret, ret ^ v); return ret; &#125; void sort() &#123; std::sort(base.begin(), base.end()); for (size_t i = 1; i != base.size(); ++i) for (size_t j = i - 1; ~j; --j) base[i] = std::min(base[i], base[i] ^ base[j]); &#125; uint64_t find_by_rank(const uint64_t&amp; k) &#123; uint64_t ret = 0; for (size_t i = 0; i != base.size(); ++i) if (k &amp; uint64_t(1) &lt;&lt; uint64_t(i)) ret ^= base[i]; return ret; &#125;&#125;; 题目CF1101G代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const size_t maxn = 1 &lt;&lt; 19;uint64_t c[maxn];pair&lt;size_t, size_t&gt; seg[maxn];struct Vec &#123; vector&lt;uint64_t&gt; base; Vec() &#123;&#125; void clear() &#123; base.clear(); &#125; bool add(uint64_t e) &#123; for (const auto&amp; v : base) e = std::min(e, e ^ v); if (e) base.emplace_back(e); return e; &#125; void join(const Vec&amp; vec) &#123; for (const auto&amp; v : vec.base) add(v); &#125; Vec operator + (const Vec&amp; vec) const &#123; Vec ret = *this; ret.join(vec); return ret; &#125; uint64_t max() &#123; uint64_t ret = 0; for (const auto&amp; v : base) ret = std::max(ret, ret ^ v); return ret; &#125;&#125; res[maxn], vec[maxn], tmp;void cdq(auto&amp; que, const size_t&amp; l, const size_t&amp; r) &#123; if (l == r) &#123; for (const auto&amp; i : que) res[i].add(c[l]); return; &#125; size_t m = (l + r) &gt;&gt; 1; tmp.clear(); for (size_t i = m; i &gt;= l; --i) &#123; tmp.add(c[i]); vec[i] = tmp; &#125; tmp.clear(); for (size_t i = m + 1; i &lt;= r; ++i) &#123; tmp.add(c[i]); vec[i] = tmp; &#125; vector&lt;size_t&gt; left, right; for (const auto&amp; i : que) &#123; if (seg[i].second &lt;= m) left.emplace_back(i); else if (seg[i].first &gt; m) right.emplace_back(i); else res[i] = vec[seg[i].first] + vec[seg[i].second]; &#125; que.clear(); cdq(left, l, m); cdq(right, m + 1, r);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); size_t n; cin &gt;&gt; n; for (size_t i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; size_t q; cin &gt;&gt; q; vector&lt;size_t&gt; que(q); iota(que.begin(), que.end(), 0); for (size_t i = 0; i != q; ++i) cin &gt;&gt; seg[i].first &gt;&gt; seg[i].second; cdq(que, 1, n); for (size_t i = 0; i != q; ++i) cout &lt;&lt; res[i].max() &lt;&lt; '\\n';&#125; CF1100F代码;12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), base; cin &gt;&gt; a.front(); for (int i = 1; i ^ n; ++i) cin &gt;&gt; a[i], a[i] ^= a[i - 1]; if (!a.back()) return cout &lt;&lt; -1 &lt;&lt; endl, 0; for (auto e : a) &#123; for (auto v : base) e = min(e, e ^ v); if (e) base.push_back(e); &#125; cout &lt;&lt; base.size() &lt;&lt; endl;&#125; HDU3949代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;struct Vec &#123; vector&lt;uint64_t&gt; base; Vec() &#123;&#125; size_t size() const &#123; return base.size(); &#125; bool add(uint64_t e) &#123; for (const auto&amp; v : base) e = std::min(e, e ^ v); if (e) base.emplace_back(e); return e; &#125; void sort() &#123; std::sort(base.begin(), base.end()); for (size_t i = 1; i != base.size(); ++i) for (size_t j = i - 1; ~j; --j) base[i] = std::min(base[i], base[i] ^ base[j]); &#125; uint64_t find_by_rank(const uint64_t&amp; k) &#123; uint64_t ret = 0; for (size_t i = 0; i != base.size(); ++i) if (k &amp; uint64_t(1) &lt;&lt; uint64_t(i)) ret ^= base[i]; return ret; &#125;&#125;;int main() &#123; size_t t; cin &gt;&gt; t; for (size_t cas = 1; cas &lt;= t; ++cas) &#123; size_t n; cin &gt;&gt; n; Vec vec; for (size_t i = 0; i != n; ++i) &#123; uint64_t a; cin &gt;&gt; a; vec.add(a); &#125; size_t q; cin &gt;&gt; q; vec.sort(); uint64_t flag = (n == vec.size()) - 1; cout &lt;&lt; \"Case #\" &lt;&lt; cas &lt;&lt; \":\\n\"; while (q--) &#123; uint64_t k; cin &gt;&gt; k; if ((k + flag) &amp; ~((uint64_t(1) &lt;&lt; uint64_t(vec.size())) - uint64_t(1))) cout &lt;&lt; \"-1\\n\"; else cout &lt;&lt; vec.find_by_rank(k + flag) &lt;&lt; '\\n'; &#125; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"线性基","slug":"线性基","permalink":"http://yoursite.com/tags/线性基/"}]}]}
{"meta":{"title":"MAOoo","subtitle":null,"description":null,"author":"MAOoo","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-01-17T12:48:12.233Z","updated":"2019-01-17T12:48:12.233Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-01-17T12:42:26.595Z","updated":"2019-01-17T12:42:26.595Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2019BNUCPC","slug":"2019BNUCPC","date":"2019-05-17T10:17:33.334Z","updated":"2019-05-18T02:19:11.260Z","comments":true,"path":"2019/05/17/2019BNUCPC/","link":"","permalink":"http://yoursite.com/2019/05/17/2019BNUCPC/","excerpt":"","text":"2019BNUCPC A. 足球题目大意水题。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; size_t T; cin &gt;&gt; T; while (T--) &#123; vector&lt;int&gt; a(23); for (auto&amp; aa : a) cin &gt;&gt; aa; cout &lt;&lt; accumulate(a.begin(), a.end(), 0) * *min_element(a.begin(), a.end()) &lt;&lt; endl; &#125;&#125; B. 进制题目大意水题。 题解水题。 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;int64_t&gt; sum(18); for (int i = 2; i &lt;= 10; ++i) &#123; int64_t base = 1; for (auto&amp; s : sum) &#123; s += base; base *= i; &#125; &#125; size_t T; cin &gt;&gt; T; while (T--) &#123; string str; cin &gt;&gt; str; reverse(str.begin(), str.end()); int64_t res = 0; for (size_t i = 0; i != str.size(); ++i) if (str[i] == '1') res += sum[i]; cout &lt;&lt; res &lt;&lt; '\\n'; &#125;&#125; C. 寻找路径题目大意改编自$~\\text{2019 Google Code Jam Qualification T2}~$。要从$~n\\times m~$的网格图的左下角走到右上角，只能向上或者向右。现给定一个由$~n~$个向上和$~m~$个向右组成的路径，问是否存在另一条路径与给定路径没有重复的边，存在则输出任意一种。 题解如果第一步和最后一步不一样，则显然可以输出贴着右下方或者左上方的路径。如果一样，不妨设第一步和最后一步都是向上，那么如果新的路径存在，则它的第一步和最后一步必须向右。如果在给定路径上存在两个连续的向右，那么用$~n~$个向上从这两个向右的中点穿过，前面和后面均为向右即可。如果不存在，很容易发现答案也是不存在的。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; size_t T; cin &gt;&gt; T; while (T--) &#123; size_t n, m; string str, res; cin &gt;&gt; n &gt;&gt; m &gt;&gt; str; if (str.front() == 'U' &amp;&amp; str.back() == 'U') &#123; for (size_t i = 2; i != n + m; ++i) if (str[i] == 'R' &amp;&amp; str[i - 1] == 'R') &#123; res = string(count(str.begin(), str.begin() + i, 'R'), 'R') + string(n, 'U'); res.append(n + m - res.size(), 'R'); break; &#125; if (res.empty()) res = \"impossible\"; &#125; if (str.front() == 'U' &amp;&amp; str.back() == 'R') &#123; res = string(m, 'R') + string(n, 'U'); &#125; if (str.front() == 'R' &amp;&amp; str.back() == 'U') &#123; res = string(n, 'U') + string(m, 'R'); &#125; if (str.front() == 'R' &amp;&amp; str.back() == 'R') &#123; for (size_t i = 2; i != n + m; ++i) if (str[i] == 'U' &amp;&amp; str[i - 1] == 'U') &#123; res = string(count(str.begin(), str.begin() + i, 'U'), 'U') + string(m, 'R'); res.append(n + m - res.size(), 'U'); break; &#125; if (res.empty()) res = \"impossible\"; &#125; cout &lt;&lt; res &lt;&lt; endl; &#125;&#125; D. 选数字题目大意给定序列$~a_1,a_2,\\dots,a_n~$，问等概率选$~k~$个数字中最小值的期望乘以$~\\binom{n}{k}~$的值。 题解题目等价于询问对于所有的$~k~$个数字的选法中最小值的总和。考虑第$~i~$小的数字的贡献次数，相当于先选这个数再在第$~i+1~$小至第$~n~$小（最大）的数字中选剩下的$~k-1~$个数字，这个值是$~\\binom{n-i}{k-1}~$。最后全部加起来即可。 代码123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const size_t maxn = 1 &lt;&lt; 10; const uint64_t mod = 1000000007; auto mul = [&amp;mod] (const uint64_t&amp; a, const uint64_t&amp; b) &#123; return a * b % mod; &#125;; vector&lt;uint64_t&gt; inv(maxn), fact(maxn), finv(maxn); inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (size_t i = 2; i != maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125; size_t T; cin &gt;&gt; T; while (T--) &#123; size_t n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;uint64_t&gt; a(n); for (auto&amp; aa : a) cin &gt;&gt; aa; sort(a.begin(), a.end()); uint64_t res = 0; for (size_t i = 0; i + k &lt;= n; ++i) res += mul(mul(a[i], fact[n - i - 1]), mul(finv[k - 1], finv[n - k - i])); cout &lt;&lt; res % mod &lt;&lt; endl; &#125;&#125; E. 高等术学题目大意场上初始有$~1~$号怪兽，每个怪兽死亡都会召唤若干新的怪兽到场上，共$~n~$只，血量为$~h_1,h_2,\\dots,h_n~$。攻击为$~\\text{AOE}~$模式，即每次攻击场上所有怪兽受到相同伤害。攻击力为$~d_1,d_2,\\dots,d_m~$的循环。每次攻击需要花费$~1~$的代价，但是如果本次攻击消灭的至少$~1~$只怪兽，则下次攻击免费。问消灭所有怪兽的总代价。数据范围$~1\\leq n\\leq10^5,~1\\leq m\\leq10^5,~1\\leq h\\leq10^9,~1\\leq d\\leq10^9~$。 题解显然要用堆来维护当前场上血量最少的怪。然后计算需要多少次攻击时现考虑需要多少个$~m~$次的攻击，然后在$~d~$的前缀和上二分。一个技巧是在把新的怪兽入堆时，把它的血量加上之前攻击力的总和。总时间复杂度为$~O(n(\\log n+\\log m))~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); size_t n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;uint64_t&gt; h(n), d(m); vector&lt;vector&lt;size_t&gt;&gt; next(n); for (auto&amp; hh : h) cin &gt;&gt; hh; for (auto&amp; dd : d) cin &gt;&gt; dd; auto p = d; for (size_t i = 1; i != m; ++i) p[i] += p[i - 1]; for (auto&amp; vec : next) &#123; size_t k; cin &gt;&gt; k; vec.resize(k); for (auto&amp; nn : vec) cin &gt;&gt; nn, --nn; &#125; priority_queue&lt;pair&lt;uint64_t, size_t&gt;, vector&lt;pair&lt;uint64_t, size_t&gt;&gt;, greater&lt;pair&lt;uint64_t, size_t&gt;&gt;&gt; que; que.emplace(h.front(), size_t(0)); uint64_t cur = 0, res = 0; while (!que.empty()) &#123; uint64_t rem = que.top().first - cur / m * p.back(); auto ite = lower_bound(p.begin(), p.end(), rem); uint64_t cnt = ite - p.begin() - cur % m; if (ite == p.end()) &#123; rem -= p.back(); cnt += rem / p.back() * m; if (rem %= p.back()) cnt += lower_bound(p.begin(), p.end(), rem) - p.begin(); else --cnt; &#125; res += cnt; cur += cnt; ++cur; uint64_t tot = cur / m * p.back() + p[cur % m] - d[cur % m]; while (!que.empty() &amp;&amp; que.top().first &lt;= tot) &#123; for (const auto&amp; nn : next[que.top().second]) que.emplace(h[nn] + tot, nn); que.pop(); &#125; &#125; cout &lt;&lt; ++res &lt;&lt; endl;&#125; F. 仙人掌题目大意问大小为$~n~$且满足$~\\text{DFS}~$序为$~1,2,\\dots,n~$的有标号仙人掌个数。仙人掌为任何一条边至多属于一个简单环的连通图。数据范围$~1\\leq T\\leq5000,~1\\leq n\\leq5000~$。 题解动态规划。用$~{\\scr F}_i~$表示大小为$~i~$且满足$~\\text{DFS}~$序单调的有标号仙人掌构成的集合。记$~dp_i^{(0)}={\\mid {\\scr F}_i\\mid}~$，则$~dp^{(0)}~$为答案序列。对于仙人掌$~F~$，用$~S(F)\\subseteq F~$表示$~F~$中包含根节点的不连通子树。记$~dp_i^{(1)}=\\sum_{F\\in{\\scr F}_i}{\\mid S(F)\\mid}~$。显然$~dp_1^{(0)}=dp_1^{(0)}=1~$。对于$~i&gt;1~$，枚举根$~1~$的标号最大的儿子，设为$~j+1~$。则整个仙人掌等价于标号为$~1,2,\\dots,j~$的仙人掌$~A~$的根节点$~1~$上挂一棵标号为$~j+1,j+2,\\dots,i~$的仙人掌$~B~$，或者再加一条覆盖边$~(1,j+1)~$的非$~\\text{DFS}~$树边$~l~$。注意到$~l~$的一端为$~1~$，另一端根据仙人掌的性质，必然在$~S(B)~$之中。所以有状态转移式 \\begin{aligned} dp_i^{(0)}&=\\sum_{j=1}^{i-1}dp_j^{(0)}\\times(dp_{i-j}^{(0)}+dp_{i-j}^{(1)})\\\\ dp_i^{(1)}&=\\sum_{j=1}^{i-1}dp_j^{(0)}\\times dp_{i-j}^{(1)}+dp_j^{(1)}\\times(dp_{i-j}^{(0)}+dp_{i-j}^{(1)})\\\\ \\end{aligned}代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const uint64_t mod = 1000000007; auto add = [&amp;mod] (const uint64_t&amp; a, const uint64_t&amp; b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;; auto mul = [&amp;mod] (const uint64_t&amp; a, const uint64_t&amp; b) &#123; return a * b % mod; &#125;; const size_t maxn = 5000; vector&lt;uint64_t&gt; dp0(maxn + 1), dp1(maxn + 1); dp0[1] = dp1[1] = 1; for (size_t i = 2; i &lt;= maxn; ++i) for (size_t j = 1; j != i; ++j) &#123; dp0[i] = add(dp0[i], mul(dp0[j], add(dp0[i - j], dp1[i - j]))); dp1[i] = add(dp1[i], add(mul(dp0[j], dp1[i - j]), mul(dp1[j], add(dp0[i - j], dp1[i - j])))); &#125; size_t T, n; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; cout &lt;&lt; dp0[n] &lt;&lt; endl; &#125;&#125; G. 慢慢变小的序列题目大意需要对序列$~A_1,A_2,\\dots,A_n~$支持两种操作。修改操作为将区间$~[L,R]~$与首项为$~X~$，公差为$~Y~$的等差数列取最小值。查询操作为查询$~A_x~$的值。数据范围$~1\\leq n,q\\leq100000,~{\\mid A\\mid}\\leq100000,~{\\mid X\\mid}\\leq100000,~{\\mid Y\\mid}\\leq5~$。 题解注意到$~Y~$的数据范围，用$~11~$棵线段树维护每种公差的修改即可。总时间复杂度为$~O(11q\\log n)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;inline void minn(int&amp; x, const int&amp; y) &#123; x = min(x, y); &#125;int seg[11][1 &lt;&lt; 18];#define lson (index &lt;&lt; 1)#define rson (lson ^ 1)#define mid ((begin + end) &gt;&gt; 1)#define LEFT begin, mid, lson#define RIGHT mid, end, rson#define SEG left, rightvoid build5(int begin, int end, int index) &#123; if (begin + 1 == end) &#123; cin &gt;&gt; seg[5][index]; return; &#125; build5(LEFT); build5(RIGHT);&#125;void modify(int id, int begin, int end, int index, int left, int right, int x) &#123; if (left &gt;= end || right &lt;= begin) return; if (left &lt;= begin &amp;&amp; right &gt;= end) &#123; minn(seg[id][index], x + (begin - left) * (id - 5)); return; &#125; modify(id, LEFT, SEG, x); modify(id, RIGHT, SEG, x);&#125;int query(int id, int begin, int end, int index, int pos) &#123; if (pos &gt; end || pos &lt;= begin) return inf; if (begin + 1 == end) return seg[id][index]; return min(min(query(id, LEFT, pos), query(id, RIGHT, pos)), seg[id][index] + (pos - begin - 1) * (id - 5));&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #define endl '\\n' memset(seg, 0x3f, sizeof (seg)); int n, q; cin &gt;&gt; n &gt;&gt; q; build5(0, n, 1); while (q--) &#123; int opt; cin &gt;&gt; opt; if (opt == 1) &#123; int l, r, x, y; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x &gt;&gt; y; modify(y + 5, 0, n, 1, l - 1, r, x); &#125; else &#123; int x; cin &gt;&gt; x; int res = inf; for (int i = 0; i &lt;= 10; ++i) minn(res, query(i, 0, n, 1, x)); cout &lt;&lt; res &lt;&lt; endl; &#125; &#125;&#125; H. 你不知道的故事题目大意有$~2^k-1~$个灯和开关，初始亮灭状态给出。可以把它们视作一棵完全二叉树的$~\\text{BFS}~$序。对于每个开关$~i~$，它一定能控制对应位置的灯$~i~$，有可能控制灯$~2i,2i+1,\\lfloor\\frac{i}{2}\\rfloor~$，即完全二叉树上与它相邻的点。且保证每个灯不会被它的两个儿子开关同时控制。对于任意一种全局开关控制情况，均对应着一种开关方式使得亮的灯数最多。现问这个最多灯数的最小值（在所有全局开关控制情况下）。 题解动态规划。显然直接暴力枚举所有的全局开关控制情况然后做树形$~\\text{DP}~$是不可能的。用三个$~01~$状态分别记录当前点的亮灭情况，父亲的亮灭情况，自己的开关能否控制父亲。数值表示的是当前点的子树能对答案的最大贡献。转移过程暴力枚举自己的开关能否控制左右儿子，左右儿子的开关能否控制自己，共$~12~$种情况取$~\\min~$，然后根据自己是否按开关取$~\\max~$。 代码12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int a[1 &lt;&lt; 15], dp[1 &lt;&lt; 15][2][2][2];int main() &#123; #define loop(o) for (int o = 0; o != 2; ++o) int k; cin &gt;&gt; k; for (int i = 1; i != (1 &lt;&lt; k); ++i) cin &gt;&gt; a[i]; memset(dp, 0x3f, sizeof (dp)); for (int i = 1 &lt;&lt; k &gt;&gt; 1; i != (1 &lt;&lt; k); ++i) loop(s) loop(f) loop(x) dp[i][s][f][x] = max((s ^ 1) + x - ((x &amp; f) &lt;&lt; 1), s); for (int i = (1 &lt;&lt; k &gt;&gt; 1) - 1; i; --i) loop(s) loop(f) loop(x) loop(l) loop(r) loop(lf) loop(rf) if (!(lf &amp; rf)) dp[i][s][f][x] = min(dp[i][s][f][x], max( dp[i &lt;&lt; 1][l ^ a[i &lt;&lt; 1]][s ^ 1][lf] + dp[i &lt;&lt; 1 ^ 1][r ^ a[i &lt;&lt; 1 ^ 1]][s ^ 1][rf] + (s ^ 1) + x - ((x &amp; f) &lt;&lt; 1), dp[i &lt;&lt; 1][ a[i &lt;&lt; 1]][s ][lf] + dp[i &lt;&lt; 1 ^ 1][ a[i &lt;&lt; 1 ^ 1]][s ][rf] + s )); cout &lt;&lt; dp[1][a[1]][0][0] &lt;&lt; endl;&#125;","categories":[{"name":"比赛笔记","slug":"比赛笔记","permalink":"http://yoursite.com/categories/比赛笔记/"}],"tags":[]},{"title":"2019BITCPC","slug":"2019BITCPC","date":"2019-04-26T15:37:04.393Z","updated":"2019-04-26T15:37:12.773Z","comments":true,"path":"2019/04/26/2019BITCPC/","link":"","permalink":"http://yoursite.com/2019/04/26/2019BITCPC/","excerpt":"","text":"2019BITCPC A. 两只脑斧题目大意水题。 题解水题。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; map&lt;string, char&gt; res; res[\"0\"] = 'X'; res[\"5--\"] = 'E'; res[\"2-\"] = 'I'; res[\"1-\"] = 'E'; res[\"4-\"] = 'I'; res[\"3-\"] = 'E'; res[\"6-\"] = 'I'; res[\"5-\"] = 'E'; res[\"7-\"] = 'I'; res[\"1\"] = 'E'; res[\"2\"] = 'I'; res[\"3\"] = 'E'; res[\"4\"] = 'I'; res[\"5\"] = 'E'; res[\"6\"] = 'I'; res[\"1+\"] = 'E'; res[\"7\"] = 'I'; res[\"3+\"] = 'E'; res[\"2+\"] = 'I'; res[\"5+\"] = 'E'; res[\"4+\"] = 'I'; res[\"1++\"] = 'E'; res[\"6+\"] = 'I'; res[\"3++\"] = 'E'; res[\"7+\"] = 'I'; size_t n; cin &gt;&gt; n; while (n--) &#123; string str; cin &gt;&gt; str; cout &lt;&lt; res[str]; &#125; cout &lt;&lt; endl;&#125; B. 炼金术题目大意给$~m~$个小写字母串，要求输出一个长度为$~n~$的小写字母串，使得所有给定串都不是它的子串。保证一定有解。数据范围$~1\\leq n\\leq10^5,~1\\leq m\\leq10^4,~{\\sum_{i=1}^{m}\\mid s_i\\mid}\\leq3\\times10^5~$。 题解建立$~\\text{AC}~$自动机，那么可以将其看成一个有向图，显然每个单词末尾字符所对应的节点是不可经过的。在建立自动机的$~\\text{BFS}~$过程中，将当前节点是否可经过属性逻辑或上其$~fail~$节点的属性。那么扣去不可经过的节点，题目转化为在该有向图任意寻找一条长度为$~n~$的链。通过$~\\text{DFS}~$寻找环，如果无环，则在$~\\text{DAG}~$上$~\\text{DP}~$，总时间复杂度为$~O(n+\\sum s)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;struct ACAM &#123; static const size_t maxs = 1 &lt;&lt; 20; static const size_t ch_size = 26; struct &#123; size_t next[ch_size], fail, to, dis; bool end, vis; &#125; trie[maxs]; size_t size, n; char res[maxs]; void init() &#123; memset(trie, 0, sizeof (trie)); size = 1, res[n] = '\\0'; &#125; void insert(const char str[], size_t len) &#123; size_t cur = 0; for (size_t i = 0; i != len; ++i) &#123; size_t ch = str[i] - 'a'; if (!trie[cur].next[ch]) trie[cur].next[ch] = size++; cur = trie[cur].next[ch]; &#125; trie[cur].end = true; &#125; void build_fail() &#123; queue&lt;size_t&gt; que; for (size_t i = 0; i != ch_size; ++i) if (trie-&gt;next[i]) que.emplace(trie-&gt;next[i]); while (!que.empty()) &#123; size_t cur = que.front(); que.pop(); for (size_t i = 0; i != ch_size; ++i) &#123; if (trie[cur].next[i]) &#123; trie[trie[cur].next[i]].fail = trie[trie[cur].fail].next[i]; que.emplace(trie[cur].next[i]); &#125; else &#123; trie[cur].next[i] = trie[trie[cur].fail].next[i]; &#125; &#125; trie[cur].end |= trie[trie[cur].fail].end; trie[cur].to = -1; &#125; trie[0].to = -1; &#125; bool dfs1(size_t cur = 0, size_t index = 0) &#123; if (index == n) return true; if (~trie[cur].to) &#123; res[index++] = 'a' + trie[cur].to; return dfs1(trie[cur].next[trie[cur].to], index); &#125; if (trie[cur].vis) return false; trie[cur].vis = true; for (size_t i = 0; i != ch_size; ++i) if (!trie[trie[cur].next[i]].end) &#123; res[index] = 'a' + i; if (dfs1(trie[cur].next[trie[cur].to = i], index + 1)) return true; else trie[cur].to = -1; &#125; return false; &#125; size_t dfs2(size_t cur = 0) &#123; if (trie[cur].dis) return trie[cur].dis; for (size_t i = 0; i != ch_size; ++i) if (!trie[trie[cur].next[i]].end) trie[cur].dis = max(trie[cur].dis, dfs2(trie[cur].next[i])); return ++trie[cur].dis; &#125; void route() &#123; for (size_t i = 0, cur = 0; i != n; ++i) &#123; for (size_t j = 0; j != ch_size; ++j) if (i + trie[trie[cur].next[j]].dis &gt;= n) &#123; res[i] = 'a' + j; break; &#125; &#125; &#125;&#125; acam;int main() &#123; ios::sync_with_stdio(false); size_t m; cin &gt;&gt; acam.n &gt;&gt; m; acam.init(); while (m--) &#123; string str; cin &gt;&gt; str; acam.insert(str.data(), str.size()); &#125; acam.build_fail(); if (!acam.dfs1()) &#123; assert(acam.dfs2() &gt; acam.n); acam.route(); &#125; cout &lt;&lt; acam.res &lt;&lt; endl;&#125; C. 赛尔逵传说题目大意打怪兽。怪兽血量为$~d~$，攻击力为$~x~$，自己攻击力为$~k~$。同时可以嗑最多$~c~$次$~\\text{buff}~$，使得下一次攻击力增加$~k~$，随后失效。怪物轮流上，自己先攻击，问最少损失的血量。数据范围$~1\\leq n\\leq10^5,~1\\leq k,c\\leq10^6,~1\\leq d,x\\leq10^6~$。 题解在不考虑$~\\text{buff}~$的条件下，对付每个怪兽需要受到的攻击次数为$~\\lfloor\\frac{d-1}{k}\\rfloor~$，而每层$~\\text{buff}~$可以使得该次数减$~1~$。于是对于怪兽的攻击力$~x~$排序后模拟即可，总时间复杂度为$~O(n\\log n + c)~$。 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; size_t n, k, c; cin &gt;&gt; n &gt;&gt; k &gt;&gt; c; vector&lt;pair&lt;size_t, size_t&gt;&gt; monster(n); for (auto&amp; m : monster) &#123; size_t d, x; cin &gt;&gt; d &gt;&gt; x; m = pair&lt;size_t, size_t&gt;(x, (d - 1) / k); &#125; sort(monster.begin(), monster.end()); reverse(monster.begin(), monster.end()); uint64_t res = 0; for (auto m : monster) &#123; size_t cur = min(c, m.second); c -= cur; res += m.first * uint64_t(m.second - cur); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. 碟中谍题目大意有一个通道，上下侧为$~y=w~$和$~y=0~$，左右侧为$~x=+\\infty~$和$~x=-\\infty~$。同时平面上有$~n~$个圆形障碍物，坐标为$~(x,y)~$，半径为$~r~$。自己也是圆形，问最大的半径使得可以从左边移动至右边。数据范围$~1\\leq T\\leq100,~1\\leq 2\\leq10^5,~0\\leq n\\leq10^3,~-10^5\\leq x\\leq10^5,~0\\leq y\\leq w,~1\\leq r\\leq10^5~$。 题解假设当前自己的半径为$~R~$。则可以把上下侧改为$~y=w-R~$和$~y=R~$，每个圆的半径都增加$~R~$。那么此时能否通过等价于是否存在一条无半径路径穿越这个通道，等价于这些圆是否将上下侧连通。那么本题可以转化为最短路问题，路径的长度定义为路径上边的长度的最大值，边的长度定义为两个圆的距离。用$~\\text{Dijstra}~$算法，总时间复杂度为$~O(Tn^2)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const size_t maxn = 1 &lt;&lt; 10;const double inf = 1e18;struct Circle &#123; double x, y, r; &#125; circle[maxn];inline double dis(const Circle&amp; c1, const Circle&amp; c2) &#123; return max(0.0, hypot(c1.x - c2.x, c1.y - c2.y) - c1.r - c2.r); &#125;double cost[maxn][maxn], res[maxn];bool vis[maxn];int main() &#123; size_t t; scanf(\"%u\", &amp;t); while (t--) &#123; double w; size_t n; scanf(\"%lf%u\", &amp;w, &amp;n); for (size_t i = 0; i != n; ++i) scanf(\"%lf%lf%lf\", &amp;circle[i].x, &amp;circle[i].y, &amp;circle[i].r); for (size_t i = 0; i != n; ++i) for (size_t j = 0; j != n; ++j) cost[i][j] = dis(circle[i], circle[j]); cost[n + 1][n + 1] = cost[n][n] = 0; cost[n + 1][n] = cost[n][n + 1] = w; for (size_t i = 0; i != n; ++i) &#123; cost[n + 1][i] = cost[i][n + 1] = max(0.0, circle[i].y - circle[i].r); cost[n][i] = cost[i][n] = max(0.0, w - circle[i].y - circle[i].r); &#125; n += 2; for (size_t i = 0; i != n; ++i) res[i] = inf; memset(vis, 0, n); res[n - 1] = 0; size_t next = n - 1; while (next != n - 2U) &#123; vis[next] = true; double cur = inf; size_t last = next; for (size_t i = 0; i != n; ++i) if (!vis[i]) if ((res[i] = min(res[i], max(res[last], cost[last][i]))) &lt; cur) next = i, cur = res[i]; &#125; printf(\"%.6f\\n\", res[n - 2] / 2); &#125;&#125; E. 只有一端开口的瓶子题目大意现在有一个$~1,2,\\dots,n~$的全排列构成的序列和$~k~$个空的栈。可以有如下三种操作：把当前序列的头部放入第$~p~$个栈的顶部；把第$~p~$个栈的顶部放入新序列的尾部；把第$~p~$个栈的顶部放入第$~q~$个栈的顶部。最终要使得新序列升序，即为$~1,2,\\dots,n~$。先给定$~T~$组全排列，问这些全排列分别至少需要准备多少个栈才能完成升序操作。数据范围$~1\\leq T\\leq100,~1\\leq n\\leq10^5~$。 题解不难发现答案不会大于$~2~$，那么只需要判断答案是否为$~1~$即可。线性栈模拟，总时间复杂度为$~O(Tn)~$。 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; size_t t; cin &gt;&gt; t; while (t--) &#123; size_t n; cin &gt;&gt; n; size_t next = 1; stack&lt;size_t&gt; sta; while (n--) &#123; size_t p; cin &gt;&gt; p; sta.emplace(p); while (!sta.empty() &amp;&amp; sta.top() == next) &#123; sta.pop(); ++next; &#125; &#125; cout &lt;&lt; (sta.empty() ? 1 : 2) &lt;&lt; endl; &#125;&#125; F. 风王之瞳题目大意计算长宽为$~n,m~$的正方形网格图有多少个格点正方形。 题解不妨设$~n\\leq m~$。先考虑对于边长为$~k\\leq n~$的正方形，顶点都落在该正方形上的格点正方形有$~k~$个。而这样的正方形有$~(n-k+1)(m-k+1)~$个。于是答案为 \\sum_{k=1}^{n}k(n-k+1)(m-k+1)=\\frac{n(n+1)(n+2)(2m-n+1)}{12}代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; size_t t; cin &gt;&gt; t; while (t--) &#123; uint64_t n, m; cin &gt;&gt; n &gt;&gt; m; if (n &gt; m) swap(n, m); cout &lt;&lt; n * (n + 1) * (n + 2) / 6 * (2 * m - n + 1) / 2 &lt;&lt; endl; &#125;&#125; G. 神圣的 F2 连接着我们题目大意有一个二分图，两边的编号都是$~1,2,\\dots,n~$，左边有$~p~$个关键点$~x_1,x_2,\\dots,x_p~$，右边有$~q~$个关键点$~y_1,y_2,\\dots,y_q~$。还有$~m~$组双向边，权值为$~w~$，将左边编号在$~[a,b]~$的点于右边编号在$~[c,d]~$的点相连，注意同一侧的点之间是没有边的。需要所有左边的关键点$~x~$到右边最近的$~y~$的距离，或者无法连通。数据范围$~1\\leq n,m,p,q\\leq10^5,~1\\leq a\\leq b\\leq n,~1\\leq c\\leq d\\leq n,~1\\leq w\\leq10^9~$。 题解显然是多源最短路问题，关键在于如何建图，如果暴力建图那么边数是$~O(nm)~$的。对于每侧的点都建立两棵线段树：在线段树一上，所有的父子对都连一条父亲指向儿子的权值为$~0~$的边；在线段树二上，所有的父子对都连一条儿子指向父亲的权值为$~0~$的边；在两颗线段树对应的点对上，连一条线段树一上节点指向线段树二上节点的权值为$~0~$的边。对于题目给出的边，将区间$~[a,b]~$和$~[c,d]~$在两边的线段树上分解，再给图增加两个中间点代表从左到右和从右到左的边。连接的边有：在左二树分解到的节点指向一号中间点的权值为$~w~$的边；一号中间点指向在右一树分解到的节点的权值为$~0~$的边；在右二树上分解到的节点指向二号中间点的权值为$~w~$的边；二号中间点指向在左一树分解到的节点的权值为$~0~$的边。然后跑堆优化的$~\\text{Dijstra}~$多源最短路，只要在最开始将所有的$~y~$入堆，剩下的步骤和单源最短路一致。总时间复杂度为$~O(m\\log^2n)~$，空间复杂度为$~O(n+m\\log n)~$。注意本题会卡时间常数和空间常数。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (index &lt;&lt; 1)#define rson (lson ^ 1)#define mid ((begin + end) &gt;&gt; 1)#define LEFT begin, mid, lson, side#define RIGHT mid, end, rson, side#define SEG left, right#define size_t uint32_tconst size_t maxn = 100005;const size_t zero = 0;size_t pos[2][maxn], graph_size, seg[2][maxn &lt;&lt; 2];struct &#123; uint64_t dis; size_t side, index; &#125; node[maxn * 10];vector&lt;pair&lt;size_t, size_t&gt;&gt; dir[maxn * 10];void build(size_t begin, size_t end, size_t index, size_t side) &#123; node[graph_size &lt;&lt; 1].side = node[graph_size &lt;&lt; 1 ^ 1].side = side; node[graph_size &lt;&lt; 1].index = node[graph_size &lt;&lt; 1 ^ 1].index = index; node[graph_size &lt;&lt; 1].dis = node[graph_size &lt;&lt; 1 ^ 1].dis = -1; dir[graph_size &lt;&lt; 1].emplace_back(graph_size &lt;&lt; 1 ^ 1, zero); seg[side][index] = graph_size++; if (begin + 1U == end) &#123; pos[side][end] = index; return; &#125; build(LEFT); build(RIGHT); dir[seg[side][index] &lt;&lt; 1].emplace_back(seg[side][lson] &lt;&lt; 1, zero); dir[seg[side][index] &lt;&lt; 1].emplace_back(seg[side][rson] &lt;&lt; 1, zero); dir[seg[side][lson] &lt;&lt; 1 ^ 1].emplace_back(seg[side][index] &lt;&lt; 1 ^ 1, zero); dir[seg[side][rson] &lt;&lt; 1 ^ 1].emplace_back(seg[side][index] &lt;&lt; 1 ^ 1, zero);&#125;void link(size_t left, size_t right, size_t begin, size_t end, size_t index, size_t side, size_t w) &#123; if (left &gt;= end || right &lt;= begin) return; if (left &lt;= begin &amp;&amp; right &gt;= end) &#123; dir[seg[side][index] &lt;&lt; 1 ^ 1].emplace_back(graph_size &lt;&lt; 1 ^ side, w); dir[graph_size &lt;&lt; 1 ^ 1 ^ side].emplace_back(seg[side][index] &lt;&lt; 1, zero); return; &#125; link(SEG, LEFT, w); link(SEG, RIGHT, w);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); size_t n, m, p, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; q; build(0, n, 1, 0); build(0, n, 1, 1); while (m--) &#123; size_t a, b, c, d, w; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; w; node[graph_size &lt;&lt; 1].side = node[graph_size &lt;&lt; 1 ^ 1].side = -1; node[graph_size &lt;&lt; 1].index = node[graph_size &lt;&lt; 1 ^ 1].index = -1; node[graph_size &lt;&lt; 1].dis = node[graph_size &lt;&lt; 1 ^ 1].dis = -1; link(--a, b, 0, n, 1, 0, w); link(--c, d, 0, n, 1, 1, w); ++graph_size; &#125; vector&lt;size_t&gt; x(p); for (auto&amp; xx : x) cin &gt;&gt; xx; priority_queue&lt;pair&lt;uint64_t, size_t&gt;, vector&lt;pair&lt;uint64_t, size_t&gt;&gt;, greater&lt;pair&lt;uint64_t, size_t&gt;&gt;&gt; que; while (q--) &#123; size_t y; cin &gt;&gt; y; que.emplace(uint64_t(zero), seg[1][pos[1][y]] &lt;&lt; 1); &#125; while (!que.empty()) &#123; uint64_t dis = que.top().first; size_t cur = que.top().second; que.pop(); if (~node[cur].dis) continue; node[cur].dis = dis; for (auto next : dir[cur]) if (!~node[next.first].dis) que.emplace(dis + next.second, next.first); dir[cur].clear(); &#125; uint64_t res = zero; for (auto xx : x) res = max(res, node[seg[0][pos[0][xx]] &lt;&lt; 1].dis); if (~res) cout &lt;&lt; res &lt;&lt; endl; else cout &lt;&lt; \"boring game\" &lt;&lt; endl;&#125; H. 目标是成为数论大师题目大意问$~f(x)=\\sqrt{ax}+b~$的点，保证存在且为整数。输出格式为升序不重。数据范围$~1\\leq T\\leq100,~-10^3\\leq a,b\\leq10^3~$。 题解解二次方程，注意细节。 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; size_t t; cin &gt;&gt; t; while (t--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; res; auto add = [&amp;] (int x) &#123; if ((int)round(sqrt(a * x)) + b == x) res.emplace_back(x); &#125;; int delta = round(sqrt(a * a + 4 * a * b)); add((a + 2 * b - delta) / 2); add((a + 2 * b + delta) / 2); sort(res.begin(), res.end()); res.resize(unique(res.begin(), res.end()) - res.begin()); cout &lt;&lt; res.size() &lt;&lt; endl &lt;&lt; res.front(); for (size_t i = 1; i != res.size(); ++i) cout &lt;&lt; ' ' &lt;&lt; res[i]; cout &lt;&lt; endl; &#125;&#125; I. 出给 paul-lu 的数数题题目大意一个$~n\\times n~$的表上每个位置的值只能取$~[1,k]~$。定义一个位置为$~\\text{bi}~$点当且仅当它严格大于它所处的行与列的所有其它的值。记$~B_i\\in[0,n^2]~$为恰好有$~i~$个$~\\text{bi}~$点的方案数。计算$~\\sum_{i=0}^{n^2}{i^2\\cdot B_i}~$。数据范围$~1\\leq T\\leq20,~1\\leq n,k\\leq200~$。 题解对任意方案$~A~$，用$~f(A)~$表示该方案下的$~\\text{bi}~$点的数量，则有 \\sum_{i=0}^{n^2}{i^2\\cdot B_i}=\\sum_Af^2(A)用$~S(A)~$表示该方案下的所有$~\\text{bi}~$点的集合，则 f(A)=\\sum_{p\\in S(A)}1于是 \\sum_{i=0}^{n^2}{i^2\\cdot B_i}=\\sum_A\\sum_{p_1\\in S(A)}\\sum_{p_2\\in S(A)}1对于两点$~p_1,p_2~$（可重），用$~g(p_1,p_2)~$表示它们均为$~\\text{bi}~$的方案数，则可以交换求和顺序，得到 \\sum_{i=0}^{n^2}{i^2\\cdot B_i}=\\sum_{p_1}\\sum_{p_2}g(p_1,p_2)当$~p_1,p_2~$不重合但同行或者同列时，显然有$~g=0~$。不难发现$~g~$其实只有$~2~$种非平凡取值，即$~p_1,p_2~$重合时和$~p_1,p_2~$不重合时。那么令$~g_0=g((1,1),(1,1)),~g_1=g((1,1),(2,2))~$，则有 g_0=k^{(n-1)^2}\\sum_{i=0}^{k-1}i^{2(n-1)} \\\\ g_1=k^{(n-2)^2}\\sum_{i=0}^{k-1}\\sum_{j=0}^{k-1}\\min(i,j)^{2(n-1)}\\max(i,j)^{2(n-2)} \\\\ \\sum_{i=0}^{n^2}{i^2\\cdot B_i}=n^2g_0+n^2(n-1)^2g_1 \\\\剩下的计算步骤是十分简单的。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const uint64_t mod = 1000000007; auto sub = [&amp;] (const uint64_t&amp; a, const uint64_t&amp; b) &#123; return a &lt; b ? a - b + mod : a - b; &#125;; auto add = [&amp;] (const uint64_t&amp; a, const uint64_t&amp; b) &#123; return sub(a, mod - b); &#125;; auto mul = [&amp;] (const uint64_t&amp; a, const uint64_t&amp; b) &#123; return a * b % mod; &#125;; auto fpow = [&amp;] (uint64_t a, uint64_t n) &#123; uint64_t ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret; &#125;; size_t t; cin &gt;&gt; t; while (t--) &#123; uint64_t n, k; cin &gt;&gt; n &gt;&gt; k; uint64_t cal1 = 0, cal2 = 0; for (uint64_t i = 0; i != k; ++i) cal1 = add(cal1, fpow(i, (n - 1) &lt;&lt; 1)); cal1 = mul(cal1, fpow(k, (n - 1) * (n - 1))); for (uint64_t i = 0; i != k; ++i) for (uint64_t j = 0; j != k; ++j) cal2 = add(cal2, mul(fpow(min(i, j), (n - 1) &lt;&lt; 1), fpow(max(i, j), (n - 2) &lt;&lt; 1))); cal2 = mul(mul(cal2, (n - 1) * (n - 1)), fpow(k, (n - 2) * (n - 2))); cout &lt;&lt; mul(add(cal1, cal2), n * n) &lt;&lt; endl; &#125;&#125; J. 金色传说题目大意定义一个长度为$~n~$的字符串表达式合法，当且仅当它仅由$~0,1,\\dots,9~$，以及$~+~$或$~-~$组成，且首尾不能是运算符，运算符不相邻（注意允许数字有前导零）。问所有长度为$~n~$的合法字符串表达式的值之和。数据范围$~1\\leq T\\leq100,~1\\leq n\\leq5\\times10^5~$。 题解设答案序列为$~{f_n}~$，前几项$~f_0=0,~f_1=45,~f_2=4950,\\dots~$，其生成多项式为 F(x)=\\sum_{n=0}^{\\infty}f_nx^n准备工作先考虑序列$~{g_n:g_n=10^n}~$，易得其生成多项式为 G(x)=~\\sum_{n=0}^{\\infty}10^nx^n=\\frac{1}{1-10x}考虑仅有数字组成的字符串，对应的答案序列为$~{h_n:h_n=\\frac{10^n(10^n-1)}{2}}~$，其生成多项式可以推出为 H(x)=\\sum_{n=0}^{\\infty}h_nx^n=\\frac{1}{2}\\left(\\frac{1}{1-100x}-\\frac{1}{1-10x}\\right)计算$~f_n~$。若没有运算符，则对$~f_n~$为$~h_n~$。若有运算符，考虑最后一个数字的长度$~k~$，满足$~1\\leq k\\leq n-2~$。此时最后一个数字有$~g_k~$种取法，运算符有$~2~$种取法。注意到此时由于正负号相消，最后一个数字对于$~f_n~$的贡献为$~0~$，于是剩下的贡献为$~2g_kf_{n-1-k}~$。即 \\begin{aligned} f_n &=h_n+2\\sum_{k=1}^{n-2}g_kf_{n-1-k} \\\\ &=h_n-2f_{n-1-k}+2\\sum_{k=0}^{n-1}g_kf_{n-1-k} \\\\ \\end{aligned}这是一个卷积式，它对于$n\\geq1~$均满足。于是对于$~n=1,2,\\dots~$，等式两边乘以$~x^{n-1}~$后累加，可以得出生成多项式的等式 \\frac{F(x)-F(0)}{x}=\\frac{H(x)-H(0)}{x}-2F(x)+2G(x)F(x)可以算出 F(x)=\\frac{1}{1-110x+980x^2+2000x^3}于是对于$~n\\geq3~$，有线性递推式 f_n=110f_{n-1}-980f_{n-2}-2000f_{n-3}预处理或者矩阵快速幂均可通过此题，时间复杂度分别为$~O(n+T)~$和$~O(T\\log n)~$。 代码（$~O(T\\log n)~$）12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const size_t mod = 998244353; auto add = [&amp;] (const size_t&amp; a, const size_t&amp; b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;; auto mul = [&amp;] (const size_t&amp; a, const size_t&amp; b) &#123; return 1LL * a * b % mod; &#125;; auto mat_mul = [&amp;] (size_t A[3][3], size_t B[3][3], size_t C[3][3]) &#123; for (size_t i = 0; i != 3; ++i) for (size_t j = 0; j != 3; ++j) for (size_t k = 0; k != 3; ++k) C[i][j] = add(C[i][j], mul(A[i][k], B[k][j])); &#125;; size_t t; cin &gt;&gt; t; while (t--) &#123; size_t n, res[3][3] = &#123; &#123; 1, 0, 0 &#125;, &#123; 0, 1, 0 &#125;, &#123; 0, 0, 1 &#125; &#125;, bas[3][3] = &#123; &#123; 110, mod - 980, mod - 2000 &#125;, &#123; 1, 0, 0, &#125;, &#123; 0, 1, 0 &#125; &#125;, tmp[3][3]; for (cin &gt;&gt; n; n; n &gt;&gt;= 1) &#123; if (n &amp; 1) &#123; memset(tmp, 0, sizeof (tmp)); mat_mul(res, bas, tmp); memcpy(res, tmp, sizeof (tmp)); &#125; memset(tmp, 0, sizeof (tmp)); mat_mul(bas, bas, tmp); memcpy(bas, tmp, sizeof (tmp)); &#125; cout &lt;&lt; mul(add(mul(res[2][0], 110), res[2][1]), 45) &lt;&lt; endl; &#125;&#125; K. 多项式求导题目大意多项式求导。 题解水题。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const int mod = 998244353; auto mul = [&amp;mod] (const int&amp; a, const int&amp; b) &#123; return 1LL * a * b % mod; &#125;; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n + 1); for (int i = n; ~i; --i) cin &gt;&gt; a[i]; while (k--) &#123; vector&lt;int&gt; a_(n + 1, 0); for (int i = n; i; --i) a_[i - 1] = mul(a[i], i); a = a_; &#125; for (int i = n; i; --i) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; a.front() &lt;&lt; endl;&#125; L. 旅行的意义题目大意地图是个$~\\text{DAG}~$，起点为$~1~$。每到一个新的点会停留$~1~$天，然后等概率的选择再留$~1~$天或者去下一个可以到的点，路程花费$~1~$天。至多停留$~2~$天，然后必须等概率的选择下一个可以到的点，如果不能继续则停止。问总天数的期望。数据范围$~1\\leq T\\leq10,~1\\leq n\\leq10^5,~0\\leq m\\leq10^5~$ 题解裸的$~\\text{DAG}~$上概率$~\\text{DP}~$，代码使用的拓扑排序代替记忆化$~\\text{DFS}~$。注意快读！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); const int mod = 998244353; auto add = [&amp;mod] (const int&amp; a, const int&amp; b) &#123; return a + b &lt; mod ? a + b : a + b - mod; &#125;; auto mul = [&amp;mod] (const int&amp; a, const int&amp; b) &#123; return 1LL * a * b % mod; &#125;; vector&lt;int&gt; inv(100002, 1); for (int i = 2; i &lt;= 100001; ++i) inv[i] = mul(inv[mod % i], mod - mod / i); size_t t; cin &gt;&gt; t; while (t--) &#123; size_t n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;size_t&gt;&gt; to(n), from(n); vector&lt;size_t&gt; deg(n, 0), topo; vector&lt;int&gt; res(n, 0); while (m--) &#123; size_t u, v; cin &gt;&gt; u &gt;&gt; v; --u; --v; to[u].emplace_back(v); from[v].emplace_back(u); &#125; for (size_t u = 0; u != n; ++u) if (!(deg[u] = to[u].size())) &#123; res[u] = 2; topo.emplace_back(u); &#125; for (size_t i = 0; i != topo.size(); ++i) &#123; auto&amp; u = topo[i]; if (!to[u].empty()) &#123; for (auto v : to[u]) res[u] = add(res[u], res[v]); res[u] = mul(res[u], inv[to[u].size()]); res[u] = add(res[u], inv[to[u].size() + 1] + 2); &#125; for (auto v : from[u]) if (!--deg[v]) topo.emplace_back(v); &#125; cout &lt;&lt; res.front() &lt;&lt; endl; &#125;&#125;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"http://yoursite.com/categories/刷题笔记/"}],"tags":[]},{"title":"Codeforces Round 542 [Alex Lopashev Thanks-Round] (Div. 2)","slug":"Codeforces Round 542 [Alex Lopashev Thanks-Round] (Div. 2)","date":"2019-04-18T10:15:18.855Z","updated":"2019-04-18T10:27:32.608Z","comments":true,"path":"2019/04/18/Codeforces Round 542 [Alex Lopashev Thanks-Round] (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/04/18/Codeforces Round 542 [Alex Lopashev Thanks-Round] (Div. 2)/","excerpt":"","text":"Codeforces Round #542 [Alex Lopashev Thanks-Round] (Div. 2) A. Be Positive题目大意水题。 题解水题。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, a, neg = 0, pos = 0; cin &gt;&gt; n; for (int i = 0; i != n; ++i) &#123; cin &gt;&gt; a; if (a &lt; 0) ++neg; if (a &gt; 0) ++pos; &#125; if (neg * 2 &gt;= n) return cout &lt;&lt; -1 &lt;&lt; endl, 0; if (pos * 2 &gt;= n) return cout &lt;&lt; 1 &lt;&lt; endl, 0; cout &lt;&lt; 0 &lt;&lt; endl;&#125; B. Two Cakes题目大意给定一个长度为$~2n~$的序列，数字$~1,2,\\dots,n~$各出现$~2~$次。有$~2~$人初始再序列的最左边，他们分别要依次拿到$~1,2,\\dots,n~$，且每个数字只能被拿一次，所以结束时刚好拿完。问这$~2~$人移动距离之和的最小值。数据范围$~1\\leq n\\leq10^5~$。 题解水题。见代码。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; pos(n + 1); pos.front() = vector&lt;int&gt;(2, 0); for (int i = 0; i != n * 2; ++i) &#123; int a; cin &gt;&gt; a; pos[a].push_back(i); &#125; long long res = 0; for (int i = 0; i != n; ++i) res += min(abs(pos[i + 1][0] - pos[i][0]) + abs(pos[i + 1][1] - pos[i][1]), abs(pos[i + 1][0] - pos[i][1]) + abs(pos[i + 1][1] - pos[i][0])); cout &lt;&lt; res &lt;&lt; endl;&#125; C. Connect题目大意给一个地图由土和水组成，起点终点均在土上，只能在土上移动。可以至多建$~1~$个隧道连接$~2~$个土，欧式距离的平方。问从起点到终点的最小花费。数据范围$~1\\leq n\\leq50~$。 题解爆搜$~\\text{BFS}~$或者$~\\text{DFS}~$得到起点和终点的联通块，然后暴力枚举隧道的起点和终点即可。总时间复杂度为$~O(n^4)~$。注意到在爆搜过程中，可以不枚举终点纵坐标$~y_2~$，只需要使得$~(y-y_1 )^2~$最小，这一步可以预处理，所以总时间复杂度可以降为$~O(n^3)~$。 代码（$~O(n^4)~$）12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; char cell[52][52]; memset(cell, '1', sizeof (cell)); int dx[4] = &#123; 1, 0, -1, 0 &#125;, dy[4] = &#123; 0, 1, 0, -1 &#125;, dis[52][52]; memset(dis, 0x3f, sizeof (dis)); int n, r1, c1, r2, c2; cin &gt;&gt; n &gt;&gt; r1 &gt;&gt; c1 &gt;&gt; r2 &gt;&gt; c2; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) cin &gt;&gt; cell[i][j]; vector&lt;pair&lt;int, int&gt;&gt; que; auto push = [&amp;] (const int&amp; x, const int&amp; y) &#123; cell[x][y] = '1'; que.emplace_back(x, y); &#125;; push(r2, c2); for (size_t i = 0; i != que.size(); ++i) &#123; int X = que[i].first; int Y = que[i].second; for (int y = 1; y &lt;= n; ++y) dis[X][y] = min(dis[X][y], (Y - y) * (Y - y)); for (size_t j = 0; j != 4U; ++j) if (cell[X + dx[j]][Y + dy[j]] == '0') push(X + dx[j], Y + dy[j]); &#125; int res = INT_MAX; que.clear(); push(r1, c1); for (size_t i = 0; i != que.size(); ++i) &#123; int X = que[i].first; int Y = que[i].second; for (int x = 1; x &lt;= n; ++x) res = min(res, (X - x) * (X - x) + dis[x][Y]); for (size_t j = 0; j != 4U; ++j) if (cell[X + dx[j]][Y + dy[j]] == '0') push(X + dx[j], Y + dy[j]); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; 代码（$~O(n^3)~$）1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;char cell[52][52];int dx[4] = &#123; 1, 0, -1, 0 &#125;, dy[4] = &#123; 0, 1, 0, -1 &#125;, dis[52][52];int main() &#123; memset(cell, '1', sizeof (cell)); memset(dis, 0x3f, sizeof (dis)); int n, r1, c1, r2, c2; cin &gt;&gt; n &gt;&gt; r1 &gt;&gt; c1 &gt;&gt; r2 &gt;&gt; c2; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) cin &gt;&gt; cell[i][j]; vector&lt;pair&lt;int, int&gt;&gt; que; auto push = [&amp;] (const int&amp; x, const int&amp; y) &#123; cell[x][y] = '1'; que.emplace_back(x, y); &#125;; push(r2, c2); for (size_t i = 0; i != que.size(); ++i) &#123; int X = que[i].first; int Y = que[i].second; for (int y = 1; y &lt;= n; ++y) dis[X][y] = min(dis[X][y], (Y - y) * (Y - y)); for (size_t j = 0; j != 4U; ++j) if (cell[X + dx[j]][Y + dy[j]] == '0') push(X + dx[j], Y + dy[j]); &#125; int res = INT_MAX; que.clear(); push(r1, c1); for (size_t i = 0; i != que.size(); ++i) &#123; int X = que[i].first; int Y = que[i].second; for (int x = 1; x &lt;= n; ++x) res = min(res, (X - x) * (X - x) + dis[x][Y]); for (size_t j = 0; j != 4U; ++j) if (cell[X + dx[j]][Y + dy[j]] == '0') push(X + dx[j], Y + dy[j]); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D1. Toy Train (Simplified)题目大意有$~n~$个车站围成环，以及$~m~$颗糖果的初始位置和目标位置。火车每次到站至多只能装$~1~$颗糖果，但是可以卸下若干糖果。问分别以每个站为起点，要将所有糖果送到目标地点，火车的最少行驶距离。数据范围$~2\\leq n\\leq100,~1\\leq m\\leq200~$。 题解考虑第$~i~$站，一共有$~x~$颗糖果以它为起点，且最近的终点为$~y~$，这一步可以在$~O(m)~$内处理完。那么火车第$~1~$次到达该站时，至少还要行驶$~(x-1)\\cdot n+y~$。而每次到达一个新站，取该站目标地点最远的那颗糖果这样就能得到最小距离的方案。按题意枚举起点以及起点到所有站的距离，总时间复杂度为$~O(n^2+m)~$。 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; dis(n + 1, 0), cnt(n + 1, 0); while (m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; ++cnt[a]; dis[a] = min(dis[a], a &gt; b ? b - a : b - a - n); &#125; for (int i = 1; i &lt;= n; ++i) &#123; int res = 0; for (int j = 1; j &lt;= n; ++j) if (cnt[j]) res = max(res, (i &gt; j ? j - i + n : j - i) + cnt[j] * n + dis[j]); cout &lt;&lt; res &lt;&lt; ' '; &#125; cout &lt;&lt; endl;&#125; D2. Toy Train题目大意上一题的基础上增加数据范围$~2\\leq n\\leq5000,~1\\leq m\\leq20000~$。 题解上一题的$~O(n^2+m)~$做法依然能过。但是注意到在计算第$~1~$个位置的答案时，已经处理的大部分区间的最小值。那么只需要记录前缀$~\\min~$和后缀$~\\min~$，这样每个位置的答案可以在$~O(1)~$内求出，总时间复杂度为$~O(n+m)~$。 代码（$~O(n+m)~$）1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; dis(n + 1, 0), cnt(n + 1, 0); while (m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; ++cnt[a]; dis[a] = min(dis[a], a &gt; b ? b - a : b - a - n); &#125; vector&lt;int&gt; pre(n, -n), suf(n + 2, -n); for (int i = 1; i != n; ++i) &#123; pre[i] = pre[i - 1]; if (cnt[i]) pre[i] = max(pre[i], cnt[i] * n + dis[i] + i); &#125; for (int i = n; i; --i) &#123; suf[i] = suf[i + 1]; if (cnt[i]) suf[i] = max(suf[i], cnt[i] * n + dis[i] + i); &#125; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; max(pre[i - 1] + n - i, suf[i] - i) &lt;&lt; ' '; cout &lt;&lt; endl;&#125; E. Wrong Answer题目大意要计算一个序列的 \\max_{0\\leq l\\leq r< n}{(r-l+1)\\sum_{i=l}^{r}{a_i}}现给出一个假算法的伪代码12345678910111213function find_answer(n, a) # Assumes n is an integer between 1 and 2000, inclusive # Assumes a is a list containing n integers: a[0], a[1], ..., a[n-1] res = 0 cur = 0 k = -1 for i = 0 to i = n-1 cur = cur + a[i] if cur &lt; 0 cur = 0 k = i res = max(res, (i-k)*cur) return res 输出一个序列$~a_0,a_1,\\dots,a_{n-1}~$满足正确算法得到的答案比假算法得到的答案恰好大$~k~$。数据范围$~1\\leq k\\leq10^9,~1\\leq n\\leq2000,~{\\mid a_i\\mid}\\leq10^6~$。 题解不妨令$~a_0=0,~a_i\\geq 0,~\\forall~i&gt;0,~S=\\sum_{i&gt;0} a_i&gt;1~$。于是有$~k=n(S-1)-(n-1)S=S-n~$。令$~n=2000~$，于是$~S=k+2000~$，构造方法十分简单。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const int maxn = 2000; const int maxa = 1000000; int k; cin &gt;&gt; k; k += maxn; cout &lt;&lt; maxn &lt;&lt; endl &lt;&lt; -1; for (int i = 1; i != maxn; ++i) &#123; if (k &gt; maxa) cout &lt;&lt; ' ' &lt;&lt; maxa, k -= maxa; else cout &lt;&lt; ' ' &lt;&lt; k, k = 0; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 541 (Div. 2)","slug":"Codeforces Round 541 (Div. 2)","date":"2019-03-12T05:49:45.902Z","updated":"2019-03-12T05:49:52.721Z","comments":true,"path":"2019/03/12/Codeforces Round 541 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/03/12/Codeforces Round 541 (Div. 2)/","excerpt":"","text":"Codeforces Round #541 (Div. 2) A. Sea Battle题目大意水题。 题解水题。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int w1, h1, w2, h2; cin &gt;&gt; w1 &gt;&gt; h1 &gt;&gt; w2 &gt;&gt; h2; cout &lt;&lt; (w1 + h1 + h2 + 2 &lt;&lt; 1) &lt;&lt; endl;&#125; B. Draw!题目大意水题。 题解水题。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int last = 0, res = 1; while (n--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; res += max(0, min(a, b) - last); last = max(a, b) - (a != b); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; C. Birthday题目大意给定$~n~$个数子，要求排成一个环，使得相邻的差的绝对值之和最小。 题解贪心。升序后奇项排一起偶项排一起。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; sort(a.begin(), a.end()); for (int i = 0; i &lt; n; i += 2) cout &lt;&lt; a[i] &lt;&lt; ' '; for (int i = n &amp; 1 ? n - 2 : n - 1; i != 1; i -= 2) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; a[1] &lt;&lt; endl;&#125; D. Gourmet choice题目大意由$~n+m~$个菜品，给出一个$~n\\times m~$的矩阵表示相应的比较关系。输出根据这个矩阵的打分方式，满足矩阵的比较关系，且不同的分数数量最小。有可能输出不存在。数据范围$~1\\leq n,m\\leq1000~$。 题解拓扑排序。建图时需要注意如果$~a&gt;b~$且$~b=c~$，则需要增加$~a&gt;c~$。可以用$~\\text{DSU}~$并查集和$~\\text{bitset}~$来维护相等的联通块，这样建图的时间复杂度上限为$~O(\\frac{(n+m)^3\\log n+m}{\\text{bitset}})~$（不写按秩合并）。应该还有更优的建图方式，但上述做法能过，总时间复杂度为$~O(\\frac{(n+m)^3\\log n+m}{\\text{bitset}}+(n+m)^2)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 11;int n, m, deg[maxn], fa[maxn], res[maxn];bitset&lt;maxn&gt; mat[maxn], adj[maxn];vector&lt;int&gt; toward[maxn];vector&lt;vector&lt;int&gt;&gt; topo;int find(int x) &#123; return x == fa[x] ? x : (fa[x] = find(fa[x])); &#125;inline void merge(int x, int y) &#123; x = find(x); y = find(y); mat[fa[y] = x] |= mat[y];&#125;void topo_sort() &#123; vector&lt;int&gt; now; for (int i = 0; i != n + m; ++i) &#123; for (int j = 0; j != n + m; ++j) if (adj[i][j]) adj[i] |= mat[find(j)]; for (int j = 0; j != n + m; ++j) if (adj[i][j]) ++deg[j]; &#125; for (int i = 0; i != n + m; ++i) if (!deg[i]) now.push_back(i); int cnt = 0; while (!now.empty()) &#123; cnt += now.size(); topo.push_back(now); vector&lt;int&gt; tmp; for (const auto&amp; i : now) for (int j = 0; j != n + m; ++j) if (adj[i][j]) if (!--deg[j]) tmp.push_back(j); now = tmp; &#125; if (cnt != n + m) exit((cout &lt;&lt; \"No\" &lt;&lt; endl, 0));&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i != n + m; ++i) mat[fa[i] = i].set(i); for (int i = 0; i != n; ++i) for (int j = n; j != n + m; ++j) &#123; char ch; cin &gt;&gt; ch; if (ch == '&lt;') adj[j].set(i); if (ch == '&gt;') adj[i].set(j); if (ch == '=') merge(i, j); &#125; topo_sort(); for (int i = 0; i != (int)topo.size(); ++i) for (const auto&amp; j : topo[i]) res[j] = topo.size() - i; cout &lt;&lt; \"Yes\" &lt;&lt; endl; for (int i = 0; i != n; ++i) cout &lt;&lt; res[i] &lt;&lt; ' '; cout &lt;&lt; endl; for (int i = 0; i != m; ++i) cout &lt;&lt; res[i + n] &lt;&lt; ' '; cout &lt;&lt; endl;&#125; E. String Multiplication题目大意对于给定字符串$~s=\\overline{s_1s_2\\dots s_n}~$和$~t=\\overline{t_1t_2\\dots t_m}~$，定义$~s+t=\\overline{s_1s_2\\dots s_nt_1t_2\\dots t_m}~$和$~s\\cdot t=t+s_1+t+s_2+t+\\dots+t+s_n+t~$。现给定字符串序列$~p_1,p_2,\\dots,p_n~$，问$~(((p_1\\cdot p_2)\\cdot p3)\\cdot\\dots)\\cdot p_n~$中最长的连续相同子序列长度。数据范围$~\\sum{\\mid p\\mid}\\leq100000~$。 题解不难发现$~\\cdot~$运算满足结合律，那么等价于询问$~p_1\\cdot(p_2\\cdot(\\dots\\cdot p_n))~$。直接线性模拟即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; stack&lt;string&gt; strs; while (n--) &#123; string str; cin &gt;&gt; str; strs.push(str); &#125; string now = strs.top(); strs.pop(); int cal1 = 0, cal2 = 0, res = 0, cnt = 0; char ch1 = now.front(), ch2 = now.back(), last = '$'; for (int i = 0; i != (int)now.size(); ++i) &#123; if (now[i] == ch1) ++cal1; else break; &#125; for (int i = now.size() - 1; ~i; --i) &#123; if (now[i] == ch2) ++cal2; else break; &#125; for (const auto&amp; ch : now) &#123; if (ch != last) cnt = 0; res = max(res, ++cnt); last = ch; &#125; bool check = res == (int)now.size(); while (!strs.empty()) &#123; now = strs.top(); strs.pop(); if (check) &#123; int tmp1 = 0, tmp2 = 0, tmp = 0; for (int i = 0; i != (int)now.size(); ++i) &#123; if (now[i] == ch1) ++tmp1; else break; &#125; cal1 = tmp1 + (tmp1 + 1) * res; for (int i = now.size() - 1; ~i; --i) &#123; if (now[i] == ch1) ++tmp2; else break; &#125; cal2 = tmp2 + (tmp2 + 1) * res; cnt = 0; for (const auto&amp; ch : now) &#123; if (ch != ch1) cnt = 0; else tmp = max(tmp, ++cnt); &#125; res = max(res, tmp + (tmp + 1) * res); check = tmp == (int)now.size(); &#125; else if (ch1 == ch2) &#123; if (~now.find(ch1)) res = max(res, cal1 + cal2 + 1); &#125; else &#123; if (~now.find(ch1)) res = max(res, cal1 + 1); if (~now.find(ch2)) res = max(res, cal2 + 1); &#125; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; F. Asya And Kittens给定正整数$~n~$和$~n-1~$对$~x\\not=y~$，满足$~1\\leq x,y\\leq n~$。需要找到一个全排列，初始每项均属于单独的区间。然后按顺序考虑$~(x,y)~$，$x~$所在的区间必须与$~y~$所在的区间相邻，然后将这两个区间合并，最终整个全排列均在一个区间之内。数据范围$~2\\leq n\\leq150000~$。 题解裸并查集。不写按秩合并的时间复杂度上限为$~O(n\\log n)~$。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 150001;int fa[maxn];vector&lt;int&gt; sons[maxn];int find(int x) &#123; return x == fa[x] ? x : (fa[x] = find(fa[x])); &#125;inline void merge(int x, int y) &#123; x = find(x); y = find(y); sons[fa[y] = x].push_back(y);&#125;void dfs(int u) &#123; cout &lt;&lt; u &lt;&lt; ' '; for (auto&amp; v : sons[u]) dfs(v);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) fa[i] = i; while (--n) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y); &#125; dfs(find(1)); cout &lt;&lt; endl;&#125; G. Most Dangerous Shark题目大意给出$~m~$个多米诺骨牌的给高度$~a~$和花费$~c~$。问将所有多米诺骨牌推倒的最小总花费。数据范围$~1\\leq m\\leq10^7,~1\\leq a\\leq m,~1\\leq c\\leq100000~$。 题解用$~left_i~$表示将$~i~$向左推，恰好推倒至$~left_i~$。那么不难发现所有的区间$~I_i=[left_i,i]~$均互相包含或者不交，所以可以通过栈结构来线性求出。同理用$~right_i~$表示将$~i~$向右推，恰好推倒至$~right_i~$。接下来动态规划，用$~dp_i~$表示将前$~i~$个都推倒的最小花费，则有转移式 dp_i=\\min\\lbrace dp_j+c_i:left_i\\leq j< i\\rbrace\\cup\\lbrace dp_{j-1}+c_j:j< i\\leq right_j\\rbrace整个过程均可用栈维护，总时间复杂度为$~O(m)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;pair&lt;int, long long&gt;&gt;&gt; blocks(n); vector&lt;int&gt; a(m + 1), left(m + 1), right(m + 1); vector&lt;long long&gt; c(m + 1), dp(m + 1), minn(m + 1); for (auto&amp; block : blocks) &#123; int k; cin &gt;&gt; k; block.resize(k); for (auto&amp; domi : block) cin &gt;&gt; domi.first; for (auto&amp; domi : block) cin &gt;&gt; domi.second; &#125; int q, index = 0; cin &gt;&gt; q; while (q--) &#123; int id, mul; cin &gt;&gt; id &gt;&gt; mul; for (auto&amp; domi : blocks[id - 1]) &#123; ++index; a[index] = domi.first; c[index] = domi.second * mul; &#125; &#125; stack&lt;int&gt; sta1; for (int i = m; i; --i) &#123; for (right[i] = min(m, i + a[i] - 1); !sta1.empty() &amp;&amp; right[i] &gt;= sta1.top(); sta1.pop()) right[i] = max(right[i], right[sta1.top()]); sta1.push(i); &#125; while (!sta1.empty()) sta1.pop(); dp.front() = 0; stack&lt;pair&lt;int, long long&gt;&gt; sta2; for (int i = 1; i &lt;= m; ++i) &#123; minn[i] = dp[left[i] = max(0, i - a[i])]; for (left[i] = max(0, i - a[i]); !sta1.empty() &amp;&amp; left[i] &lt; sta1.top(); sta1.pop()) &#123; left[i] = min(left[i], left[sta1.top()]); minn[i] = min(minn[i], minn[sta1.top()]); &#125; dp[i] = minn[i] + c[i]; while (!sta2.empty() &amp;&amp; i &gt; right[sta2.top().first]) sta2.pop(); if (sta2.empty()) &#123; sta2.push(make_pair(right[i], dp[i - 1] + c[i])); &#125; else &#123; dp[i] = min(dp[i], sta2.top().second); sta2.push(make_pair(right[i], min(sta2.top().second, dp[i - 1] + c[i]))); &#125; minn[i] = min(minn[i], dp[i]); sta1.push(i); &#125; cout &lt;&lt; dp.back() &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Educational Codeforces Round 61 (Rated for Div. 2)","slug":"Educational Codeforces Round 61 (Rated for Div. 2)","date":"2019-03-10T04:00:44.878Z","updated":"2019-03-10T04:07:59.844Z","comments":true,"path":"2019/03/10/Educational Codeforces Round 61 (Rated for Div. 2)/","link":"","permalink":"http://yoursite.com/2019/03/10/Educational Codeforces Round 61 (Rated for Div. 2)/","excerpt":"","text":"Educational Codeforces Round 61 (Rated for Div. 2) A. Regular Bracket Sequence题目大意现有$~cnt_1~$个$~\\text{((}~$，$cnt_2~$个$~\\text{()}~$，$~cnt_3~$个$~\\text{)(}~$，$~cnt_4~$个$~\\text{))}~$。问能否组合成一个合法括号串。 题解判断$~cnt_1=cnt_4~$，且$~cnt_1&gt;0~$或$~cnt_3=0~$ 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int cnt[4]; for (int i = 0; i != 4; ++i) cin &gt;&gt; cnt[i]; cout &lt;&lt; (cnt[0] == cnt[3] &amp;&amp; (cnt[0] &amp;&amp; !cnt[2])) &lt;&lt; endl;&#125; B. Discounts题目大意水题。 题解水题。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;long long&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; sort(a.begin(), a.end()); long long sum = accumulate(a.begin(), a.end(), 0LL); int m; cin &gt;&gt; m; while (m--) &#123; int q; cin &gt;&gt; q; cout &lt;&lt; sum - a[n - q] &lt;&lt; endl; &#125;&#125; C. Painting the Fence题目大意给定$~n~$以内$~q~$个离散区间，问$~q-2~$个区间的并集最多包含多少个整点。数据范围$~3\\leq n,q\\leq5000~$。 题解考虑$~q-1~$的做法。对于数轴$~1,2,\\dots,n~$上差分，则得到所包含于区间数量的差分数组。同时把每个区间放入其右端点的$~\\text{vector}~$之中。从小到大枚举右端点，则可以知道每个区间中有多少个点的值为$~1~$，代表不取这个区间所减少的答案。整个过程都是线性的，所以时间复杂度为$~O(n+q)~$。那么对于本体，现暴力枚举第一个不选的区间即可，总时间复杂度为$~O(q\\cdot(n+q))~$。 代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, q; cin &gt;&gt; n &gt;&gt; q; vector&lt;int&gt; d(n + 2, 0); vector&lt;pair&lt;int, int&gt;&gt; seg(q); vector&lt;vector&lt;int&gt;&gt; line(n + 1); for (int i = 0; i != q; ++i) &#123; cin &gt;&gt; seg[i].first &gt;&gt; seg[i].second; ++d[seg[i].first]; --d[++seg[i].second]; line[seg[i].second - 1].push_back(i); &#125; int res = 0; for (int i = 0; i != q; ++i) &#123; vector&lt;int&gt; dd(d), sweep(n + 1, 0); --dd[seg[i].first]; ++dd[seg[i].second]; int sub = 0x3f3f3f3f, cal = 0; for (int j = 1; j &lt;= n; ++j) &#123; sweep[j] = sweep[j - 1]; if ((dd[j] += dd[j - 1]) == 1) ++sweep[j]; if (dd[j]) ++cal; for (auto&amp; k : line[j]) if (i != k) sub = min(sub, sweep[seg[k].second - 1] - sweep[seg[k].first - 1]); &#125; res = max(res, cal - sub); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. Stressful Training题目大意有$~n~$台电脑，给出初始电量$~a~$和每分钟耗电$~b~$。总共$~k~$分钟，现有$~1~$个充电器，每分钟只能给$~1~$台电脑充电。问使得在最后一刻之前没有电脑没电（为负）的最小功率或者不存在。数据范围$~1\\leq n,k\\leq2\\cdot10^5,~1\\leq a\\leq10^{17},~1\\leq b\\leq10^{12}~$。 题解二分答案，然后判断是否合法。使用优先队列的话总时间复杂度为$~O(k\\log n\\log\\max)~$，很难通过。对于每台电脑，将其放入没电的时刻所对应的$~\\text{vector}~$之中，模拟这$~k~$分钟即可。这样总时间复杂度为$~O((n+k)\\log\\max)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const long long INF = 0x3f3f3f3f3f3f3f3f;int n, k;long long x;vector&lt;pair&lt;long long, long long&gt;&gt; ab;vector&lt;vector&lt;pair&lt;long long, long long&gt;&gt;&gt; line;bool check() &#123; for (auto&amp; time : line) time.clear(); for (auto&amp; laptop : ab) if (laptop.first / laptop.second &lt; k) line[laptop.first / laptop.second].push_back(laptop); int cnt = 0; int fuck = 0; for (auto&amp; time : line) &#123; ++cnt; for (auto&amp; laptop : time) &#123; long long temp = ((laptop.first / laptop.second + 1) * laptop.second - laptop.first - 1) / x + 1; if ((cnt -= temp) &lt; 0) return false; if ((laptop.first + temp * x) / laptop.second &lt; k) line[(laptop.first + temp * x) / laptop.second].push_back(make_pair(laptop.first + temp * x, laptop.second)); &#125; &#125; return true;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; k; ab.resize(n); line.resize(--k); for (auto&amp; in : ab) cin &gt;&gt; in.first; for (auto&amp; in : ab) cin &gt;&gt; in.second; bool flag = true; for (auto&amp; laptop : ab) if (laptop.first &lt; laptop.second * k) flag = false; if (flag) return cout &lt;&lt; 0 &lt;&lt; endl, 0; long long left = 0, right = INF; while (right - left != 1) &#123; x = (left + right) &gt;&gt; 1; if (check()) right = x; else left = x; &#125; cout &lt;&lt; (right == INF ? -1 : right) &lt;&lt; endl;&#125; E. Knapsack题目大意数字$~1\\leq i\\leq8~$有$~cnt_i~$个。问组成的和在不超过$~W~$下的最大值。 题解考虑$~S=\\gcd(1,2,\\dots,8)=840~$。对于数字$~i~$，取$~\\frac{S}{i}~$个求和能得到$~S~$。动态规划，记$~dp[i][j]~$为已经考虑了前$~i~$个数字，每个数字至多取$~\\min(\\frac{S}{i},cnt_i)~$个，未取过的数字还能凑出多少$~S~$。这样空间复杂度为$~O(8^2\\cdot840)~$，时间复杂度为$~O(8\\cdot\\log8\\cdot840^2)~$。 代码12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const int maxn = 8; const int gcd = 840; long long w, cnt, res = 0; vector&lt;vector&lt;long long&gt;&gt; dp(maxn + 1, vector&lt;long long&gt;(maxn * gcd + 1, -1)); dp.front().front() = 0; cin &gt;&gt; w; for (int i = 1; i &lt;= maxn; ++i) &#123; cin &gt;&gt; cnt; for (int j = 0; j &lt;= gcd / i &amp;&amp; j &lt;= cnt; ++j) for (int k = i * j; k &lt;= maxn * gcd; ++k) if (~dp[i - 1][k - i * j]) dp[i][k] = max(dp[i][k], dp[i - 1][k - i * j] + (cnt - j) / (gcd / i)); &#125; for (int i = 0; i &lt;= maxn * gcd &amp;&amp; i &lt;= w; ++i) if (~dp.back()[i]) res = max(res, i + gcd * min(dp.back()[i], (w - i) / gcd)); cout &lt;&lt; res &lt;&lt; endl;&#125; F. Clear the String题目大意给定一个小写字母串，每次可以消除连续的相同子串，问最小消除次数。数据范围$~1\\leq n\\leq500~$。 题解相邻去重后就是一个区间$~\\text{DP}~$问题。具体见代码，时间复杂度为$~O(n^3)~$。 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;string str;int dp[500][500];int calc(int l, int r) &#123; if (~dp[l][r]) return dp[l][r]; if (l &gt; r) return dp[l][r] = 0; dp[l][r] = calc(l + 1, r) + 1; for (int i = l + 1; i &lt; r; ++i) if (str[l] == str[i]) dp[l][r] = min(dp[l][r], calc(l + 1, i - 1) + calc(i, r)); if (str[l] == str[r]) dp[l][r] = min(dp[l][r], calc(l + 1, r - 1) + 1); return dp[l][r];&#125;int main() &#123; int n; cin &gt;&gt; n &gt;&gt; str; str = string(str.begin(), unique(str.begin(), str.end())); memset(dp, -1, sizeof (dp)); cout &lt;&lt; calc(0, str.size() - 1) &lt;&lt; endl;&#125; G. Greedy Subsequences题目大意给定一个序列$~a_1,a_2,\\dots,a_n~$，定义贪心子序列满足除首项外，每一项均为原序列中右边第一个大于前一项的值。给定$~k~$，输出区间$~[1,k],~[2,k+1],~\\dots,~[n-k+1,n]~$的最长贪心子序列长度。数据范围$~1\\leq k\\leq n\\leq10^6,~1\\leq a\\leq n~$。 题解记$~f(r)=\\max\\lbrace l:a_r\\geq a_l,~l&lt; r\\rbrace~$，其中不妨设$~a_0=\\inf~$。这一步可以通过单调栈线性求出。再令$~g(l,r)~$表示首相为$~a_l~$，右边不超过$~r~$的最长贪心子序列长度。则有转移式 g(l,r)=\\begin{cases} g(l,r-1) &\\text{$l\\leq f(r)$} \\\\ g(l,r-1)+1 &\\text{$l>f(r)$} \\end{cases}且区间$~[r-k+1,r]~$的答案为$~\\max_{l=r-k+1}^{r}{g(l,r)}~$。用线段树维护即可，总时间复杂度为$~O(n\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 20;int a[maxn], seg[maxn &lt;&lt; 1], tag[maxn &lt;&lt; 1];#define mid ((begin + end) &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (index &lt;&lt; 1 ^ 1)#define LEFT begin, mid, lson#define RIGHT mid, end, rson#define SEG left, rightvoid push_down(int index) &#123; seg[index] += tag[index]; if (index &lt; maxn) &#123; tag[lson] += tag[index]; tag[rson] += tag[index]; &#125; tag[index] = 0;&#125;void modify(int begin, int end, int index, int left, int right) &#123; push_down(index); if (begin &gt;= left &amp;&amp; end &lt;= right) &#123; ++tag[index]; return; &#125; if (left &lt; mid) modify(LEFT, SEG); if (right &gt; mid) modify(RIGHT, SEG); seg[index] = max(seg[lson] + tag[lson], seg[rson] + tag[rson]);&#125;int query(int begin, int end, int index, int left, int right) &#123; push_down(index); if (begin &gt;= left &amp;&amp; end &lt;= right) return seg[index]; if (begin &gt;= right || end &lt;= left) return 0; return max(query(LEFT, SEG), query(RIGHT, SEG));&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin &gt;&gt; n &gt;&gt; k; a[0] = 1 &lt;&lt; 20; stack&lt;int&gt; sta; sta.push(0); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; while (a[sta.top()] &lt; a[i]) sta.pop(); modify(0, n, 1, sta.top(), i); sta.push(i); if (i &gt;= k) cout &lt;&lt; query(0, n, 1, i - k, i) &lt;&lt; ' '; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"2014-2015 ACM-ICPC, NEERC, Northern Subregional Contest (TBC)","slug":"2014-2015 ACM-ICPC, NEERC, Northern Subregional Contest (TBC)","date":"2019-03-10T04:00:44.878Z","updated":"2019-03-13T13:21:24.455Z","comments":true,"path":"2019/03/10/2014-2015 ACM-ICPC, NEERC, Northern Subregional Contest (TBC)/","link":"","permalink":"http://yoursite.com/2019/03/10/2014-2015 ACM-ICPC, NEERC, Northern Subregional Contest (TBC)/","excerpt":"","text":"2014-2015 ACM-ICPC, NEERC, Northern Subregional Contest A. Alarm Clock题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen(\"alarm.in\", \"r\", stdin); freopen(\"alarm.out\", \"w\", stdout); map&lt;int, pair&lt;int, int&gt;&gt; res; const int d[] = &#123;6, 2, 5, 5, 4, 5, 6, 3, 7, 6&#125;; for (int i = 0; i != 24; ++i) for (int j = 0; j != 60; ++j) res[d[i % 10] + d[i / 10] + d[j % 10] + d[j / 10]] = make_pair(i, j); int n; scanf(\"%d\", &amp;n); auto ite = res.find(n); if (ite == res.end()) puts(\"Impossible\"); else printf(\"%02d:%02d\\n\", ite-&gt;second.first, ite-&gt;second.second);&#125; B. Buffcraft题目大意水题。 题解水题。有坑。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen(\"buffcraft.in\", \"r\", stdin); freopen(\"buffcraft.out\", \"w\", stdout); int b, k, cd, cp; cin &gt;&gt; b &gt;&gt; k &gt;&gt; cd &gt;&gt; cp; vector&lt;pair&lt;long long, int&gt;&gt; d(cd + 1), p(cp + 1); d.front() = p.front() = make_pair(0, 0); for (int i = 1; i &lt;= cd; ++i) cin &gt;&gt; d[i].first, d[i].second = i; for (int i = 1; i &lt;= cp; ++i) cin &gt;&gt; p[i].first, p[i].second = i; sort(d.begin() + 1, d.end(), greater&lt;pair&lt;long long, int&gt;&gt;()); sort(p.begin() + 1, p.end(), greater&lt;pair&lt;long long, int&gt;&gt;()); vector&lt;long long&gt; dd(cd + 1, 0), pp(cp + 1, 0); for (int i = 1; i &lt;= cd; ++i) dd[i] = dd[i - 1] + d[i].first; for (int i = 1; i &lt;= cp; ++i) pp[i] = pp[i - 1] + p[i].first; int n = 0, m = 0; long long cal = 0; for (int i = 0; i &lt;= min(k, cd); ++i) &#123; long long temp = (b + dd[i]) * (pp[min(cp, k - i)] + 100); if (cal &lt; temp) &#123; cal = temp; n = i; m = min(cp, k - i); &#125; &#125; cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; m &lt;&lt; endl; for (int i = 1; i &lt; n; ++i) cout &lt;&lt; d[i].second &lt;&lt; ' '; if (n) cout &lt;&lt; d[n].second; cout &lt;&lt; endl; for (int i = 1; i &lt; m; ++i) cout &lt;&lt; p[i].second &lt;&lt; ' '; if (m) cout &lt;&lt; p[m].second; cout &lt;&lt; endl;&#125; D. Digits题目大意输出最小的$~n~$个不同正整数的和，满足这些数的各位数之和相等。数据范围$~1\\leq n\\leq5000~$。 题解注意到数据范围较小，考虑爆搜。爆搜$~10^7~$以内的正整数更新数据范围内对应的答案即可。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen(\"digits.in\", \"r\", stdin); freopen(\"digits.out\", \"w\", stdout); vector&lt;long long&gt; res(5001, 0x3f3f3f3f3f3f3f3f), cal(64, 0); vector&lt;int&gt; cnt(64, 0); for (int i = 1; i &lt;= 10000000; ++i) &#123; int sum = 0; for (int j = i; j; j /= 10) sum += j % 10; if (++cnt[sum] &lt;= 5000) res[cnt[sum]] = min(res[cnt[sum]], cal[sum] += i); &#125; int n; cin &gt;&gt; n; cout &lt;&lt; res[n] &lt;&lt; endl;&#125; G. Grave题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen(\"grave.in\", \"r\", stdin); freopen(\"grave.out\", \"w\", stdout); int x[4], y[4], w, h; for (int i = 0; i != 4; ++i) cin &gt;&gt; x[i] &gt;&gt; y[i]; cin &gt;&gt; w &gt;&gt; h; bool flag = false; if (x[2] - x[0] &gt;= w &amp;&amp; y[1] - y[0] &gt;= h) flag = true; if (x[1] - x[3] &gt;= w &amp;&amp; y[1] - y[0] &gt;= h) flag = true; if (x[1] - x[0] &gt;= w &amp;&amp; y[2] - y[0] &gt;= h) flag = true; if (x[1] - x[0] &gt;= w &amp;&amp; y[1] - y[3] &gt;= h) flag = true; cout &lt;&lt; (flag ? \"Yes\" : \"No\") &lt;&lt; endl;&#125; H. Hiking in the Hills题目大意给定一个三维空间下的地形图，表面由$~n~$个三角形拼接而成。然后给定平面上的起点和终点，输出一条路径，使得路径的海拔的最大值最小。数据范围$~2\\leq n\\leq2000~$。 题解对偶图的单源最短路问题。将三角形视为点，任意相接触的两三角形的公共边或公共点是为边，那么边权则是公共部分的最低海拔。暴力建图即可，时间复杂度为$~O(n^2)~$，单元最短路用$~\\text{Dijstra}~$算法，是否堆优化均不影响时间复杂度。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Point &#123; ll x, y, z; Point() &#123;&#125; Point(ll xx, ll yy, ll zz): x(xx), y(yy), z(zz) &#123;&#125; void input() &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; &#125; void output() &#123; cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ' &lt;&lt; z &lt;&lt; '\\n'; &#125; bool operator == (const Point&amp; p) const &#123; return x == p.x &amp;&amp; y == p.y; &#125; Point operator - (const Point&amp; p) const &#123; return Point(x - p.x, y - p.y, 0); &#125; ll operator ^ (const Point&amp; p) const &#123; return x * p.y - y * p.x; &#125;&#125;;inline Point lower(const Point&amp; p1, const Point&amp; p2) &#123; return p1.z &lt; p2.z ? p1 : p2; &#125;struct Triagnle &#123; Point p[3]; Triagnle() &#123;&#125; Triagnle(Point a, Point b, Point c) &#123; p[0] = a, p[1] = b, p[2] = c; &#125; Triagnle(Point pp[]) &#123; for (int i = 0; i != 3; ++i) p[i] = pp[i]; &#125; void input() &#123; for (int i = 0; i != 3; ++i) p[i].input(); &#125; ll area() &#123; return abs((p[1] - p[0]) ^ (p[2] - p[0])); &#125; bool have(Point&amp; pp) &#123; ll cal = 0; for (int i = 0; i != 3; ++i) cal += abs((p[i] - pp) ^ (p[(i + 1) % 3] - pp)); return cal == area(); &#125;&#125;;inline vector&lt;Point&gt; operator &amp; (const Triagnle&amp; t1, const Triagnle&amp; t2) &#123; vector&lt;Point&gt; ret; for (int i = 0; i != 3; ++i) for (int j = 0; j != 3; ++j) if (t1.p[i] == t2.p[j]) ret.push_back(t1.p[i]); return ret;&#125;#define ff first#define ss second#define mp make_pairstruct Node &#123; Point p; int id, from; ll h; Node() &#123;&#125; Node(Point pp, int i, int f, ll hh): p(pp), id(i), from(f), h(hh) &#123;&#125; bool operator &lt; (const Node&amp; n) const &#123; return h &gt; n.h; &#125;&#125;;int main() &#123; freopen(\"hiking.in\", \"r\", stdin); freopen(\"hiking.out\", \"w\", stdout); int n; cin &gt;&gt; n; vector&lt;Triagnle&gt; planes(n); for (auto&amp; plane : planes) plane.input(); vector&lt;vector&lt;pair&lt;int, Point&gt;&gt;&gt; adj(n); for (int i = 0; i != n; ++i) for (int j = i + 1; j != n; ++j) &#123; auto tmp = planes[i] &amp; planes[j]; if (tmp.size()) &#123; if (tmp.size() == 1) &#123; adj[i].push_back(mp(j, tmp.front())); adj[j].push_back(mp(i, tmp.front())); &#125; else &#123; auto p = lower(tmp.front(), tmp.back()); adj[i].push_back(mp(j, p)); adj[j].push_back(mp(i, p)); &#125; &#125; &#125; Point start, finish; start.input(); finish.input(); int begin, end; for (int i = 0; i != n; ++i) if (planes[i].have(start)) &#123; begin = i; break; &#125; for (int i = 0; i != n; ++i) if (planes[i].have(finish)) &#123; end = i; break; &#125; priority_queue&lt;Node&gt; que; que.push(Node(start, begin, begin, start.z)); vector&lt;bool&gt; vis(n, false); vector&lt;int&gt; from(n); vector&lt;Point&gt; nodes(n); while (!que.empty()) &#123; auto now = que.top(); que.pop(); if (vis[now.id]) continue; vis[now.id] = true; from[now.id] = now.from; nodes[now.id] = now.p; for (auto&amp; next : adj[now.id]) if (!vis[next.ff]) que.push(Node(next.ss, next.ff, now.id, max(now.h, next.ss.z))); &#125; vector&lt;Point&gt; res(1, finish); while (true) &#123; res.push_back(nodes[end]); if (end == begin) break; end = from[end]; &#125; reverse(res.begin(), res.end()); cout &lt;&lt; res.size() &lt;&lt; '\\n'; for (auto&amp; ans : res) ans.output();&#125; I. Instruction题目大意铁路轨道视为一棵$~n~$个节点的二叉树，起点为根节点，终点为叶节点。然后给定$~m~$列火车的出发时刻$~t~$和终点$~p~$。每个非叶节点的初始指向为编号较小的子节点。为使得每辆火车均到达相应终点，那么需要在一些时刻修改一些非叶节点的指向。输出一种不超过$~100000~$次的修改方案。数据范围$~3\\leq n\\leq51,~1\\leq m\\leq100,~0\\leq t\\leq10000,~1\\leq p\\leq26~$。 题解模拟。对于每辆火车，考虑它从起点到终点的过程，则可以得到这条路径上的非叶节点在某些时刻需要满足的状态（指向哪个子节点）。最终对于每个节点，所有的状态按时间升序然后去重即可。总时间复杂度为$~O(nm\\log m)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;#define ff first#define ss second#define mp make_pairint main() &#123; freopen(\"instruction.in\", \"r\", stdin); freopen(\"instruction.out\", \"w\", stdout); int n; cin &gt;&gt; n; int p[128], fa[64], son[64][2], tmp[64] = &#123;0&#125;, to[64][64], go[64][64], state[64] = &#123;0&#125;, check[64] = &#123;0&#125;; for (int i = 1; i &lt;= n; ++i) &#123; char ch; int f; cin &gt;&gt; ch &gt;&gt; f; fa[i] = f; to[f][i] = tmp[f]; son[f][tmp[f]++] = i; if (ch == 'p') &#123; char name; cin &gt;&gt; name; p[name] = i; for (int j = i; j; j = fa[j]) go[fa[j]][i] = to[fa[j]][j]; &#125; else &#123; check[i] = 1; &#125; &#125; vector&lt;pii&gt; node[64], res; int m; cin &gt;&gt; m; while (m--) &#123; int t; char ch; cin &gt;&gt; t &gt;&gt; ch; int id = p[ch]; for (int i = 0; i != id; i = son[i][go[i][id]]) node[i].push_back(mp(t++, go[i][id])); &#125; for (int i = 1; i &lt;= n; ++i) if (check[i]) &#123; sort(node[i].begin(), node[i].end()); int now = 0; for (auto fuck : node[i]) if (now != fuck.ss) &#123; now = fuck.ss; res.push_back(mp(fuck.ff, i)); &#125; &#125; sort(res.begin(), res.end()); cout &lt;&lt; res.size() &lt;&lt; '\\n'; for (auto ans : res) cout &lt;&lt; ans.ss &lt;&lt; ' ' &lt;&lt; ans.ff &lt;&lt; '\\n';&#125; J. Joy of Flight题目大意给定起点和终点坐标，飞机需要恰好在第$~k~$秒到达终点，同时给出这期间的风向变化和飞机的最大速度$~v_\\max~$，每秒飞机的真实位移等于飞机速度向量于风速向量之和。输出每秒飞机所到达的坐标或者不存在到达终点的方案。 题解分离风速与自身速度。那么方案存在等价于起点经过$~k~$秒的风吹所到达的坐标与终点的距离$~dis~$小于等于$~k\\cdot v_\\max~$。那么每秒的飞机速度即为$~\\frac{dis}{k}~$。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;long long, long long&gt; pll;#define ff first#define ss second#define mp make_pairint main() &#123; freopen(\"joy.in\", \"r\", stdin); freopen(\"joy.out\", \"w\", stdout); pll begin, end; scanf(\"%lld%lld%lld%lld\", &amp;begin.ff, &amp;begin.ss, &amp;end.ff, &amp;end.ss); int n, k; long long vmax; scanf(\"%d%d%lld\", &amp;n, &amp;k, &amp;vmax); vector&lt;pair&lt;int, pll&gt;&gt; input(n); vector&lt;pll&gt; winds(k); for (int i = 0; i != n; ++i) &#123; scanf(\"%d%lld%lld\", &amp;input[i].ff, &amp;input[i].ss.ff, &amp;input[i].ss.ss); for (int j = input[i - 1].ff; i &amp;&amp; j != input[i].ff; ++j) winds[j] = input[i - 1].ss; &#125; for (int i = input.back().ff; i != k; ++i) winds[i] = input.back().ss; pll flow = mp(end.ff - begin.ff, end.ss - begin.ss); for (auto&amp; wind : winds) flow = mp(flow.ff - wind.ff, flow.ss - wind.ss); if (flow.ff * flow.ff + flow.ss * flow.ss &gt; vmax * vmax * k * k) return puts(\"No\"), 0; puts(\"Yes\"); pll temp = begin; int day = 0; for (auto&amp; wind : winds) &#123; ++day; temp = mp(temp.ff + wind.ff, temp.ss + wind.ss); printf(\"%f %f\\n\", temp.ff + (double)flow.ff * day / k, temp.ss + (double)flow.ss * day / k); &#125;&#125; K. Kebab House题目大意数轴上从$~1~$开始有$~n~$个相连的线段区间，并给出每个区间的长度$~q~$。现要在所有线段内合法的取若干个点，满足相邻的两个点之间所未取到的点的数量至少为$~t~$，每个线段内最多取$~q-x~$个点。问合法的方案数（包括不取）。数据范围$~1\\leq n\\leq1000,~0\\leq t\\leq100,~0\\leq q\\leq250,~0\\leq x\\leq q~$。 题解动态规划。问$~\\text{WSY}~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using ul = std::uint32_t;using li = std::int32_t;using ll = std::int64_t;using ull = std::uint64_t;const ul base = 1e9 + 7;ul plus(ul a, ul b)&#123; return a + b &lt; base ? a + b : a + b - base;&#125;ul minus(ul a, ul b)&#123; return a &lt; b ? a + base - b : a - b;&#125;ul mul(ul a, ul b)&#123; return ull(a) * ull(b) % ull(base);&#125;//#define TEST#ifdef TESTstd::istream&amp; myis = std::cin;std::ostream&amp; myos = std::cout;#endif#ifndef TESTstd::ifstream myis(\"kebab.in\");std::ofstream myos(\"kebab.out\");#endiful m, n, t;ul segst[250001];ul segable[250001];ul sum[250001];ul ans[250001][251];ul finalans = 1;int main()&#123; std::ios::sync_with_stdio(false); myis.tie(0); myis &gt;&gt; m &gt;&gt; t; for (ul i = 0, st = 1; i != m; ++i) &#123; ul q, x; myis &gt;&gt; q &gt;&gt; x; for (ul j = st; j != st + q; ++j) &#123; segst[j] = st; segable[j] = q - x; &#125; st = st + q; n = st - 1; &#125; sum[0] = 1; for (ul i = 1; i &lt;= n; ++i) &#123; sum[i] = sum[i - 1]; for (ul j = 1; j &lt;= segable[i]; ++j) &#123; if (j == 1) &#123; if (i &gt;= t + 1) &#123; ans[i][j] = sum[std::min(i - t - 1, segst[i] - 1)]; &#125; else &#123; ans[i][j] = 1; &#125; &#125; else &#123; if (i &gt;= t + 1 &amp;&amp; i - t - 1 &gt;= segst[i] + j - 2) &#123; ans[i][j] = minus(ans[i - t - 1][j - 1], segst[i] + j - 2 &gt;= 1 ? ans[segst[i] + j - 3][j - 1] : ul(0)); &#125; &#125; sum[i] = plus(sum[i], ans[i][j]); finalans = plus(finalans, ans[i][j]); ans[i][j] = plus(ans[i - 1][j], ans[i][j]); &#125; &#125; myos &lt;&lt; finalans &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[]},{"title":"EOJ Monthly 2019.2 (based on February Selection)","slug":"EOJ Monthly 2019.2 (based on February Selection)","date":"2019-02-25T09:29:22.057Z","updated":"2019-02-27T09:08:35.860Z","comments":true,"path":"2019/02/25/EOJ Monthly 2019.2 (based on February Selection)/","link":"","permalink":"http://yoursite.com/2019/02/25/EOJ Monthly 2019.2 (based on February Selection)/","excerpt":"","text":"EOJ Monthly 2019.2 (based on February Selection) A. 回收卫星题目大意交互题。有一个球心为$~(x,~y,~z)~$半径为$~r~$的球，且原点$~(0,~0,~0)~$保证在球内部或边界上。每次可以询问一个点是否在球的内部或边界上，需要在至多$~200~$次询问下确定球心坐标。数据范围$~{\\mid x\\mid}\\leq10^9,~{\\mid y\\mid}\\leq10^9,~{\\mid z\\mid}\\leq10^9,~1\\leq r\\leq10^9~$。 题解通过二分可以确定$~x_1=\\max\\lbrace x_0\\mid(x-x_0)^2+y^2+z^2\\leq r^2\\rbrace~$和$~x_2=\\min\\lbrace x_0\\mid(x-x_0)^2+y^2+z^2\\leq r^2\\rbrace~$。注意到绝对值最大为$~2\\times10^9~$，二分上界必须大于该数，且会爆$~\\text{int}~$。考虑关于$~x_0~$的一元二次方程 (x-x_0)^2+y^2+z^2=r^2解为 x_0=x\\pm\\sqrt{r^2-y^2-z^2}于是有 x_1=x+\\left\\lfloor\\sqrt{r^2-y^2-z^2}\\right\\rfloor \\\\ x_2=x-\\left\\lfloor\\sqrt{r^2-y^2-z^2}\\right\\rfloor \\\\ x={\\frac{x_1+x_2}{2}}同理可解出$~y~$与$~z~$。次数最多$~6\\times32=192~$次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 2000000001;inline int query(const int&amp; x, const int&amp; y, const int&amp; z) &#123; cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ' &lt;&lt; z &lt;&lt; endl; int ret; cin &gt;&gt; ret; return ret;&#125;int main() &#123; long long left, right, x1, x2, y1, y2, z1, z2; &#123; left = 0, right = INF; while (right - left != 1) &#123; int mid = left + right &gt;&gt; 1; if (query(mid, 0, 0)) left = mid; else right = mid; &#125; x1 = left; &#125; &#123; left = 0, right = INF; while (right - left != 1) &#123; int mid = left + right &gt;&gt; 1; if (query(-mid, 0, 0)) left = mid; else right = mid; &#125; x2 = -left; &#125; &#123; left = 0, right = INF; while (right - left != 1) &#123; int mid = left + right &gt;&gt; 1; if (query(0, mid, 0)) left = mid; else right = mid; &#125; y1 = left; &#125; &#123; left = 0, right = INF; while (right - left != 1) &#123; int mid = left + right &gt;&gt; 1; if (query(0, -mid, 0)) left = mid; else right = mid; &#125; y2 = -left; &#125; &#123; left = 0, right = INF; while (right - left != 1) &#123; int mid = left + right &gt;&gt; 1; if (query(0, 0, mid)) left = mid; else right = mid; &#125; z1 = left; &#125; &#123; left = 0, right = INF; while (right - left != 1) &#123; int mid = left + right &gt;&gt; 1; if (query(0, 0, -mid)) left = mid; else right = mid; &#125; z2 = -left; &#125; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; (x1 + x2 &gt;&gt; 1) &lt;&lt; ' ' &lt;&lt; (y1 + y2 &gt;&gt; 1) &lt;&lt; ' ' &lt;&lt; (z1 + z2 &gt;&gt; 1) &lt;&lt; endl;&#125; B. 解题题目大意给定一个$~n~$位大整数，询问$~q~$次，每次给定一个正整数$~m~$。选取大整数十进制表示下连续的一段保留，其余全变成$~0~$，找出最小的如此生成的正整数满足是$~m~$的倍数，或者不存在。数据范围$~1\\leq n\\leq10^6,~1\\leq q\\leq500,~\\sum m\\leq5\\times10^7~$。 题解记$~a_i~$为大整数后$~i~$位模$~m~$的余数，注意需要添加$~a_0=0~$。取区间$~[l,r]~$生成的数字是$~m~$的倍数，等价于$~a_{n+1-l}=a_{n-r}~$。只要将$~i~$从小到大计算$~a_i~$，对于最小的$~j~$，存在$~i&lt; j~$满足$~a_i=a_j~$，则答案$~[l,r]=[n+1-j,n-i]~$。由抽屉原理，至多计算$~m+1~$次就一定能得出答案。总时间复杂度为$~O(\\sum m)~$。 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); string num; cin &gt;&gt; num; const int n = num.size(); vector&lt;int&gt; dig(n); for (int i = 0; i != n; ++i) dig[i] = num[i] - '0'; int q; cin &gt;&gt; q; while (q--) &#123; int m; cin &gt;&gt; m; vector&lt;int&gt; pos(m, 0); pos[0] = n; bool flag = true; int base = 1, now = 0; for (int i = n - 1; ~i; --i) &#123; now = (now + base * dig[i]) % m; if (pos[now]) &#123; cout &lt;&lt; i + 1 &lt;&lt; ' ' &lt;&lt; pos[now] &lt;&lt; '\\n'; flag = false; break; &#125; pos[now] = i; base = base * 10 % m; &#125; if (flag) cout &lt;&lt; -1 &lt;&lt; '\\n'; &#125;&#125; C. 魔板题目大意有一个$~n\\times m~$个格点的网格图，第$~i~$行第$~j~$列的坐标为$~(i,j)~$。每个点有个数字，有序状态下$~(i,j)~$的数字为$~(i-1)\\times m+j~$。有两种置换方式：选择$~(x&lt; n,~y&lt; m)~$，将$~(x,y),(x+1,y),(x,y+1)~$上的数字顺时针交换；选择$~(x&lt; n,~y&lt; m)~$，将$~(x,y),(x+1,y),(x+1,y+1),(x,y+1)~$上的数字顺时针交换。现给定一个打乱的状态，输出任意一种使其有序的操作方式，且次数不能超过$~3\\cdot10^6~$。数据范围$~2\\leq n,m\\leq100~$。 题解构造大模拟。注意到先进行$~1~$次操作$~2~$再进行$~2~$次操作$~1~$，等价于只交换$~(x+1,y)~$和$~(x+1,y+1)~$。先进行$~2~$次操作$~1~$再进行$~1~$次操作$~2~$，等价于只交换$~(x,y+1)~$和$~(x+1,y+1)~$。那么暴力模拟即可，上限$~3\\cdot10^6~$其实很宽松。 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;#define ff first#define ss second#define mp make_pairpii pos[10001];int mat[101][101], m, n, res_size;pair&lt;int, pii&gt; res[1 &lt;&lt; 22];inline void work1(int x, int y) &#123; int a = mat[x][y], b = mat[x + 1][y], c = mat[x][y + 1]; pos[mat[x + 1][y] = a] = mp(x + 1, y); pos[mat[x][y + 1] = b] = mp(x, y + 1); pos[mat[x][y] = c] = mp(x, y); res[res_size++] = mp(1, mp(x, y));&#125;inline void work2(int x, int y) &#123; int a = mat[x][y], b = mat[x + 1][y], c = mat[x + 1][y + 1], d = mat[x][y + 1]; pos[mat[x + 1][y] = a] = mp(x + 1, y); pos[mat[x + 1][y + 1] = b] = mp(x + 1, y + 1); pos[mat[x][y + 1] = c] = mp(x, y + 1); pos[mat[x][y] = d] = mp(x, y); res[res_size++] = mp(2, mp(x, y));&#125;inline void swap_up(int x, int y) &#123; work2(x, y); work1(x, y); work1(x, y);&#125;inline void swap_right(int x, int y) &#123; work1(x, y); work1(x, y); work2(x, y);&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; mat[i][j]; pos[mat[i][j]] = mp(i, j); &#125; for (int i = 1, k = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j, ++k) &#123; while (pos[k].ss &lt; j) &#123; if (pos[k].ff != n) &#123; work1(pos[k].ff, pos[k].ss); work1(pos[k].ff - 1, pos[k].ss); &#125; else &#123; swap_up(pos[k].ff - 1, pos[k].ss); &#125; &#125; while (pos[k].ss &gt; j) &#123; if (pos[k].ff != n) &#123; work1(pos[k].ff, pos[k].ss - 1); &#125; else &#123; swap_up(pos[k].ff - 1, pos[k].ss - 1); &#125; &#125; while (pos[k].ff &gt; i + 1) &#123; if (j != 1) &#123; work2(pos[k].ff - 1, pos[k].ss - 1); &#125; else &#123; work1(pos[k].ff - 1, pos[k].ss); work1(pos[k].ff, pos[k].ss - 1); &#125; &#125; if (pos[k].ff != i) &#123; if (j != m) &#123; work1(pos[k].ff - 1, pos[k].ss); work1(pos[k].ff, pos[k].ss - 1); &#125; else &#123; swap_right(pos[k].ff - 1, pos[k].ss - 1); &#125; &#125; &#125; cout &lt;&lt; res_size &lt;&lt; '\\n'; for (int i = 0; i != res_size; ++i) cout &lt;&lt; res[i].ff &lt;&lt; ' ' &lt;&lt; res[i].ss.ff &lt;&lt; ' ' &lt;&lt; res[i].ss.ss &lt;&lt; '\\n';&#125; D. 进制转换题目大意问$~[l,r]~$中有多少个数的$~k~$进制表示恰好有$~m~$个末尾$~0~$。数据范围$1\\leq T\\leq10^5,~1\\leq l\\leq r\\leq10^18,~2\\leq k,m\\leq100$。 题解水题。预处理所有的$~k^m~$，然后将$~k^m~$的倍数的数量减去$~k^{m+1}~$的数量即可。总时间复杂度为$~O(km+T)~$，注意细节。 代码1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const long long INF = 0x3f3f3f3f3f3f3f3f;long long pown[101][102];inline long long calc(const long long&amp; n, const int&amp; k, const int&amp; m) &#123; return (~pown[k][m] ? n / pown[k][m] : 0) - (~pown[k][m + 1] ? n / pown[k][m + 1] : 0);&#125;int main() &#123; for (int i = 2; i &lt;= 100; ++i) &#123; pown[i][0] = 1; for (int j = 1; j &lt;= 101; ++j) &#123; if (pown[i][j - 1] &lt; INF / i &amp;&amp; ~pown[i][j - 1]) pown[i][j] = pown[i][j - 1] * i; else pown[i][j] = -1; &#125; &#125; int t; cin &gt;&gt; t; while (t--) &#123; long long l, r; int k, m; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k &gt;&gt; m; cout &lt;&lt; calc(r, k, m) - calc(l - 1, k, m) &lt;&lt; endl; &#125;&#125; E. 中位数题目大意给定一个带点权有重边的有向无环图$~\\text{DAG}~$，问点$~1~$到点$~n~$所有路径的最大中位数。路径的中位数定义为升序后角标为$~\\lfloor\\frac{x}{2}\\rfloor+1~$的权值。 题解二分套$~\\text{DAG}~$上差分$~\\text{DP}~$。二分答案，然后对于权值大于等于当前值的点标记为$~1~$反之为$~-1~$。从点$~1~$开始跑$~\\text{DP}~$，如果点$~n~$的结果小于$~0~$，则当前值过大。可以先对$~\\text{DAG}~$先拓扑排序，这样$~\\text{DP}~$过程不需要用递归实现，常数小。总时间复杂度为$~O(n\\log A)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 20;int deg[maxn], a[maxn], cal[maxn];vector&lt;int&gt; adj[maxn], topo;void dfs(int u = 1) &#123; for (auto v : adj[u]) if (!deg[v]++) dfs(v); &#125;void topo_sort() &#123; topo.push_back(1); for (int i = 0; i != (int)topo.size(); ++i) for (auto j : adj[topo[i]]) if (!--deg[j]) topo.push_back(j);&#125;bool check(const int&amp; x, const int&amp; end) &#123; memset(cal, 0xc0, sizeof (cal)); cal[1] = 0; for (auto u : topo) &#123; a[u] &lt; x ? --cal[u] : ++cal[u]; for (auto v : adj[u]) cal[v] = max(cal[v], cal[u]); &#125; return cal[end] &gt;= 0;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); &#125; dfs(); if (!deg[n]) return cout &lt;&lt; -1 &lt;&lt; endl, 0; topo_sort(); int left = 0, right = 0x3f3f3f3f; while (right - left != 1) &#123; int mid = (left + right) &gt;&gt; 1; if (check(mid, n)) left = mid; else right = mid; &#125; cout &lt;&lt; left &lt;&lt; endl;&#125; F. 方差题目大意给定$~n~$个数，问$~m~$个数的最小方差$~\\sigma^2~$是多少，输出$~\\sigma^2m^2~$。数据范围$~1\\leq m\\leq n\\leq10^6,~1\\leq x\\leq10^3~$。 题解先排序，注意到数据范围，桶排（基数排序）的时间复杂度为$~O(n+x)~$。注意到方差计算公式 \\begin{aligned} \\sigma^2 &=\\frac{1}{m}\\sum(a-\\bar{a})^2 \\\\ &=\\frac{1}{m}\\sum a^2-\\bar{a}^2 \\end{aligned}于是答案计算公式为 \\max\\{m\\sum_{i=l}^{r}a_i^2-(\\sum_{i=l}^{r}a_i)^2\\}滑窗即可。总时间复杂度为$~O(n+x)~$。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;long long a[1 &lt;&lt; 20];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i ^ n; ++i) cin &gt;&gt; a[i]; sort(a, a + n); long long cal1 = 0, cal2 = 0; for (int i = 0; i ^ m; ++i) cal1 += a[i] * a[i], cal2 += a[i]; long long res = cal1 * m - cal2 * cal2; for (int i = m; i ^ n; ++i) &#123; cal1 += a[i] * a[i] - a[i - m] * a[i - m]; cal2 += a[i] - a[i - m]; res = min(res, cal1 * m - cal2 * cal2); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"http://yoursite.com/categories/刷题笔记/"}],"tags":[]},{"title":"Educational Codeforces Round 60 (Rated for Div. 2)","slug":"Educational Codeforces Round 60 (Rated for Div. 2)","date":"2019-02-24T12:46:50.771Z","updated":"2019-04-18T10:27:35.911Z","comments":true,"path":"2019/02/24/Educational Codeforces Round 60 (Rated for Div. 2)/","link":"","permalink":"http://yoursite.com/2019/02/24/Educational Codeforces Round 60 (Rated for Div. 2)/","excerpt":"","text":"Educational Codeforces Round 60 (Rated for Div. 2) A. Best Subsegment题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; int x = * max_element(a.begin(), a.end()); int res = 0, cnt = 0; for (auto aa : a) &#123; if (aa ^ x) res = max(res, cnt), cnt = 0; else ++cnt; &#125; cout &lt;&lt; max(res, cnt) &lt;&lt; endl;&#125; B. Emotes题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; vector&lt;long long&gt; a(n); long long max1 = 0, max2 = 0; while (n--) &#123; long long a; cin &gt;&gt; a; if (a &gt; max2) max2 = a; if (max1 &lt; max2) swap(max1, max2); &#125; cout &lt;&lt; m / (k + 1) * (max1 * k + max2) + m % (k + 1) * max1 &lt;&lt; endl;&#125; C. Magic Ship题目大意要让一艘船从$~(x_1,~y_1)~$走到$~(x_2,~y_2)~$，每天可以选择上下左右或者不走。但是还有给定的周期为$~n~$的风速影响，每天船的最终移动为当前的风速与船速的选择之和。问到达目的地的最短时间或达不到。 题解将船速和风速分开考虑。那么第$~k~$天能到达目的地，当且仅当$~{\\mid x_2-x_3\\mid+\\mid y_2-y_3\\mid}\\leq k~$。其中$~(x_3,~y_3)~$为如果这$~k~$天船本身静止依靠风速所到达的地点。那么就可以二分天数得出答案了。总时间复杂度为$~O(n+\\log\\max)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;long long, long long&gt; pll;#define mp make_pair#define ff first#define ss secondinline pll operator + (const pll&amp; x, const pll&amp; y) &#123;return mp(x.ff + y.ff, x.ss + y.ss);&#125;inline pll operator - (const pll&amp; x, const pll&amp; y) &#123;return mp(x.ff - y.ff, x.ss - y.ss);&#125;inline pll operator * (const pll&amp; x, const long long&amp; y) &#123;return mp(x.ff * y, x.ss * y);&#125;const long long INF = 0x3f3f3f3f3f3f3f3f;const int maxn = 1e5 + 5;int n;pll wind[maxn], p1, p2;inline bool check(const long long&amp; step) &#123; pll tmp = wind[n] * (step / n) + wind[step % n] - p2; return abs(tmp.ff) + abs(tmp.ss) &lt;= step;&#125;int main() &#123; cin &gt;&gt; p1.ff &gt;&gt; p1.ss &gt;&gt; p2.ff &gt;&gt; p2.ss &gt;&gt; n; p2 = p2 - p1; map&lt;char, pll&gt; cal; cal['U'] = mp(0LL, 1LL); cal['D'] = mp(0LL, -1LL); cal['L'] = mp(-1LL, 0LL); cal['R'] = mp(1LL, 0LL); for (int i = 1; i &lt;= n; ++i) &#123; char ch; cin &gt;&gt; ch; wind[i] = wind[i - 1] + cal[ch]; &#125; long long left = 0, right = INF; while (right - left ^ 1) &#123; long long mid = left + right &gt;&gt; 1; if (check(mid)) right = mid; else left = mid; &#125; cout &lt;&lt; (right ^ INF ? right : -1) &lt;&lt; endl;&#125; D. Magic Gems题目大意观察样例可知题目等价于询问有多少长度为$~N~$的$~01~$序列使得每段连续的$~0~$的长度都是$~M~$的倍数。数据范围$~1\\leq N\\leq10^{18},~2\\leq M\\leq100~$。 题解显然有答案序列的转移式$~res_N=res_{N-1}+res_{N-M}~$。那么转化为矩阵快速幂问题可以在$~O(M^3\\log N)~$的时间复杂内解决。当然也存在$~O(M^2\\log N)~$与$~O(M\\log M\\log N)~$的算法。 代码（$~O(M^3\\log N)~$）1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;int base[100][100], mat[100][100], tmp[100][100], m;inline void mul(int C[][100], int A[][100], int B[][100]) &#123; for (int i = 0; i ^ m; ++i) for (int j = 0; j ^ m; ++j) &#123; C[i][j] = 0; for (int k = 0; k ^ m; ++k) C[i][j] = add(C[i][j], mul(A[i][k], B[k][j])); &#125;&#125;int main() &#123; long long n; cin &gt;&gt; n &gt;&gt; m; base[0][0] = base[0][m - 1] = mat[0][0] = 1; for (int i = 1; i ^ m; ++i) base[i][i - 1] = mat[i][i] = 1; while (n) &#123; if (n &amp; 1) &#123; mul(tmp, mat, base); memcpy(mat, tmp, sizeof (tmp)); &#125; mul(tmp, base, base); memcpy(base, tmp, sizeof (tmp)); n &gt;&gt;= 1; &#125; cout &lt;&lt; mat[0][0] &lt;&lt; endl;&#125; 代码（$~O(M^2\\log N)~$）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef vector&lt;int&gt; vi;const int mod = 1e9 + 7;inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;vi linear_calc(vi&amp; c, long long n) &#123; int size = c.size(); if (size == 1) &#123; int ret = 1; for (int a = c.front(); n; n &gt;&gt;= 1) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); &#125; return vi(1, ret); &#125; vector&lt;vi&gt; base(size &lt;&lt; 1, vi(size, 0)), pow(64, vi(size, 0)); base[0][0] = 1; for (int i = 1; i ^ size &lt;&lt; 1; ++i) for (int j = 0; j ^ size; ++j) base[i][j] = add(mul(base[i - 1].back(), c[j]), j ? base[i - 1][j - 1] : 0); if (n &lt; (size &lt;&lt; 1)) return base[n]; pow[0][1] = 1; for (int i = 1; i ^ 64; ++i) &#123; vi tmp(size &lt;&lt; 1, 0); for (int j = 0; j ^ size; ++j) for (int k = 0; k ^ size; ++k) tmp[j + k] = add(tmp[j + k], mul(pow[i - 1][j], pow[i - 1][k])); for (int j = 0; j ^ size &lt;&lt; 1; ++j) for (int k = 0; k ^ size; ++k) pow[i][k] = add(pow[i][k], mul(tmp[j], base[j][k])); &#125; int index = 62; while ((1LL &lt;&lt; index) &gt; n) --index; vi ret = pow[index]; n ^= 1LL &lt;&lt; index; while (n) &#123; while ((1LL &lt;&lt; index) &gt; n) --index; n ^= 1LL &lt;&lt; index; vi tmp(size &lt;&lt; 1, 0); for (int i = 0; i ^ size; ++i) for (int j = 0; j ^ size; ++j) tmp[i + j] = add(tmp[i + j], mul(ret[i], pow[index][j])); fill(ret.begin(), ret.end(), 0); for (int i = 0; i ^ size &lt;&lt; 1; ++i) for (int j = 0; j ^ size; ++j) ret[j] = add(ret[j], mul(tmp[i], base[i][j])); &#125; return ret;&#125;int main() &#123; long long n; int m; cin &gt;&gt; n &gt;&gt; m; vi base(m, 0); base.front() = base.back() = 1; base = linear_calc(base, n); int res = 0; for (auto x : base) res = add(res, x); cout &lt;&lt; res &lt;&lt; endl;&#125; E. Decypher the String题目大意交互题。现有一个确定但不给出的字符串重排置换，然后给定一个某字符串经过该置换得到的新串。你可以询问任意一个同样长度的字符串，然后返回经过该置换得到的新串。要求在$~3~$次询问以内找出给定串的原串。所有字符串均为小写字母串。数据范围$~1\\leq n\\leq10^4~$。 题解字符集大小为$~26~$。那么考虑这样的一个询问：字符串开头从$~\\text{a}~$开始，每隔$~26^k~$个字符切换到下一个字母。那么就可以得到逆置换下，每个位置所指向的新位置模$~26^{k+1}~$的余数$~x~$再除以$~26^k~$的下取整$~\\lfloor\\frac{x}{26^k}\\rfloor~$的值是多少。所以当$~n\\leq10^4\\leq26^3~$时，做$~3~$次询问就能确定置换。 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str, ask[3], ans[3], res(26 * 26 * 26, '#'); for (char i = 'a'; i &lt;= 'z'; ++i) for (char j = 'a'; j &lt;= 'z'; ++j) for (char k = 'a'; k &lt;= 'z'; ++k) &#123; ask[0].append(1, i); ask[1].append(1, j); ask[2].append(1, k); &#125; cin &gt;&gt; str; int n = str.size(); str.append(26 * 26 * 26 - n, '#'); for (int i = 0; i ^ 3; ++i) &#123; cout &lt;&lt; \"? \" &lt;&lt; ask[i].substr(0, n) &lt;&lt; endl; cin &gt;&gt; ans[i]; ans[i].append(ask[i], n, 26 * 26 * 26 - n); &#125; for (int i = 0; i ^ 26 * 26 * 26; ++i) res[26 * 26 * (ans[0][i] - 'a') + 26 * (ans[1][i] - 'a') + (ans[2][i] - 'a')] = str[i]; cout &lt;&lt; \"! \" &lt;&lt; res.substr(0, n) &lt;&lt; endl;&#125; F. Crisp String题目大意给定一个长度为$~n~$由前$~p~$个小写字母组成的字符串，以及一个$~p\\times p~$的$~01~$对称矩阵。定义一个字符串是$~\\text{crisp}~$的，当且仅当字符串中所有相邻的字符对在矩阵中对应的值是$~1~$，保证给定字符串是$~\\text{crisp}~$的。每一步操作可以选择一个还有的字母，将字符串中所有该字母删除。在保证每一步操作后字符串依然是$~\\text{crisp}~$的条件下，问字符串最短长度。数据范围$~1\\leq n\\leq10^5,~1\\leq p\\leq17~$。 题解状压$~\\text{DP}~$。按位储存当前状态下还有那些字母存在，那么只需要考虑每个状态的合法性即可。对于每对字母$~(i,~j)~$，可以线性对字符串扫描一遍，算出恰好使得$~i~$与$~j~$相邻所需要删除的状态。然后再对所有状态$~\\text{DP}~$，得出在每个状态下$~i~$与$~j~$是否相邻。总时间复杂度为$~O(np^2+p^32^p)~$。代码所写的常数比较大，也存在$~O(np+p^32^p)~$的做法。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int n, p, A[17][17], cnt[17], cal[1 &lt;&lt; 17], res = maxn, a[maxn];bool check[1 &lt;&lt; 17], adj[17][17][1 &lt;&lt; 17], vis[1 &lt;&lt; 17];void dfs(int mask) &#123; if (vis[mask]) return; vis[mask] = true; for (int i = 0; i != p; ++i) for (int j = 0; j != p; ++j) if (mask &amp; 1 &lt;&lt; i &amp;&amp; mask &amp; 1 &lt;&lt; j &amp;&amp; !A[i][j] &amp;&amp; adj[i][j][((1 &lt;&lt; p) - 1) ^ mask]) return; res = min(res, cal[mask]); for (int i = 0; i != p; ++i) if (mask &amp; 1 &lt;&lt; i) dfs(mask ^ 1 &lt;&lt; i);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); string str; cin &gt;&gt; n &gt;&gt; p &gt;&gt; str; for (int i = 0; i != p; ++i) for (int j = 0; j != p; ++j) cin &gt;&gt; A[i][j]; for (int i = 0; i != n; ++i) ++cnt[a[i] = str[i] - 'a']; for (int i = 1; i != (1 &lt;&lt; p); ++i) cal[i] = cal[i ^ (i &amp; -i)] + cnt[__builtin_ctz(i)]; for (int i = 0; i != p; ++i) for (int j = 0; j != p; ++j) &#123; bool check = false; for (int k = 0, l; k != n; ++k) &#123; if (a[k] == j) &#123; if (check) adj[i][j][l] = adj[j][i][l] = true; check = false; &#125; if (a[k] == i) &#123; check = true; l = 0; &#125; if (a[k] != i &amp;&amp; a[k] != j) l |= 1 &lt;&lt; a[k]; &#125; &#125; for (int i = 0; i != p; ++i) for (int j = 0; j != p; ++j) for (int k = 1; k != (1 &lt;&lt; p); ++k) for (int l = 0; l != p; ++l) if (k &amp; 1 &lt;&lt; l) adj[i][j][k] |= adj[i][j][k ^ 1 &lt;&lt; l]; dfs((1 &lt;&lt; p) - 1); cout &lt;&lt; res &lt;&lt; endl;&#125; G. Recursive Queries题目大意给定一个全排列$~p_1,~p_2,~\\dots,~p_n~$，定义 f(l,~r)=\\begin{cases} (r-l+1)+f(l,~m_{lr}-1)+f(m_{lr}+1,~r) &\\text{$l\\leq r$} \\\\ 0 &\\text{$l>r$} \\end{cases}其中$~m_{lr}~$表示$~p_l,~\\dots,~p_r~$中最大值的角标。一共问$~q~$组$~f(l,~r)~$。数据范围$~1\\leq n\\leq10^6,~1\\leq q\\leq10^6~$。 题解定义 fl(l,~r)=(m_{lr}-l)+fl(l,~m_{lr}-1)+fl(m_{lr}+1,~r) \\\\ fr(l,~r)=(r-m_{lr})+fr(l,~m_{lr}-1)+fr(m_{lr}+1,~r)则有 f(l,~r)=(r-l+1)+fl(l,~r)+fr(l,~r)先计算$~fl(l,~r)~$。令 g(i)=\\min\\{j\\mid p_k\\leq p_i,~\\forall~k\\in[j,~i]\\}这一步可以通过单调栈线性处理。此时$~[l,~r]~$中每个点$~i~$作为计算过程中的$~m_{lr}~$时对于$~fl(l,~r)~$的贡献为$~i-\\max(l,~g(i))~$。即 fl(l,~r)=\\sum_{i=l}^{r}i-\\max(l,~g(i))在固定$~r~$的条件下，$~fl(l,~r)~$可以视为关于$~l~$的分段线性函数。将询问离线，然后对右端点$~r~$从小到大扫一遍，每次对当前的分段线性函数增加$~r-\\max(l,~g(r))~$。如何维护分段线性函数？考虑分段线性函数中的斜率$~k~$和截距$~b~$。当$~l&lt; g(r)~$时，可视为$~b~$增加$~r-g(r)~$。反之$~b~$增加$~r~$，而$~k~$减少$~1~$。于是需要一个支持区间修改和单点查询的数据结构，用差分树状数组即可。对于$~fr(l,~r)~$的计算，将所有数据翻转后等价于计算$~fl(l,~r)~$，总时间复杂度为$~O((n+q)\\log n)~$。不推荐使用递归线段树，大常数加上递归复杂度基本会$~\\text{TLE}~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 20;int p[maxn], l[maxn], r[maxn], sta[maxn], sta_size, cal[maxn];long long res[maxn], bit1[maxn], bit2[maxn];vector&lt;int&gt; query[maxn];#define lowbit(x) ((x) &amp; -(x))inline void modify(long long bit[], const int&amp; p, const long long&amp; a) &#123; for (int i = p; i &lt; maxn; i += lowbit(i)) bit[i] += a;&#125;inline long long pre_sum(long long bit[], const int&amp; p) &#123; long long ret = 0; for (int i = p; i; i ^= lowbit(i)) ret += bit[i]; return ret;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; p[i]; for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; l[i]; for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; r[i], query[r[i]].push_back(i); for (int i = 1; i &lt;= n; ++i) &#123; while (sta_size &amp;&amp; p[sta[sta_size]] &lt; p[i]) --sta_size; cal[i] = sta[sta_size] + 1; sta[++sta_size] = i; &#125; for (int i = 1; i &lt;= n; ++i) &#123; modify(bit1, 1, i - cal[i]); modify(bit1, i + 1, -i); modify(bit1, cal[i], cal[i]); modify(bit2, cal[i], 1); modify(bit2, i + 1, -1); for (auto x : query[i]) res[x] += pre_sum(bit1, l[x]) - pre_sum(bit2, l[x]) * l[x]; &#125; reverse(p + 1, p + n + 1); sta_size = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (sta_size &amp;&amp; p[sta[sta_size]] &lt; p[i]) --sta_size; cal[i] = sta[sta_size] + 1; sta[++sta_size] = i; query[i].clear(); &#125; for (int i = 1; i &lt;= m; ++i) &#123; r[i] = n + 1 - r[i]; query[n + 1 - l[i]].push_back(i); &#125; memset(bit1, 0, sizeof (bit1)); memset(bit2, 0, sizeof (bit2)); for (int i = 1; i &lt;= n; ++i) &#123; modify(bit1, 1, i - cal[i]); modify(bit1, i + 1, -i); modify(bit1, cal[i], cal[i]); modify(bit2, cal[i], 1); modify(bit2, i + 1, -1); for (auto x : query[i]) res[x] += pre_sum(bit1, r[x]) - pre_sum(bit2, r[x]) * r[x]; &#125; for (int i = 1; i ^ m; ++i) cout &lt;&lt; res[i] - l[i] - r[i] + n + 2 &lt;&lt; ' '; cout &lt;&lt; res[m] - l[m] - r[m] + n + 2 &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 539 (Div. 2) (TBC)","slug":"Codeforces Round 539 (Div. 2) (TBC)","date":"2019-02-19T14:59:25.560Z","updated":"2019-02-19T14:59:36.584Z","comments":true,"path":"2019/02/19/Codeforces Round 539 (Div. 2) (TBC)/","link":"","permalink":"http://yoursite.com/2019/02/19/Codeforces Round 539 (Div. 2) (TBC)/","excerpt":"","text":"Codeforces Round #539 (Div. 2) A. Sasha and His Trip题目大意水题。 题解水题。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, v; cin &gt;&gt; n &gt;&gt; v; cout &lt;&lt; (n &gt; v ? (n - v + 1) * (n - v) / 2 + v - 1 : n - 1) &lt;&lt; endl;&#125; B. Sasha and Magnetic Machines题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; sort(a.begin(), a.end()); int cal = 0; for (int i = 2; i &lt;= a.back(); ++i) for (int j = n - 1; j; --j) if (a[j] % i == 0) cal = min(cal, (i - 1) * (a.front() - a[j] / i)); cout &lt;&lt; accumulate(a.begin(), a.end(), 0) + cal &lt;&lt; endl;&#125; C. Sasha and a Bit of Relax题目大意给定一个长度为$~n~$的序列，问有多少个偶数长度的连续子序列满足前一半的$~\\text{xor}~$和等于后一半的$~\\text{xor}~$和。数据范围$~2\\leq n\\leq3\\cdot10^5,~0\\leq a&lt; 2^{20}~$。 题解条件其实等价于这个区间的$~\\text{xor}~$和为$~0~$。注意到数据范围，只需要开一个$~cnt~$数组记录前缀$~\\text{xor}~$和，然从前往后扫的过程中更新答案和$~cnt~$即可。时间复杂度为$~O(n)~$，空间复杂度$~O(a)~$。当然用$~\\text{map}~$来储存$~cnt~$也可以，这样的时间复杂度为$~O(n\\log n)~$，空间复杂度为$~O(n)~$。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;int a[maxn], cnt[1 &lt;&lt; 20][2];int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i], ++cnt[a[i] ^= a[i - 1]][i &amp; 1]; long long res = 0; for (int i = 1; i &lt;= n; ++i) &#123; res += cnt[a[i - 1]][i &amp; 1 ^ 1]; --cnt[a[i]][i &amp; 1]; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. Sasha and One More Name题目大意给定一个回文串，需要切$~k~$刀将其拆成$~k+1~$个连续字串，使得存在一种重新组合是个不同于原串的回文串。输出$~k~$的最小值或不存在。数据范围$~1\\leq{\\mid s\\mid}\\leq5000~$。 题解显然如果前$~\\frac{\\mid s\\mid}{2}~$个字符一样，则$~k~$不存在。否则存在一个前缀和后缀，将它们交换后可以得到一个新的回文串，于是$~1\\leq k\\leq2~$。暴力枚举判断即可，时间复杂度为$~O(n^2)~$。但是这题可以进一步优化，如果$~k=1~$，由对称性，不妨设在切在前半段，则所切的那一刀必然得到一个偶数长度的回文前缀的前一半，且剩下的后缀也是回文串（或空串）。运用$~\\text{Manacher}~$算法可以在线性时间内处理出每个中心所对应的最长回文串。那怎么判断这样的做法得到的新串是否和原串不一样呢？最朴素的方式是运用$~\\text{ex-KMP}~$算法。另一种只需要判断切的这一刀的左边，也就是这个回文前缀的的前一半，是否也是个回文串。如果是，则得到的新串必然和原串一样，这个可以自行证明。不论是否运用$~\\text{ex-KMP}~$算法，总时间复杂度均为$~O(n)~$。 代码（$~O(n^2)~$）123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;#define all(o) o.begin(), o.end()int main() &#123; string str; cin &gt;&gt; str; string sub = str.substr(0, str.size() &gt;&gt; 1); if (*max_element(all(sub)) == *min_element(all(sub))) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; bool flag = false; while (!sub.empty()) &#123; string tmp = str.substr(sub.size()) + sub; string pmt = tmp; reverse(all(pmt)); if (tmp == pmt &amp;&amp; str != tmp) return cout &lt;&lt; 1 &lt;&lt; endl, 0; sub.pop_back(); &#125; cout &lt;&lt; 2 &lt;&lt; endl;&#125; 代码（$~O(n)~$）12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e3 + 5;char str[maxn], tmp[maxn &lt;&lt; 1];int len[maxn &lt;&lt; 1];int manacher(char str[], int n, char tmp[], int len[]) &#123; int l = n + 1 &lt;&lt; 1, ret = 1; tmp[0] = '$', tmp[1] = '#'; for (int i = 0; i ^ n; ++i) tmp[i + 1 &lt;&lt; 1] = str[i], tmp[i + 1 &lt;&lt; 1 ^ 1] = '#'; len[1] = 1; for (int i = 2, mid = 1, right = 1; i ^ l; ++i) if ((i &gt; right) | (i + (len[i] = len[(mid &lt;&lt; 1) - i]) &gt; right)) &#123; for (len[mid = i] = 1; tmp[i - len[i]] == tmp[i + len[i]]; ++len[i]); ret = max(ret, len[i] - 1); right = i + len[i] - 1; &#125; return ret;&#125;bool is_palindrome(int left, int right) &#123;return right - left + 2 == len[left + right + 2];&#125;int main() &#123; cin &gt;&gt; str; int n = strlen(str); if (*max_element(str, str + (n &gt;&gt; 1)) == *min_element(str, str + (n &gt;&gt; 1))) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; manacher(str, n, tmp, len); for (int i = 0; i ^ n &gt;&gt; 1; ++i) if (!is_palindrome(0, i) &amp;&amp; is_palindrome(0, i &lt;&lt; 1 ^ 1) &amp;&amp; is_palindrome(i + 1 &lt;&lt; 1, n - 1)) return cout &lt;&lt; 1 &lt;&lt; endl, 0; cout &lt;&lt; 2 &lt;&lt; endl;&#125; F. Sasha and Interesting Fact from Graph Theory题目大意多少棵节点编号为$~1,~2,~\\dots,~n~$，边权范围为$~[1,~m]~$的树，满足连接$~a~$与$~b~$的简单路径的边权之和为$~m~$。数据范围$~2\\leq n\\leq10^6,~1\\leq m\\leq10^6~$。 题解有编号生成树计数问题离不开$~\\text{Pru2fer}~$序列。一棵大小为$~n~$的无根树的$~\\text{Pru2fer}~$序列定义为：每次删去编号最小的叶节点并记录唯一与之相邻的编号，直到还剩$~2~$个点所构成的长度为$~n-2~$的序列。容易证明不同无根树的$~\\text{Pru2fer}~$序列一定不同。相反的对于每个长度为$~n-2~$数据范围为$~[1,~n]~$的序列，可以唯一构造出一无根棵树，过程自行思考。于是得到了一个$~n~$阶完全图的无根生成树与$~\\text{Pru2fer}~$序列的双射。所以$~n~$阶完全图的无根生成树个数为$~n^{n-2}~$，这也就是$~\\text{Cayley}~$公式。显然$~a~$和$~b~$的值并不影响答案。暴力枚举连接$~a~$与$~b~$的简单路径上的点的个数$~x\\in[2,~\\min(n,~m+1)]~$。先考虑边权部分，对于路径上$~x-1~$条边的边权，这是个很普通的组合数学问题，答案为$~\\binom{m-1}{x-1}~$。对于路径外$~n-x~$条边的边权，没有任何限制，答案为$~m^{n-x}~$。对于路径上的点的组合，答案为$~A_{n-2}^{x-2}=\\frac{(n-2)!}{(n-x)!}~$。现在问题剩下的部分等价于给定一条$~x~$点的路径的生成树计数问题。不妨设这些点为$~n,~n-1,~\\dots,~n-x+1~$。那么这棵树的的$~\\text{Pru2fer}~$序列的后$~x-2~$项必为$~n-x+2,~n-x+3,~\\dots,~n~$，且倒数第$~x-1~$项必然在$~[n-x+1,~n]~$之中。有了这些限制，合法的$~\\text{Pru2fer}~$序列数量为$~x\\cdot n^{n-x-1}~$，也就是对应生成树的数量。最终答案公式为 \\sum_{x=2}^{\\min(n,~m+1)}\\frac{x\\cdot(n-2)!}{n\\cdot(n-x)!}(nm)^{n-x}\\binom{m-1}{x-1}如果线性预处理完所有数组，时间复杂度可优化至$~O(n+m)~$。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;const int maxn = 1 &lt;&lt; 20;int inv[maxn], fact[maxn], finv[maxn], pownm[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int mul(const int&amp; a, const int&amp; b, const int&amp; c) &#123;return mul(mul(a, b), c);&#125;inline int mul(const int&amp; a, const int&amp; b, const int&amp; c, const int&amp; d) &#123;return mul(mul(a, b), mul(c, d));&#125;inline int bino(const int&amp; a, const int&amp; b) &#123;return mul(fact[a], finv[b], finv[a - b]);&#125;inline void init(int n = maxn) &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ n; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125;&#125;int main() &#123; init(); int n, m, a, b; cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b; pownm[0] = 1; pownm[1] = mul(n, m); int nm = mul(n, m); for (int i = 1; i ^ maxn; ++i) pownm[i] = mul(pownm[i - 1], nm); int res = 0; for (int x = 2; x &lt;= min(n, m + 1); ++x) res = add(res, mul(mul(pownm[n - x], x, inv[n], bino(m - 1, x - 2)), fact[n - 2], finv[n - x])); cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 539 (Div. 1) (TBC)","slug":"Codeforces Round 539 (Div. 1) (TBC)","date":"2019-02-18T15:01:19.237Z","updated":"2019-02-18T15:01:27.824Z","comments":true,"path":"2019/02/18/Codeforces Round 539 (Div. 1) (TBC)/","link":"","permalink":"http://yoursite.com/2019/02/18/Codeforces Round 539 (Div. 1) (TBC)/","excerpt":"","text":"Codeforces Round #539 (Div. 1) A. Sasha and a Bit of Relax题目大意给定一个长度为$~n~$的序列，问有多少个偶数长度的连续子序列满足前一半的$~\\text{xor}~$和等于后一半的$~\\text{xor}~$和。数据范围$~2\\leq n\\leq3\\cdot10^5,~0\\leq a&lt; 2^{20}~$。 题解条件其实等价于这个区间的$~\\text{xor}~$和为$~0~$。注意到数据范围，只需要开一个$~cnt~$数组记录前缀$~\\text{xor}~$和，然从前往后扫的过程中更新答案和$~cnt~$即可。时间复杂度为$~O(n)~$，空间复杂度$~O(a)~$。当然用$~\\text{map}~$来储存$~cnt~$也可以，这样的时间复杂度为$~O(n\\log n)~$，空间复杂度为$~O(n)~$。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;int a[maxn], cnt[1 &lt;&lt; 20][2];int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i], ++cnt[a[i] ^= a[i - 1]][i &amp; 1]; long long res = 0; for (int i = 1; i &lt;= n; ++i) &#123; res += cnt[a[i - 1]][i &amp; 1 ^ 1]; --cnt[a[i]][i &amp; 1]; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; B. Sasha and One More Name题目大意给定一个回文串，需要切$~k~$刀将其拆成$~k+1~$个连续字串，使得存在一种重新组合是个不同于原串的回文串。输出$~k~$的最小值或不存在。数据范围$~1\\leq{\\mid s\\mid}\\leq5000~$。 题解显然如果前$~\\frac{\\mid s\\mid}{2}~$个字符一样，则$~k~$不存在。否则存在一个前缀和后缀，将它们交换后可以得到一个新的回文串，于是$~1\\leq k\\leq2~$。暴力枚举判断即可，时间复杂度为$~O(n^2)~$。但是这题可以进一步优化，如果$~k=1~$，由对称性，不妨设在切在前半段，则所切的那一刀必然得到一个偶数长度的回文前缀的前一半，且剩下的后缀也是回文串（或空串）。运用$~\\text{Manacher}~$算法可以在线性时间内处理出每个中心所对应的最长回文串。那怎么判断这样的做法得到的新串是否和原串不一样呢？最朴素的方式是运用$~\\text{ex-KMP}~$算法。另一种只需要判断切的这一刀的左边，也就是这个回文前缀的的前一半，是否也是个回文串。如果是，则得到的新串必然和原串一样，这个可以自行证明。不论是否运用$~\\text{ex-KMP}~$算法，总时间复杂度均为$~O(n)~$。 代码（$~O(n^2)~$）123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;#define all(o) o.begin(), o.end()int main() &#123; string str; cin &gt;&gt; str; string sub = str.substr(0, str.size() &gt;&gt; 1); if (*max_element(all(sub)) == *min_element(all(sub))) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; bool flag = false; while (!sub.empty()) &#123; string tmp = str.substr(sub.size()) + sub; string pmt = tmp; reverse(all(pmt)); if (tmp == pmt &amp;&amp; str != tmp) return cout &lt;&lt; 1 &lt;&lt; endl, 0; sub.pop_back(); &#125; cout &lt;&lt; 2 &lt;&lt; endl;&#125; 代码（$~O(n)~$）12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e3 + 5;char str[maxn], tmp[maxn &lt;&lt; 1];int len[maxn &lt;&lt; 1];int manacher(char str[], int n, char tmp[], int len[]) &#123; int l = n + 1 &lt;&lt; 1, ret = 1; tmp[0] = '$', tmp[1] = '#'; for (int i = 0; i ^ n; ++i) tmp[i + 1 &lt;&lt; 1] = str[i], tmp[i + 1 &lt;&lt; 1 ^ 1] = '#'; len[1] = 1; for (int i = 2, mid = 1, right = 1; i ^ l; ++i) if ((i &gt; right) | (i + (len[i] = len[(mid &lt;&lt; 1) - i]) &gt; right)) &#123; for (len[mid = i] = 1; tmp[i - len[i]] == tmp[i + len[i]]; ++len[i]); ret = max(ret, len[i] - 1); right = i + len[i] - 1; &#125; return ret;&#125;bool is_palindrome(int left, int right) &#123;return right - left + 2 == len[left + right + 2];&#125;int main() &#123; cin &gt;&gt; str; int n = strlen(str); if (*max_element(str, str + (n &gt;&gt; 1)) == *min_element(str, str + (n &gt;&gt; 1))) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; manacher(str, n, tmp, len); for (int i = 0; i ^ n &gt;&gt; 1; ++i) if (!is_palindrome(0, i) &amp;&amp; is_palindrome(0, i &lt;&lt; 1 ^ 1) &amp;&amp; is_palindrome(i + 1 &lt;&lt; 1, n - 1)) return cout &lt;&lt; 1 &lt;&lt; endl, 0; cout &lt;&lt; 2 &lt;&lt; endl;&#125; D. Sasha and Interesting Fact from Graph Theory题目大意多少棵节点编号为$~1,~2,~\\dots,~n~$，边权范围为$~[1,~m]~$的树，满足连接$~a~$与$~b~$的简单路径的边权之和为$~m~$。数据范围$~2\\leq n\\leq10^6,~1\\leq m\\leq10^6~$。 题解有编号生成树计数问题离不开$~\\text{Pru2fer}~$序列。一棵大小为$~n~$的无根树的$~\\text{Pru2fer}~$序列定义为：每次删去编号最小的叶节点并记录唯一与之相邻的编号，直到还剩$~2~$个点所构成的长度为$~n-2~$的序列。容易证明不同无根树的$~\\text{Pru2fer}~$序列一定不同。相反的对于每个长度为$~n-2~$数据范围为$~[1,~n]~$的序列，可以唯一构造出一无根棵树，过程自行思考。于是得到了一个$~n~$阶完全图的无根生成树与$~\\text{Pru2fer}~$序列的双射。所以$~n~$阶完全图的无根生成树个数为$~n^{n-2}~$，这也就是$~\\text{Cayley}~$公式。显然$~a~$和$~b~$的值并不影响答案。暴力枚举连接$~a~$与$~b~$的简单路径上的点的个数$~x\\in[2,~\\min(n,~m+1)]~$。先考虑边权部分，对于路径上$~x-1~$条边的边权，这是个很普通的组合数学问题，答案为$~\\binom{m-1}{x-1}~$。对于路径外$~n-x~$条边的边权，没有任何限制，答案为$~m^{n-x}~$。对于路径上的点的组合，答案为$~A_{n-2}^{x-2}=\\frac{(n-2)!}{(n-x)!}~$。现在问题剩下的部分等价于给定一条$~x~$点的路径的生成树计数问题。不妨设这些点为$~n,~n-1,~\\dots,~n-x+1~$。那么这棵树的的$~\\text{Pru2fer}~$序列的后$~x-2~$项必为$~n-x+2,~n-x+3,~\\dots,~n~$，且倒数第$~x-1~$项必然在$~[n-x+1,~n]~$之中。有了这些限制，合法的$~\\text{Pru2fer}~$序列数量为$~x\\cdot n^{n-x-1}~$，也就是对应生成树的数量。最终答案公式为 \\sum_{x=2}^{\\min(n,~m+1)}\\frac{x\\cdot(n-2)!}{n\\cdot(n-x)!}(nm)^{n-x}\\binom{m-1}{x-1}如果线性预处理完所有数组，时间复杂度可优化至$~O(n+m)~$。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;const int maxn = 1 &lt;&lt; 20;int inv[maxn], fact[maxn], finv[maxn], pownm[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int mul(const int&amp; a, const int&amp; b, const int&amp; c) &#123;return mul(mul(a, b), c);&#125;inline int mul(const int&amp; a, const int&amp; b, const int&amp; c, const int&amp; d) &#123;return mul(mul(a, b), mul(c, d));&#125;inline int bino(const int&amp; a, const int&amp; b) &#123;return mul(fact[a], finv[b], finv[a - b]);&#125;inline void init(int n = maxn) &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ n; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125;&#125;int main() &#123; init(); int n, m, a, b; cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b; pownm[0] = 1; pownm[1] = mul(n, m); int nm = mul(n, m); for (int i = 1; i ^ maxn; ++i) pownm[i] = mul(pownm[i - 1], nm); int res = 0; for (int x = 2; x &lt;= min(n, m + 1); ++x) res = add(res, mul(mul(pownm[n - x], x, inv[n], bino(m - 1, x - 2)), fact[n - 2], finv[n - x])); cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 533 (Div. 2)","slug":"Codeforces Round 533 (Div. 2)","date":"2019-02-17T15:28:40.484Z","updated":"2019-02-17T17:28:11.095Z","comments":true,"path":"2019/02/17/Codeforces Round 533 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/02/17/Codeforces Round 533 (Div. 2)/","excerpt":"","text":"Codeforces Round #533 (Div. 2) A. Salem and Sticks题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; int t = 0, cost = 0x7fffffff; for (int i = 1; i &lt;= 100; ++i) &#123; int now = 0; for (auto aa : a) now += max(abs(aa - i) - 1, 0); if (now &lt; cost) t = i, cost = now; &#125; cout &lt;&lt; t &lt;&lt; ' ' &lt;&lt; cost &lt;&lt; endl;&#125; B. Zuhair and Strings题目大意水题。 题解水题。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, k; string str; cin &gt;&gt; n &gt;&gt; k &gt;&gt; str; vector&lt;int&gt; cnt(128, 0), cal(128, 0); if (++cnt[str.front()] == k) ++cal[str.front()], --cnt[str.front()]; for (int i = 1; i ^ n; ++i) &#123; if (str[i] ^ str[i - 1]) cnt[str[i]] = 1; else ++cnt[str[i]]; if (cnt[str[i]] == k) ++cal[str[i]], cnt[str[i]] = 0; &#125; int res = 0; for (int i = 'a'; i &lt;= 'z'; ++i) res = max(res, cal[i]); cout &lt;&lt; res &lt;&lt; endl;&#125; C. Ayoub and Lost Array题目大意问有多少个长度为$~n~$且取值为$~[l,~r]~$的序列满足总和是$~3~$的倍数。数据范围$~1\\leq n\\leq2\\cdot10^5,~1\\leq l\\leq r\\leq10^9~$。 题解动态规划。递推出到每一位上满足总和模$~3~$的余数为$~0,~1,~2~$的序列分别由多少个。这个过程可以用矩阵快速幂优化，总时间复杂度为$~O(\\log n)~$。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;inline void mul(int C[][3], int A[][3], int B[][3]) &#123; for (int i = 0; i ^ 3; ++i) for (int j = 0; j ^ 3; ++j) &#123; C[i][j] = 0; for (int k = 0; k ^ 3; ++k) C[i][j] = add(C[i][j], mul(A[i][k], B[k][j])); &#125;&#125;int main() &#123; init(); int n, l, r; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; int dp[3]; for (int i = 0; i ^ 3; ++i) dp[i] = (r - i + 3) / 3 - (l - i + 2) / 3; int base[3][3] = &#123;&#123;dp[0], dp[2], dp[1]&#125;, &#123;dp[1], dp[0], dp[2]&#125;, &#123;dp[2], dp[1], dp[0]&#125;&#125;; int mat[3][3] = &#123;0&#125;, tmp[3][3]; for (int i = 0; i ^ 3; ++i) mat[i][i] = 1; while (n) &#123; if (n &amp; 1) &#123; mul(tmp, mat, base); memcpy(mat, tmp, sizeof (tmp)); &#125; mul(tmp, base, base); memcpy(base, tmp, sizeof (tmp)); n &gt;&gt;= 1; &#125; cout &lt;&lt; mat[0][0] &lt;&lt; endl;&#125; D. Kilani and the Game题目大意给定一个$~n\\times m~$的网格图和$~p~$种颜色的初始位置以及扩散速度$~s~$。每回合每种颜色可以按曼哈顿距离扩散至空白处。问最终每种颜色的大小。数据范围$~1\\leq m\\leq1000,~1\\leq m\\leq1000,~1\\leq p\\leq9,~1\\leq s\\leq10^9~$。 题解裸$~\\text{BFS}~$，具体实现见代码。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;#define mp make_pair#define ff first#define ss secondint main () &#123; int n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; vector&lt;int&gt; speed(p), res(p, 0); vector&lt;queue&lt;pii&gt;&gt; que(p); for (auto&amp; s : speed) cin &gt;&gt; s; vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(m, false)); for (int i = 0; i ^ n; ++i) for (int j = 0; j ^ m; ++j) &#123; char ch; cin &gt;&gt; ch; if (ch ^ '.') &#123; vis[i][j] = true; if (ch ^ '#') &#123; ++res[ch - '1']; que[ch - '1'].push(mp(i, j)); &#125; &#125; &#125; vector&lt;pii&gt; v(4); v[0] = mp(-1, 0); v[1] = mp(1, 0); v[2] = mp(0, -1); v[3] = mp(0, 1); bool flag = true; while (flag) &#123; flag = false; for (int i = 0; i ^ p; ++i) for (int j = 0; j ^ speed[i]; ++j) &#123; if (que[i].empty()) break; flag = true; queue&lt;pii&gt; tmp; while (!que[i].empty()) &#123; for (auto d : v) &#123; int x = que[i].front().ff + d.ff; int y = que[i].front().ss + d.ss; if (!~x || !~y || x == n || y == m || vis[x][y]) continue; vis[x][y] = true; ++res[i]; tmp.push(mp(x, y)); &#125; que[i].pop(); &#125; que[i] = tmp; &#125; &#125; for (int i = 0; i ^ p - 1; ++i) cout &lt;&lt; res[i] &lt;&lt; ' '; cout &lt;&lt; res.back() &lt;&lt; endl;&#125; E. Helping Hiasat题目大意有$~m~$个字符串，现给出若干个字符串集合，要求选出最多的字符串使得每个集合里至多选一个。数据范围$~1\\leq n\\leq10^5,~1\\leq m\\leq40,~1\\leq{\\mid s\\mid}\\leq40~$。 题解显然可以通过$~\\text{map}~$之类的手段化为一个图上最大独立集的问题。而它的补图是个最大团问题。用$~\\text{Bron-Kerbosch}~$算法可以在$~O(3^\\frac{m}{3})~$的时间复杂度内解决。总时间复杂度为$~O(n\\log\\mid s\\mid+3^\\frac{m}{3})~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;#define count1_64 __builtin_popcountll#define low0_64 __builtin_ctzllconst int maxn = 40;ull adj[maxn];int res;void bk(ull cur, ull allow, ull forbid) &#123; if (!allow) &#123; if (!forbid) res = max(res, count1_64(cur)); return; &#125; ull tmp = allow &amp; ~adj[low0_64(allow | forbid)]; for (int i = 0; i ^ maxn; ++i) if (1ULL &lt;&lt; i &amp; tmp) &#123; bk(cur ^ 1ULL &lt;&lt; i, allow &amp; adj[i], forbid &amp; adj[i]); allow ^= 1ULL &lt;&lt; i; forbid ^= 1ULL &lt;&lt; i; &#125;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; map&lt;string, int&gt; id; ull now = 0; int id_ = 0; while (n--) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; for (int i = 0; i ^ maxn; ++i) if (now &amp; 1ULL &lt;&lt; i) adj[i] |= now; now = 0; &#125; else &#123; string str; cin &gt;&gt; str; if (id.find(str) == id.end()) id[str] = id_++; now |= 1ULL &lt;&lt; id[str]; &#125; &#125; for (int i = 0; i ^ maxn; ++i) &#123; if (now &amp; 1ULL &lt;&lt; i) adj[i] |= now; adj[i] ^= (1ULL &lt;&lt; m) - 1; &#125; bk(0, (1ULL &lt;&lt; maxn) - 1, 0); cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"2019 Wannafly Winter Camp Day1 Div1","slug":"2019 Wannafly Winter Camp Day1 Div1","date":"2019-02-16T14:43:44.646Z","updated":"2019-02-16T14:46:50.403Z","comments":true,"path":"2019/02/16/2019 Wannafly Winter Camp Day1 Div1/","link":"","permalink":"http://yoursite.com/2019/02/16/2019 Wannafly Winter Camp Day1 Div1/","excerpt":"","text":"A. 机器人题目大意水题。 题解水题。注意特殊情况讨论。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, r, m, k, s; cin &gt;&gt; n &gt;&gt; r &gt;&gt; m &gt;&gt; k &gt;&gt; s; int left[2] = &#123;n, n&#125;, right[2] = &#123;0&#125;; while (r--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; left[y] = min(left[y], x); right[y] = max(right[y], x); &#125; vector&lt;bool&gt; flag(n + 1, false); flag[1] = flag[n] = true; while (m--) &#123; int pos; cin &gt;&gt; pos; flag[pos] = true; &#125; int ll = min(left[0], left[1]), rr = max(right[0], right[1]); int lll = ll, rrr = rr; while (!flag[lll]) --lll; while (!flag[rrr]) ++rrr; int res; if (right[1]) &#123; res = k; if (s &lt; ll) &#123; lll = left[1]; while (!flag[lll]) --lll; res += rrr - min(s, lll); &#125; else if (s &gt; rr) &#123; rrr = right[1]; while (!flag[rrr]) ++rrr; res += max(s, rrr) - lll; &#125; else &#123; res += rrr - lll; &#125; &#125; else &#123; if (s &lt; ll) res = rrr - s; else if (s &gt; rr) res = s - lll; else if (ll == rr) res = 0; else res = rrr - lll; &#125; cout &lt;&lt; (res &lt;&lt; 1) &lt;&lt; endl;&#125; B. 吃豆豆题目大意在$~n\\times m~$的网格图上，对于格子$~(i,~j)~$，在$~T[i][j]~$的整数倍秒时会由糖果在上面。现给定起点和终点，每秒可以选择上下左右或者不动，然后可以取走当前格子上的糖果，如果存在的话。问要获得$~C~$个糖果的最短时间。数据范围$~1\\leq n\\leq10,~1\\leq m\\le10,~1\\leq T\\leq10,~1\\leq C\\leq10^{18}~$。 题解动态规划，记录$~dp[i][j][k]~$表示第$~0~$秒在$~j~$点，第$~i~$秒在$~k~$点最多能得到多少颗糖果，这里$~j~$和$~k~$的范围是$~[0,~nm)~$。枚举$~i~$到$~\\gcd(1,~2,~\\dots,~10)=2520~$即可，因为第$~2520x~$秒在$~j~$点$~2520x+i~$秒在$~k~$点最多能得到的糖果数也为$~dp[i][j][k]~$。这里我们可以将$~dp[i]~$看作一个$~nm\\times nm~$的矩阵，将正常的矩阵乘法中的数值乘法变为加法，数值乘法变为取$~\\max~$。于是对于从$~0~$秒到第$~2520x~$秒的最多糖果矩阵，即为$~dp[2520]^x~$。由于可以原地不动，所以从$~(xs,~ys)~$到$~(xt,~yt)~$经过$~t~$秒所能得到的最多糖果数是单调递增的。用带余除法分解$~t=2520x+y~$，于是通过倍增可以求出$~x~$，然后二分$~y~$可以算出最小的$~t~$值。总时间复杂度为$~O(12600n^4+n^6\\log C)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int STEP = 2520;const int mat_size = 10000 * sizeof (__int128);int T[100];__int128 dp0[100][100], dp1[100][100], dp[STEP + 1][100], mat[64][100][100], now[100][100], tmp[100][100], cal[100];inline void update(__int128&amp; x, const __int128&amp; y) &#123;x &lt; y ? (x = y) : 0;&#125;inline void mul(__int128 C[][100], __int128 A[][100], __int128 B[][100], int size) &#123; for (int i = 0; i ^ size; ++i) for (int j = 0; j ^ size; ++j) &#123; C[i][j] = -1; for (int k = 0; k ^ size; ++k) if (~A[i][k] &amp;&amp; ~B[k][j]) update(C[i][j], A[i][k] + B[k][j]); &#125;&#125;inline void mul(__int128 C[], __int128 A[][100], __int128 B[], int size) &#123; for (int i = 0; i ^ size; ++i) &#123; C[i] = -1; for (int j = 0; j ^ size; ++j) if (~A[i][j] &amp;&amp; ~B[j]) update(C[i], A[i][j] + B[j]); &#125;&#125;void cout128(__int128 x) &#123; if (x &gt; 9) cout128(x / 10); cout &lt;&lt; int(x % 10);&#125;int main() &#123; int n, m; long long C; cin &gt;&gt; n &gt;&gt; m &gt;&gt; C; int size = n * m; for (int i = 0; i ^ size; ++i) cin &gt;&gt; T[i]; int xss, yss, xtt, ytt; cin &gt;&gt; xss &gt;&gt; yss &gt;&gt; xtt &gt;&gt; ytt; int ss = xss * m + yss - m - 1, tt = xtt * m + ytt - m - 1; for (int i = 0; i ^ 100; ++i) for (int j = 0; j ^ 100; ++j) if (i ^ j) dp0[i][j] = -1; for (int step = 1; step &lt;= STEP; ++step) &#123; for (int xs = 0; xs ^ n; ++xs) for (int ys = 0; ys ^ m; ++ys) &#123; int s = xs * m + ys; for (int xt = 0; xt ^ n; ++xt) for (int yt = 0; yt ^ m; ++yt) &#123; int t = xt * m + yt; dp1[s][t] = dp0[s][t]; if (xt) update(dp1[s][t], dp0[s][t - m]); if (yt) update(dp1[s][t], dp0[s][t - 1]); if (xt ^ n - 1) update(dp1[s][t], dp0[s][t + m]); if (yt ^ m - 1) update(dp1[s][t], dp0[s][t + 1]); if (~dp1[s][t]) dp1[s][t] += !(step % T[t]); &#125; dp[step][s] = dp1[s][tt]; &#125; memcpy(dp0, dp1, sizeof (dp0)); &#125; for (int i = 1; i &lt;= STEP; ++i) if (dp[i][ss] &gt;= C) return cout &lt;&lt; i &lt;&lt; endl, 0; memcpy(mat[0], dp0, mat_size); for (int i = 1; i ^ 64; ++i) mul(mat[i], mat[i - 1], mat[i - 1], size); int up = 63; while (mat[up][ss][tt] &gt;= C) --up; memcpy(now, mat[up], mat_size); __int128 X = 1LL &lt;&lt; up; for (int k = up - 1; ~k; --k) &#123; mul(tmp, now, mat[k], size); if (tmp[ss][tt] &lt; C) &#123; X ^= 1LL &lt;&lt; k; memcpy(now, tmp, mat_size); &#125; &#125; int l = 0, r = STEP; while (r - l ^ 1) &#123; int mid = l + r &gt;&gt; 1; mul(cal, now, dp[mid], size); if (cal[ss] &lt; C) l = mid; else r = mid; &#125; cout128(STEP * X + r); cout &lt;&lt; endl;&#125; C. 拆拆拆数题目大意将$~A~$和$~B~$分别拆成尽量小的$~n~$组，然后组成$~n~$对，使得每对互质。 题解首先猜想$~n\\leq 2~$，下面通过奇偶性对于$~\\gcd(A,~B)&gt;1~$的情况考虑构造。如果$~2\\nmid A,~2\\nmid B~$，则拆成$~(2,~A-2),~(B-2,~2)~$是显然满足题意的。剩下的情况不妨设$~2\\mid A~$，则$~(3,~A-3),~(B-2,~2)~$和$~(3,~A-3),~(B-4,~4)~$中必有一组是全部互质的。此时只有$~B=5~$的时候会产生非法情况。此时拆成$~(5,~A-5),~(3,~2)~$即可。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; long long A, B; cin &gt;&gt; A &gt;&gt; B; if (__gcd(A, B) == 1) &#123; cout &lt;&lt; 1 &lt;&lt; '\\n' &lt;&lt; A &lt;&lt; ' ' &lt;&lt; B &lt;&lt; '\\n'; continue; &#125; cout &lt;&lt; 2 &lt;&lt; '\\n'; if (A &amp; B &amp; 1) &#123; cout &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; B - 2 &lt;&lt; '\\n' &lt;&lt; A - 2 &lt;&lt; ' ' &lt;&lt; 2 &lt;&lt; '\\n'; &#125; else if (A &amp; 1) &#123; if (A == 5) cout &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; B - 5 &lt;&lt; '\\n' &lt;&lt; 3 &lt;&lt; ' ' &lt;&lt; 5 &lt;&lt; '\\n'; else if (A % 3 != 2) cout &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; B - 3 &lt;&lt; '\\n' &lt;&lt; A - 2 &lt;&lt; ' ' &lt;&lt; 3 &lt;&lt; '\\n'; else cout &lt;&lt; 4 &lt;&lt; ' ' &lt;&lt; B - 3 &lt;&lt; '\\n' &lt;&lt; A - 4 &lt;&lt; ' ' &lt;&lt; 3 &lt;&lt; '\\n'; &#125; else &#123; if (B == 5) cout &lt;&lt; A - 5 &lt;&lt; ' ' &lt;&lt; 2 &lt;&lt; '\\n' &lt;&lt; 5 &lt;&lt; ' ' &lt;&lt; 3 &lt;&lt; '\\n'; else if (B % 3 != 2) cout &lt;&lt; A - 3 &lt;&lt; ' ' &lt;&lt; 2 &lt;&lt; '\\n' &lt;&lt; 3 &lt;&lt; ' ' &lt;&lt; B - 2 &lt;&lt; '\\n'; else cout &lt;&lt; A - 3 &lt;&lt; ' ' &lt;&lt; 4 &lt;&lt; '\\n' &lt;&lt; 3 &lt;&lt; ' ' &lt;&lt; B - 4 &lt;&lt; '\\n'; &#125; &#125;&#125; D. 超难的数学题题目大意定义一个十进制数是好的，当且仅当它的十进制表示下存在$~3~$个连续的数字满足中间的严格大于两边的。现要求求出最小的$~n~$满足$~1,~2,~\\dots,~n~$中好数的比例不小于给定的比例$~p~$。 题解设$~f(n)~$为$~[1,~n]~$中好数的个数，则下面想办法构造一个序列$~a~$逼近正确答案。先令$~a_0=122~$为满足$~f=0~$的最大正整数,于是必有$~\\frac{f(a_0)}{a_0}&lt; p~$。若$~\\frac{f(a_i)}{a_i}&lt; p~$，那么考虑如何将$~a_i~$放大为$~a_{i+1}~$来逼近正确答案。为了不超过正确答案，假设$~(a_i,~a_{i+1}]~$内全是好数，那么必有$~\\frac{f(a_i)+a_{i+1}-a_i-1}{a_{i+1}-1}&lt; p~$。同时为了更快的逼近正确答案，有$~\\frac{f(a_i)+a_{i+1}-a_i}{a_{i+1}}\\geq p~$，于是有 a_{i+1}=\\left\\lceil\\frac{a_i-f(a_i)}{1-p}\\right\\rceil若$~\\frac{f(a_i)}{a_i}\\geq p~$，则代表此时已经求出答案$~a_i~$。由于$~a~$是严格单增的，在确保有界的情况下，一定存在$~a_i~$为正解。这个序列的逼近速度取决于$~f~$的分布密度和$~p~$的大小，但是过程是类似于牛顿迭代的思想，所以复杂度可以视为大常数$~C~$。下面计算$~f~$，数位$~\\text{DP}~$即可。记录$~dp[i][j][0/1]~$表示考虑到第$~i~$位还没有达成好数条件且当前是$~j~$左边有$~0/1~$个数字比$~j~$小的情况数量。这里要用到大整数高精度，在$~100~$位以内就能得出答案。总时间复杂度为$~O(100\\cdot10^2\\cdot C\\cdot\\text{BigInteger})~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.io.*;import java.util.*;import java.math.*;public class Main &#123; static BigInteger[] pow10 = new BigInteger[100]; static BigInteger[][][] dp = new BigInteger[100][10][2]; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); double p = in.nextDouble(); BigInteger hunredThousand = new BigInteger(\"100000\"); int pp = (int)(p * 100000 + 0.1); BigInteger ppp = new BigInteger(Integer.toString(pp)); BigInteger a = new BigInteger(\"122\"); initDP(); while (true) &#123; BigInteger f = func(a); if (f.multiply(hunredThousand).compareTo(a.multiply(ppp)) != -1) break; a = a.subtract(f).multiply(hunredThousand).subtract(BigInteger.ONE).divide(hunredThousand.subtract(ppp)).add(BigInteger.ONE); &#125; System.out.println(a.toString()); &#125; static void initDP() &#123; pow10[0] = BigInteger.ONE; pow10[1] = new BigInteger(\"10\"); for (int i = 2; i != 100; ++i) &#123; pow10[i] = pow10[i - 1].multiply(pow10[1]); &#125; &#125; static BigInteger func(BigInteger n) &#123; String str = n.toString(); int size = str.length(); for (int i = 0; i != size; ++i) &#123; for (int j = 0; j != 10; ++j) &#123; for (int k = 0; k != 2; ++k) &#123; dp[i][j][k] = BigInteger.ZERO; &#125; &#125; &#125; BigInteger ret = BigInteger.ZERO; int count = 1; int last = (int)(str.charAt(0) - '0'); for (int i = 1; i != last; ++i) &#123; dp[0][i][0] = dp[0][i][0].add(BigInteger.ONE); &#125; boolean flag = true; for (int i = 1; i != size; ++i) &#123; if (flag) &#123; int now = (int)(str.charAt(i) - '0'); for (int j = 0; j != now; ++j) &#123; if (j &gt; last) &#123; if (count == 1) &#123; dp[i][j][1] = dp[i][j][1].add(BigInteger.ONE); &#125; else &#123; ret = ret.add(pow10[size - i - 1]); &#125; &#125; else &#123; dp[i][j][0] = dp[i][j][0].add(BigInteger.ONE); &#125; &#125; if (now &gt; last) &#123; ++count; &#125; else &#123; count = 1; &#125; if (count == 3) &#123; ret = ret.add(BigInteger.ONE); if (i + 1 != size) &#123; ret = ret.add(new BigInteger(str.substring(i + 1, size))); &#125; flag = false; &#125; last = now; &#125; for (int j = 0; j != 10; ++j) &#123; if (j != 0) &#123; dp[i][j][0] = dp[i][j][0].add(BigInteger.ONE); &#125; for (int k = 0; k != j; ++k) &#123; dp[i][j][1] = dp[i][j][1].add(dp[i - 1][k][0]); ret = ret.add(dp[i - 1][k][1].multiply(pow10[size - i - 1])); &#125; for (int k = j; k != 10; ++k) &#123; dp[i][j][0] = dp[i][j][0].add(dp[i - 1][k][0]).add(dp[i - 1][k][1]); &#125; &#125; &#125; return ret; &#125;&#125; E. 流流流动题目大意当$~i\\not=1~$且是奇数时，与$~3i+1~$连一条边。偶数时与$~\\frac{i}{2}~$连一条边。取点可以得到$~f[i]~$的收益，但是如果一条边的两个端点$~x~$和$~y~$都取了，则会失去$~d[\\min(x,~y)]~$。问最大收益。 题解根据角谷猜想，图一定是一个森林，于是树形$~01\\text{DP}~$即可。时间复杂度为$~O(n)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; adj[101];inline void add(const int&amp; u, const int&amp; v, const int&amp; w) &#123;adj[u].push_back(make_pair(v, w));&#125;inline void biadd(const int&amp; u, const int&amp; v, const int&amp; w) &#123;add(u, v, w); add(v, u, w);&#125;bool vis[101];int f[101], d[101], dp[101][2];void dfs(int u) &#123; vis[u] = true; dp[u][1] = f[u]; for (auto v : adj[u]) if (!vis[v.first]) &#123; dfs(v.first); dp[u][0] += max(dp[v.first][0], dp[v.first][1]); dp[u][1] += max(dp[v.first][0], dp[v.first][1] - v.second); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; f[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; d[i]; for (int i = 2; i &lt;= n; ++i) &#123; if (i &amp; 1 &amp;&amp; i * 3 + 1 &lt;= n) biadd(i, i * 3 + 1, d[i]); if (!(i &amp; 1)) biadd(i, i &gt;&gt; 1, d[i &gt;&gt; 1]); &#125; int res = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; dfs(i); res += max(dp[i][0], dp[i][1]); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; F.爬爬爬山题目大意问带点权边权的单源最短路。 题解堆优化的带点权的$~\\text{Dijkstra}~$单源最短路，时间复杂度为$~O(m\\log m)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; long long k, h; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; h; vector&lt;long long&gt; cost(n + 1, 0); k += h; for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; h; if (h &gt; k) cost[i] = (h - k) * (h - k); &#125; vector&lt;vector&lt;pair&lt;int, long long&gt;&gt;&gt; adj(n + 1, vector&lt;pair&lt;int, long long&gt;&gt;(0)); while (m--) &#123; int x, y; long long z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; adj[x].push_back(make_pair(y, z)); adj[y].push_back(make_pair(x, z)); &#125; vector&lt;bool&gt; vis(n + 1, false); vector&lt;long long&gt; res(n + 1); priority_queue&lt;pair&lt;long long, int&gt;, vector&lt;pair&lt;long long, int&gt;&gt;, greater&lt;pair&lt;long long, int&gt;&gt;&gt; que; que.push(make_pair(cost[1], 1)); while (true) &#123; auto now = que.top(); que.pop(); if (vis[now.second]) continue; vis[now.second] = true; res[now.second] = now.first; if (now.second == n) break; for (auto next : adj[now.second]) que.push(make_pair(now.first + next.second + cost[next.first], next.first)); &#125; cout &lt;&lt; res[n] &lt;&lt; endl;&#125; G. 双重矩阵题目大意给定一个$~n\\times m~$的矩阵，以它位子矩阵单位构造一个$x\\times y$个该矩阵的大矩阵，问大矩阵最大的子矩阵满足不互质。数据范围$~1\\leq n\\leq100,~1\\leq m\\leq100,~1\\leq x\\leq1000000,~1\\leq y\\leq1000000~$。 题解问$~\\text{WSY}~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using ul = std::uint32_t;using li = std::int32_t;using ll = std::int64_t;using ull = std::uint64_t;using llf = long double;using lf = double;const ul sz = 256;ul data;ul vtrees[201][sz &lt;&lt; 1];ul htree[sz &lt;&lt; 1];ull n, m, x, y;ul gcd(ul a, ul b)&#123; while (a) &#123; a ^= b ^= a ^= b %= a; &#125; return b;&#125;void change(ul tree[], ul pos, ul v)&#123; for (tree[pos |= sz] = v, pos &gt;&gt;= 1; pos; pos &gt;&gt;= 1) &#123; tree[pos] = gcd(tree[pos &lt;&lt; 1 | 1], tree[pos &lt;&lt; 1]); &#125;&#125;ul get(const ul tree[], ul l, ul r)&#123; ul ret = 0; for (l = l - 1 | sz, r = r + 1 | sz; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123; if (~l &amp; 1) &#123; ret = gcd(ret, tree[l ^ 1]); &#125; if (r &amp; 1) &#123; ret = gcd(ret, tree[r ^ 1]); &#125; &#125; return ret;&#125;ull fn(ull t)&#123; return t == n ? x * n : t;&#125;ull fm(ull t)&#123; return t == m ? y * m : t;&#125;int main()&#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; for (ul i = 1; i &lt;= n; ++i) &#123; for (ul j = 1; j &lt;= m; ++j) &#123; std::cin &gt;&gt; data; change(vtrees[j], i, data); change(vtrees[j], i + n, data); change(vtrees[j + m], i, data); change(vtrees[j + m], i + n, data); &#125; &#125; ull ans = 0; for (ul up = 1; up &lt;= n; ++up) &#123; for (ul low = up; low &lt;= up + n - 1; ++low) &#123; for (ul i = 1; i &lt;= m + m; ++i) &#123; change(htree, i, get(vtrees[i], up, low)); &#125; for (ul l = 1, r = 1; l &lt;= m; ++l) &#123; while (r &lt; l) &#123; ++r; &#125; while (r &lt; l + m - 1 &amp;&amp; get(htree, l, r + 1) != 1) &#123; ++r; &#125; if (get(htree, l, r) != 1) &#123; ans = std::max(ans, fn(low - up + 1) * fm(r - l + 1)); &#125; &#125; &#125; &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125; H. 我爱割葱题目大意给定$~n~$棵葱，第$~i~$棵的高度为$~a_i~$。定义在高度$~h~$割区间$~[l,~r]~$是合法的，如果对于任意$~i\\in[l,~r]~$，均满足$~h\\leq a_i~$。割完一刀后将获得下面的部分，且上面的部分不会掉落。现在最多割$~k~$刀，问能获得葱的总长度的最大值。 题解问$~\\text{WSY}~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;using ul = std::uint32_t;using li = std::int32_t;using ll = std::int64_t;using ull = std::uint64_t;using llf = long double;using lf = double;const ul sz = 128;ul a[102];ul least[102][102];ul n, k;ul tree[256];std::vector&lt;std::pair&lt;ul, bool&gt;&gt; paras;std::vector&lt;ul&gt; stack;ul segid[102][102];ul valid[1000001];ul idval[101];ul ans[101][101][101];bool already[101][101][101];class segment &#123;public: ul l = 0, r = 0; segment(ul a, ul b): l(a), r(b) &#123; &#125; segment()=default;&#125;;std::vector&lt;segment&gt; sons[102][102];segment bigson[102][102];segment bro[102][102];std::vector&lt;std::vector&lt;segment&gt;&gt; segstack(1);segment idseg[101];void getbroandbigson(ul l, ul r)&#123; if (!sons[l][r].size()) &#123; return; &#125; bigson[l][r] = sons[l][r][0]; for (ul i = 0; i != sons[l][r].size(); ++i) &#123; if (i) &#123; bro[sons[l][r][i - 1].l][sons[l][r][i - 1].r] = sons[l][r][i]; &#125; getbroandbigson(sons[l][r][i].l, sons[l][r][i].r); &#125;&#125;ul search(ul l, ul r, ul c, ul k)&#123; if (!l || !r || !k) &#123; return 0; &#125; if (already[segid[l][r]][valid[c]][k]) &#123; return ans[segid[l][r]][valid[c]][k]; &#125; already[segid[l][r]][valid[c]][k] = true; ul temp1 = 0; for (ul sonk = 0; sonk &lt;= k; ++sonk) &#123; temp1 = std::max(temp1, search(bro[l][r].l, bro[l][r].r, c, k - sonk) + search(bigson[l][r].l, bigson[l][r].r, c, sonk)); &#125; ul temp2 = 0; for (ul sonk = 0; sonk &lt; k; ++sonk) &#123; temp2 = std::max(temp2, search(bro[l][r].l, bro[l][r].r, c, k - 1 - sonk) + search(bigson[l][r].l, bigson[l][r].r, least[l][r], sonk)); &#125; temp2 += (r - l + 1) * (least[l][r] - c); return ans[segid[l][r]][valid[c]][k] = std::max(temp1, temp2);&#125;void change(ul tree[], ul pos, ul val)&#123; for (tree[pos |= sz] = val, pos &gt;&gt;= 1; pos; pos &gt;&gt;= 1) &#123; tree[pos] = std::min(tree[pos &lt;&lt; 1 | 1], tree[pos &lt;&lt; 1]); &#125;&#125;ul get(const ul tree[], ul l, ul r)&#123; ul ret = 1e6 + 1; for (l = l - 1 | sz, r = r + 1 | sz; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123; if (~l &amp; 1) &#123; ret = std::min(ret, tree[l ^ 1]); &#125; if (r &amp; 1) &#123; ret = std::min(ret, tree[r ^ 1]); &#125; &#125; return ret;&#125;int main()&#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; k; for (ul i = 1; i &lt;= n; ++i) &#123; std::cin &gt;&gt; a[i]; change(tree, i, a[i]); &#125; ul cnt = 1; for (ul l = 1; l &lt;= n; ++l) &#123; for (ul r = l; r &lt;= n; ++r) &#123; least[l][r] = get(tree, l, r); if (least[l][r] &gt; a[l - 1] &amp;&amp; least[l][r] &gt; a[r + 1]) &#123; paras.push_back(std::pair&lt;ul, bool&gt;(l, false)); paras.push_back(std::pair&lt;ul, bool&gt;(r, true)); segid[l][r] = cnt; valid[least[l][r]] = cnt; idseg[cnt] = segment(l, r); idval[cnt] = least[l][r]; ++cnt; &#125; &#125; &#125; std::sort(paras.begin(), paras.end()); for (const auto&amp; para : paras) &#123; if (para.second) &#123; ul l = stack.back(); ul r = para.first; stack.pop_back(); sons[l][r] = std::move(segstack.back()); segstack.pop_back(); segstack.back().push_back(segment(l, r)); &#125; else &#123; stack.push_back(para.first); segstack.push_back(std::vector&lt;segment&gt;()); &#125; &#125; getbroandbigson(1, n); std::cout &lt;&lt; search(1, n, 0, k) &lt;&lt; std::endl; return 0;&#125; I. 起起落落题目大意给定一个序列$~p~$，定义一个奇数长度且至少为$~3~$的子序列$~p_{a_1},~p_{a_2},~\\dots,~p_{a_m}~$是持续下降的，如果对于任意$~i~$为偶数，均满足$~p_{a_{i-1}}&gt;p_{a_{i+1}}&gt;p_{a_i}~$。计算出有多少个持续下降子序列。数据范围$~1\\leq n\\leq100000~$。 题解问$~\\text{WJR}~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;const int mod = 1e9 + 7;int n;int a[maxn],t[maxn],e;int pos(int x)&#123; return lower_bound(t+1,t+1+e,x) - t;&#125;struct SEG&#123; int seg[maxn*5],lazy[maxn*5],g[maxn*5]; int lson(int v) &#123; return v &lt;&lt; 1; &#125; int rson(int v) &#123; return v &lt;&lt; 1 | 1; &#125; void init()&#123; memset(seg,0,sizeof seg); memset(lazy,0,sizeof seg); memset(g,0,sizeof g); &#125; void pushdown(int v)&#123; lazy[lson(v)] += lazy[v]; lazy[rson(v)] += lazy[v]; lazy[v] = 0; &#125; void change(int l,int r,int ql,int qr,int v,int val)&#123; if(l &gt; qr||r &lt; ql) return; if(l == r) &#123; lazy[v] = 0; g[v] = val; return; &#125; pushdown(v); int mid = (l + r ) &gt;&gt; 1; change(l,mid,ql,qr,lson(v),val); change(mid+1,r,ql,qr,rson(v),val); pushup(v); &#125; void pushup(int v)&#123; seg[v] = (seg[lson(v)] + 1ll * g[lson(v)] * lazy[lson(v)] % mod) % mod; seg[v] += (seg[rson(v)] + 1ll * g[rson(v)] * lazy[rson(v)] % mod) % mod; seg[v] %= mod; g[v] = (g[lson(v)] + g[rson(v)]) % mod; &#125; void update(int l,int r,int ql,int qr,int v,int val) &#123; if(qr &lt; ql) return; if(ql &lt;= l&amp;&amp;r &lt;= qr) &#123; lazy[v] += val; return; &#125; if(l &gt; qr||r &lt; ql) return; pushdown(v); int mid = (l + r) &gt;&gt; 1; if(l &lt;= mid) update(l,mid,ql,qr,lson(v),val); if(r &gt; mid) update(mid+1,r,ql,qr,rson(v),val); pushup(v); &#125; int sum(int l,int r,int ql,int qr,int v) &#123; if(qr &lt; ql) return 0; if(ql &lt;= l&amp;&amp;r &lt;= qr)&#123; return (seg[v] + 1ll * g[v] * lazy[v] % mod) % mod; &#125; if(r &lt; ql||l &gt; qr) return 0; pushdown(v); int res = 0,mid = (l + r) &gt;&gt; 1; if(l &lt;= mid) res += sum(l,mid,ql,qr,lson(v)); if(r &gt; mid) res = (res + sum(mid+1,r,ql,qr,rson(v))) % mod; pushup(v); return res; &#125;&#125;f;int main() &#123; scanf(\"%d\",&amp;n); for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;a[i]); memcpy(t,a,sizeof a); e = n; sort(t+1,t+1+e); e = unique(t+1,t+1+e) - (t+1); f.init(); int ans = 0; for(int i = n;i &gt;= 1;i--) &#123; int v = pos(a[i]); int temp = f.sum(1,e,1,v-1,1); ans = (ans + temp) % mod; f.update(1,e,v+1,e,1,1); f.change(1,e,v,v,1,(temp + 1) % mod); &#125; printf(\"%d\\n\",ans); return 0;&#125; J. 夺宝奇兵有$~n~$个人，他们总共有$~m~$个宝物。现已知每个宝物在谁手上和它的售价，问最少花多少钱买可以使得自己的宝物数量严格大于任何人的宝物数量。 题解先对所有人所持有的宝物排序，然后暴力枚举交易结束后其他人宝物数量的最大值。在这个过程中维护一棵权值线段树，这样每次枚举过程中树上二分即可得到相应的最小花费。我的代码是使用二分权值树状数组，复杂度多一层$~O(\\log m)~$，但是常数比权值线段树递归写法小很多，也很方便。权值线段树或权值树状数组二分写法的时间复杂度为$~o((n+m)\\log m)~$，下面代码的时间复杂度为$~O((n+m)\\log^2m)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;long long num[maxn], bit2[maxn];vector&lt;int&gt; have[maxn], flr[maxn];int cnt[maxn], bit1[maxn];#define lowbit(x) (x &amp; -x)int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; struct Input &#123; long long a; int c; &#125;; vector&lt;Input&gt; input(m + 1); for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; input[i].a &gt;&gt; input[i].c; sort(input.begin(), input.end(), [](Input a, Input b) &#123;return a.a &lt; b.a;&#125;); for (int i = 1; i &lt;= m; ++i) &#123; num[i] = input[i].a; have[input[i].c].push_back(i); flr[have[input[i].c].size()].push_back(input[i].c); &#125; long long tot = 0; for (int i = 1; i &lt;= n; ++i) sort(have[i].begin(), have[i].end(), greater&lt;long long&gt;()); int up; for (up = 1; flr[up].size(); ++up) cnt[up] = cnt[up - 1] + flr[up].size(); for (int i = 1; i &lt;= m; ++i) for (int j = i; j &lt; maxn; j += lowbit(j)) ++bit1[j], bit2[j] += num[i]; long long res = 0x3f3f3f3f3f3f3f3f; for (int i = up; cnt[up - 1] - cnt[i - 1] &lt;= i &amp;&amp; i; --i) &#123; int rem = i - cnt[up - 1] + cnt[i - 1]; for (auto j : flr[i]) &#123; int idx = have[j][i - 1]; tot += num[idx]; for (int k = idx; k &lt; maxn; k += lowbit(k)) --bit1[k], bit2[k] -= num[idx]; &#125; long long now = tot; if (rem) &#123; int l = 0, r = maxn; while (r - l ^ 1) &#123; int mid = l + r &gt;&gt; 1, sum = 0; for (int k = mid; k; k -= lowbit(k)) sum += bit1[k]; if (sum &lt; rem) l = mid; else r = mid; &#125; for (int k = r; k; k -= lowbit(k)) now += bit2[k]; &#125; res = min(res, now); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; K. 星球大战题目大意给定一个$~n~$个点$~m~$条边的简单连通图，定义两点间的距离为连接连点的简单路径的最小值。现给定邪恶势力的起点位置，需要找到一个正义势力的起点位置，使得势力扩散后最终邪恶势力的数量最少。对于每个点，如果它离邪恶势力的距离严格小于离正义势力的距离，则最终会变为邪恶势力，否则变为正义势力或者保持中立。输出邪恶势力最终数量的最小值。 题解问$~\\text{WSY}~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;bits/stdc++.h&gt;using ul = std::uint32_t;using li = std::int32_t;using ll = std::int64_t;using ull = std::uint64_t;using llf = long double;using lf = double;using vul = std::vector&lt;ul&gt;;vul edges[ul(1e5 + 1)];ul father[ul(1e5 + 1)][18];std::vector&lt;ul&gt; sons[ul(1e5 + 1)];ul n, m;std::queue&lt;ul&gt; queue;bool already[ul(1e5 + 1)];std::vector&lt;ul&gt; special;ul disspecial[202][ul(1e5 + 1)];ul dis1[ul(1e5 + 1)];ul left[ul(1e5 + 1)];ul right[ul(1e5 + 1)];std::vector&lt;std::pair&lt;ul, bool&gt;&gt; paras;ul calcfather(ul x, ul lg)&#123; if (!x) &#123; return 0; &#125; if (~father[x][lg]) &#123; return father[x][lg]; &#125; else &#123; return father[x][lg] = calcfather(calcfather(x, lg - 1), lg - 1); &#125;&#125;ul getfather(ul x, ul step)&#123; for (ul lg = 0; step; step &gt;&gt;= 1, ++lg) &#123; if (step &amp; 1) &#123; x = calcfather(x, lg); &#125; &#125; return x;&#125;ul search(ul x, ul cnt) &#123; left[x] = cnt; for (ul son : sons[x]) &#123; cnt = search(son, cnt + 1); &#125; right[x] = cnt; return cnt;&#125;int main()&#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::scanf(\"%u%u\", &amp;n, &amp;m); for (ul i = 1; i &lt;= n; ++i) &#123; for (ul j = 0; j != 18; ++j) &#123; father[i][j] = ~ul(0); &#125; &#125; for (ul i = 0; i != m; ++i) &#123; ul u, v; std::scanf(\"%u%u\", &amp;u, &amp;v); edges[u].push_back(v); edges[v].push_back(u); &#125; queue.push(1); already[1] = true; father[1][0] = 0; while (queue.size()) &#123; ul curr = queue.front(); queue.pop(); for (ul nex : edges[curr]) &#123; if (father[curr][0] == nex) &#123; continue; &#125; if (already[nex]) &#123; special.push_back(curr); special.push_back(nex); continue; &#125; father[nex][0] = curr; sons[curr].push_back(nex); queue.push(nex); already[nex] = true; dis1[nex] = dis1[curr] + 1; &#125; &#125; std::sort(special.begin(), special.end()); special.resize(std::unique(special.begin(), special.end()) - special.begin()); search(1, 1); for (ul i = 0; i != special.size(); ++i) &#123; for (ul j = 1; j &lt;= n; ++j) &#123; disspecial[i][j] = ~ul(0); &#125; queue.push(special[i]); disspecial[i][special[i]] = 0; while (queue.size()) &#123; ul curr = queue.front(); queue.pop(); for (ul nex : edges[curr]) &#123; if (~disspecial[i][nex]) &#123; continue; &#125; disspecial[i][nex] = disspecial[i][curr] + 1; queue.push(nex); &#125; &#125; &#125; ul ans = n; for (ul white = 2; white &lt;= n; ++white) &#123; paras.resize(0); for (ul i = 0; i != special.size(); ++i) &#123; if (dis1[special[i]] &lt; disspecial[i][white]) &#123; continue; &#125; ul temp = getfather(special[i], dis1[special[i]] - disspecial[i][white] &gt;&gt; 1); paras.push_back(std::pair&lt;ul, bool&gt;(left[temp], false)); paras.push_back(std::pair&lt;ul, bool&gt;(right[temp], true)); &#125; ul temp = getfather(white, dis1[white] &gt;&gt; 1); paras.push_back(std::pair&lt;ul, bool&gt;(left[temp], false)); paras.push_back(std::pair&lt;ul, bool&gt;(right[temp], true)); std::sort(paras.begin(), paras.end()); temp = 0; ul st = 0; ul prev = 0; for (const auto&amp; para : paras) &#123; if (!st) &#123; prev = para.first; &#125; if (para.second) &#123; --st; &#125; else &#123; ++st; &#125; if (!st) &#123; temp += para.first - prev + 1; &#125; &#125; ans = std::min(ans, n - temp); &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"训练笔记","slug":"训练笔记","permalink":"http://yoursite.com/categories/训练笔记/"}],"tags":[]},{"title":"RMQ与LCA与ST表 (TBC)","slug":"RMQ与LCA与ST表 (TBC)","date":"2019-02-14T17:19:26.857Z","updated":"2019-02-15T20:28:53.818Z","comments":true,"path":"2019/02/15/RMQ与LCA与ST表 (TBC)/","link":"","permalink":"http://yoursite.com/2019/02/15/RMQ与LCA与ST表 (TBC)/","excerpt":"","text":"RMQ区间最值查询$~\\text{Range Minimun/Maximun Query}~$，简称$~\\text{RMQ}~$。 线段树线段树是解决$~\\text{RMQ}~$问题最普通的办法，时间复杂度为预处理$~O(n)~$，单次询问$~O(\\log n)~$。支持在线。同时也支持$~O(\\log n)~$的区间修改的动态$~\\text{RMQ}~$问题。下面模板的区间均为左开右闭，角标从$~0~$开始。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const int maxn = 1 &lt;&lt; 17;int a[maxn], seg[maxn &lt;&lt; 1], tag[maxn &lt;&lt; 1];#define mid (begin + end &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (index &lt;&lt; 1 ^ 1)void build(int begin, int end, int index) &#123; if (begin ^ mid) &#123; build(begin, mid, lson); build(mid, end, rson); seg[index] = min(seg[lson], seg[rson]); &#125; else &#123; seg[index] = a[begin]; &#125;&#125;inline void push_down(const int&amp; index) &#123; seg[index] += tag[index]; if (index &lt; maxn)) &#123; tag[lson] += tag[index]; tag[rson] += tag[index]; &#125; tag[index] = 0;&#125;void modify(int begin, int end, int index, int left, int right, int x) &#123; push_down(index); if (begin &gt;= left &amp;&amp; end &lt;= right) &#123; tag[index] += x; return; &#125; if (left &lt; mid) modify(begin, mid, lson, left, right, x); if (right &gt; mid) modify(mid, end, rson, left, right, x); seg[index] = min(seg[lson] + tag[lson], seg[rson] + tag[rson]);&#125;int query(int begin, int end, int index, int left, int right) &#123; push_down(index); if (begin &gt;= left &amp;&amp; end &lt;= right) return seg[index]; if (begin &gt;= right || end &lt;= left) return 0x3f3f3f3f; return min(query(begin, mid, lson, left, right), query(mid, end, rson, left, right));&#125; ST表如果只有静态查询，那么考虑这样一个数组：记$~st[i][j]~$为$~[i,~i+2^j)~$的最值。那么需要$~O(n\\log n)~$的空间。显然$~st[i][0]=a[i]~$。且对于其它项，可以将区间$~[i,~i+2^j)~$二分为$~[i,~i+2^{j-1})~$和$~[i+2^{j-1},~i+2^j)~$，也就是通过$~st[i][j-1]~$和$~st[i+2^{j-1}][j-1]~$来$~O(1)~$地转移。那么对于任意的询问区间$~[l,~r)~$，记$~k=\\lfloor\\log(r-l)\\rfloor~$，均可划分为$~[l,~l+2^k)~$和$~[r-2^k,~r)~$这两个子问题来解决。时间复杂度为预处理$~O(n\\log n)~$，单次询问$~O(1)~$。支持在线。下面模板的角标从$~0~$开始。 12345678910111213141516const int pow2 = 17;const int maxn = 1 &lt;&lt; pow2;int a[maxn], st[maxn][pow2 + 1], log2_floor[maxn], n;void st_init(int n) &#123; log2_floor[0] = -1; for (int i = 1; i &lt;= n; ++i) log2_floor[i] = log2_floor[i &gt;&gt; 1] + 1; for (int i = 0; i ^ n; ++i) st[i][0] = a[i]; for (int i = 1; i &lt;= log2_floor[n]; ++i) for (int j = 0; j + (1 &lt;&lt; i) ^ n; ++j) st[j][i] = min(st[j][i - 1], st[j + (1 &lt;&lt; i - 1)][i - 1]);&#125;inline int rmq(const int&amp; l, const int&amp; r) &#123; int k = log2_floor[r - l]; return min(st[l][k], st[r - (1 &lt;&lt; k)][k]);&#125; LCA最近公共祖先$~\\text{Lowest Common Ancestors}~$，简称$~\\text{LCA}~$。 倍增类似于$~\\text{ST}~$表的$~\\text{DP}~$思想，记$~pa[i][j]~$为节点$~i~$的第$~2^j~$级祖先。为防止溢出，根节点的父亲依然是根节点。现在$~\\text{DFS}~$过程中处理出$~pa[i][0]~$，对于其它项，有$~O(1)~$的转移式 pa[i][j]=pa[pa[i][j-1]][j-1]这里的时间复杂度和空间复杂度均为$~O(\\log n)~$。那么可以用类似快速幂的方式，可以在$~O(\\log n)~$的时间内查询任意点的任意级祖先。查询$~\\text{LCA}~$时，先将较深的点上升到与另一点等高，然后在保持两点不一样的条件下，将两个点上升至$~\\text{LCA}~$的两个儿子处。时间复杂度为预处理$~O(n\\log n)~$，单次查询$~O(\\log n)~$。支持在线。 123456789101112131415161718192021const int pow2 = 17;const int maxn = 1 &lt;&lt; pow2;vector&lt;int&gt; adj[maxn];int pa[maxn][pow2], dep[maxn];void dfs(int u = 1, int p = 1, int d) &#123; dep[u] = d; pa[u][0] = p; for (int i = 1; i ^ pow2; ++i) pa[u][i] = pa[pa[u][i - 1]][i - 1]; for (auto v : adj[u]) if (v ^ p) dfs(v, u, d + 1);&#125;int lca(int u, int v) &#123; if (dep[u] &gt; dep[u]) swap(u, v); for (int k = dep[v] - dep[u], i = 0; k; k &gt;&gt;= 1, ++i) if (k &amp; 1) u = pa[u][i]; if (u == v) return u; for (int i = pow2 - 1; ~i; --i) if (pa[u][i] ^ pa[v][i]) &#123; u = pa[u][i]; v = pa[v][i]; &#125; return pa[u][0];&#125; ST表首先引入一个叫欧拉序的概念，在$~\\text{DFS}~$序的基础上，将回溯过程中经过的点也加入到序列之中，则构成了欧拉序。容易证明，序列的长度为$~2n-1~$，且一个节点是叶节点当且仅当它只在欧拉序中出现一次。那么对于非叶节点$~u~$，它在欧拉序中出现至少$~2~$次，那么节点$~v~$是$~u~$的后代，当且仅当$~v~$在欧拉序中，被$~2~$个$~u~$包含。于是对于欧拉序上两个点的$~\\text{LCA}~$问题，可以等价于这两个节点构成的闭区间的$~\\text{LCA}~$问题，且$~\\text{LCA}~$必出现在这个闭区间之中。和$~\\text{RMQ}~$问题一样，这类问题是保偏序的。所以可以用$~\\text{ST}~$表来支持$~O(n\\log n)~$的预处理和$~O(1)~$的单次在线查询。 1234567891011121314151617181920212223242526272829303132const int pow2 = 17;const int maxn = 1 &lt;&lt; pow2;vector&lt;int&gt; adj[maxn];int st[maxn &lt;&lt; 1][pow2 + 1], dep[maxn], euler[maxn], log2_floor[maxn &lt;&lt; 1];int euler_clock;void dfs(int u = 1, int p = 0) &#123; st[++euler_clock][0] = u; euler[u] = euler_clock; for (auto v : adj[u]) if (v ^ p) &#123; dep[v] = dep[u] + 1; dfs(v, u); st[++euler_clock][0] = u; &#125;&#125;inline bool cmp(const int&amp; x, const int&amp; y) &#123;return dep[x] &lt; dep[y];&#125;inline int upper(const int&amp; x, const int&amp; y) &#123;return cmp(x, y) ? x : y;&#125;void lca_init() &#123; log2_floor[0] = -1; for (int i = 1; i &lt;= euler_clock; ++i) log2_floor[i] = log2_floor[i &gt;&gt; 1] + 1; for (int i = 1; i &lt;= log2_floor[euler_clock]; ++i) for (int j = 1; j + (1 &lt;&lt; i) ^ euler_clock + 1; ++j) st[j][i] = upper(st[j][i - 1], st[j + (1 &lt;&lt; i - 1)][i - 1]);&#125;inline int lca(int u, int v) &#123; if (u == v) return u; u = euler[u]; v = euler[v]; if (u &gt; v) swap(u, v); int temp = log2_floor[++v - u]; return upper(st[u][temp], st[v - (1 &lt;&lt; temp)][temp]);&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"RMQ","slug":"RMQ","permalink":"http://yoursite.com/tags/RMQ/"},{"name":"LCA","slug":"LCA","permalink":"http://yoursite.com/tags/LCA/"},{"name":"ST表","slug":"ST表","permalink":"http://yoursite.com/tags/ST表/"}]},{"title":"Codeforces Global Round 1 (TBC)","slug":"Codeforces Global Round 1 (TBC)","date":"2019-02-14T16:32:50.817Z","updated":"2019-02-14T16:51:29.557Z","comments":true,"path":"2019/02/15/Codeforces Global Round 1 (TBC)/","link":"","permalink":"http://yoursite.com/2019/02/15/Codeforces Global Round 1 (TBC)/","excerpt":"","text":"Codeforces Global Round 1 A. Parity题目大意问一个$~k~$位$~b~$进制数的奇偶性。 题解水题。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int b, k, a; cin &gt;&gt; b &gt;&gt; k; b &amp;= 1; int res = 0; while (--k) &#123; cin &gt;&gt; a; res ^= a &amp; 1 &amp; b; &#125; cin &gt;&gt; a; res ^= a &amp; 1; if (res) cout &lt;&lt; \"odd\" &lt;&lt; endl; else cout &lt;&lt; \"even\" &lt;&lt; endl;&#125; B. Tape题目大意要求使用$~k~$个区间覆盖$~n~$个点，输出区间长度总和的最小值。 题解水题。贪心。差分序列排序即可。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; vector&lt;int&gt; b(n), d(n, 0); for (auto&amp; in : b) cin &gt;&gt; in; for (int i = 1; i ^ n; ++i) d[i] = b[i] - b[i - 1] - 1; sort(d.begin(), d.end()); int res = b.back() - b.front() + 1; for (int i = n - k + 1; i ^ n; ++i) res -= d[i]; cout &lt;&lt; res &lt;&lt; endl;&#125; C. Meaningless Operations题目大意定义$~f(a)=\\max{\\gcd(a\\oplus b,~a\\odot b)\\mid0&lt; b&lt; a}~$其中$~\\oplus~$和$~\\odot~$分别是位运算中的异或$~\\text{xor}~$和与$~\\text{and}~$。一共$~q~$次询问，输出对应的$~f(a)~$。数据范围$~1\\leq q\\leq10^3,~2\\leq a\\leq2^{25}-1~$。 题解可以发现将$~a~$二进制表示后，如果不全为$~1~$，则$~f(a)~$即为全为$~1~$的数值（取$~b~$为$~a~$的补位）。否则$~f(a)~$为$~a~$的最大非$~a~$因子。具体证明过程可自行考虑。那么只需要预处理所有$~2^n-1~$即可。用$~\\text{map}~$储存预处理数值并用$~\\text{__builtin}~$优化位运算，总时间复杂度为$~O(\\sqrt{a}+q\\log a)~$。当然也可以打表后用数组储存答案，时间复杂度可以优化至$~O(q)~$。 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; map&lt;int, int&gt; res; for (int i = 2; i &lt;= 25; ++i) &#123; int x = (1 &lt;&lt; i) - 1; for (int j = 3, k = sqrt(x + 0.1); j &lt;= k; ++j) if (!(x % j)) &#123; res[x] = x / j; break; &#125; if (res.find(x) == res.end()) res[x] = 1; &#125; int q; cin &gt;&gt; q; while (q--) &#123; int a; cin &gt;&gt; a; int x = (1 &lt;&lt; 32 - __builtin_clz(a)) - 1; if (x ^ a) cout &lt;&lt; x &lt;&lt; endl; else cout &lt;&lt; res[x] &lt;&lt; endl; &#125;&#125; D. Jongmah题目大意麻将模拟，问最多能凑出多少副顺子或者刻子。 题解动态规划。每个数字如果作为顺子计算，那么只有$~3~$种位置供选择。而若某一位置上这个数字作为顺子出现的次数大于$~2~$，那么对于$~3k~$个一样的顺子，可以化为$~3k~$个刻子。那么对于每一个数字，它前$~2~$个数字的状态总数则是$~3\\times3=9~$种，每次转移要计算$~3~$次，这样总时间复杂度为$~O(3^3m)~$。可以用滚动数组优化空间。 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; cnt(m, 0); while (n--) &#123; int a; cin &gt;&gt; a; ++cnt[--a]; &#125; int dp[2][3][3] = &#123;0&#125;; for (int i = 0; i ^ m; ++i) &#123; memset(dp[i &amp; 1 ^ 1], 0, 9 * sizeof (int)); for (int j = 0; j ^ 3; ++j) for (int k = 0; k ^ 3; ++k) for (int l = 0; l ^ 3; ++l) if (j + k + l &lt;= cnt[i]) dp[i &amp; 1 ^ 1][k][l] = max(dp[i &amp; 1 ^ 1][k][l], dp[i &amp; 1][j][k] + l + (cnt[i] - j - k - l) / 3); &#125; cout &lt;&lt; dp[m &amp; 1][0][0] &lt;&lt; endl;&#125; E. Magic Stones题目大意对于一个长度为$~n~$的序列，可以对非端点元素如下操作：将$~c_i~$变为$~c_{i+1}+c_{i-1}-c_i~$。现给定两个序列$~c~$和$~t~$，问$~c~$能否经过若干次操作变成$~t~$。 题解考虑差分序列，不难发现每次操作则是交换差分序列相邻的两个元素。只需要将差分序列排序比较即可。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), b(n); for (auto&amp; in : a) cin &gt;&gt; in; for (auto&amp; in : b) cin &gt;&gt; in; for (int i = n - 1; i; --i) a[i] -= a[i - 1], b[i] -= b[i - 1]; sort(a.begin() + 1, a.end()); sort(b.begin() + 1, b.end()); cout &lt;&lt; (a == b ? \"Yes\" : \"No\") &lt;&lt; endl;&#125; F. Nearest Leaf题目大意编号按照$~\\text{DFS}~$序给出一棵边权树，两点之间的距离定义为简单路径的权值和。每次询问编号$~[l,~r]~$内与$~v~$最近的叶子的距离。数据范围$~3\\leq n\\leq500000,~1\\leq q\\leq500000~$。 题解将问题离线，对于$~v=1~$的询问，叶节点的距离保留，其余距离设为$~\\inf~$，这样可以用一棵最值线段树来询问最短距离。由$~\\text{DFS}~$序的性质，每个节点的子树的编号均为序列上的一个闭区间，那么在$~\\text{DFS}~$的过程中，区间修改，就能对所有的节点进行询问。总时间复杂度为$~O((n+q)\\log n)~$。注意需要快读。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 19;vector&lt;pair&lt;int, long long&gt;&gt; son[maxn];vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; ask[maxn];long long dis[maxn], res[maxn], seg[maxn &lt;&lt; 1], tag[maxn &lt;&lt; 2];bool check[maxn];int n, now, index[maxn];void dfs1(int u) &#123; now = u; for (auto e : son[u]) &#123; dis[e.first] = dis[u] + e.second; dfs1(e.first); &#125; index[u] = now; check[u] = son[u].empty();&#125;#define mid (begin + end &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (index &lt;&lt; 1 ^ 1)void build(int begin, int end, int index) &#123; if (begin ^ mid) &#123; build(begin, mid, lson); build(mid, end, rson); seg[index] = min(seg[lson], seg[rson]); &#125; else &#123; seg[index] = check[end] ? dis[end] : 0x3f3f3f3f3f3f3f3f; &#125;&#125;inline void push_down(const int&amp; index) &#123; seg[index] += tag[index]; tag[lson] += tag[index]; tag[rson] += tag[index]; tag[index] = 0;&#125;long long query(int begin, int end, int index, int left, int right) &#123; push_down(index); if (begin &gt;= left &amp;&amp; end &lt;= right) return seg[index]; if (begin &gt;= right || end &lt;= left) return 0x3f3f3f3f3f3f3f3f; return min(query(begin, mid, lson, left, right), query(mid, end, rson, left, right));&#125;void modify(int begin, int end, int index, int left, int right, long long x) &#123; push_down(index); if (begin &gt;= left &amp;&amp; end &lt;= right) &#123; tag[index] += x; return; &#125; if (left &lt; mid) modify(begin, mid, lson, left, right, x); if (right &gt; mid) modify(mid, end, rson, left, right, x); seg[index] = min(seg[lson] + tag[lson], seg[rson] + tag[rson]);&#125;void dfs2(int u) &#123; for (auto q : ask[u]) res[q.second] = query(0, n, 1, q.first.first - 1, q.first.second); for (auto e : son[u]) &#123; tag[1] += e.second; modify(0, n, 1, e.first - 1, index[e.first], -(e.second &lt;&lt; 1)); dfs2(e.first); tag[1] -= e.second; modify(0, n, 1, e.first - 1, index[e.first], e.second &lt;&lt; 1); &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int q; cin &gt;&gt; n &gt;&gt; q; for (int i = 2; i &lt;= n; ++i) &#123; int p; long long w; cin &gt;&gt; p &gt;&gt; w; son[p].push_back(make_pair(i, w)); &#125; dfs1(1); build(0, n, 1); for (int i = 0; i ^ q; ++i) &#123; int v, l, r; cin &gt;&gt; v &gt;&gt; l &gt;&gt; r; ask[v].push_back(make_pair(make_pair(l, r), i)); &#125; dfs2(1); for (int i = 0; i ^ q; ++i) cout &lt;&lt; res[i] &lt;&lt; '\\n';&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Educational Codeforces Round 59 (Rated for Div. 2) (TBC)","slug":"Educational Codeforces Round 59 (Rated for Div. 2) (TBC)","date":"2019-02-14T10:11:31.136Z","updated":"2019-02-14T11:52:24.786Z","comments":true,"path":"2019/02/14/Educational Codeforces Round 59 (Rated for Div. 2) (TBC)/","link":"","permalink":"http://yoursite.com/2019/02/14/Educational Codeforces Round 59 (Rated for Div. 2) (TBC)/","excerpt":"","text":"Educational Codeforces Round 59 (Rated for Div. 2) A. Digits Sequence Dividing题目大意水题。 题解水题。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int q; cin &gt;&gt; q; while (q--) &#123; int n; string str; cin &gt;&gt; n &gt;&gt; str; if (str.size() == 2 &amp;&amp; str.front() &gt;= str.back()) cout &lt;&lt; \"NO\" &lt;&lt; endl; else cout &lt;&lt; \"YES\" &lt;&lt; endl &lt;&lt; 2 &lt;&lt; endl &lt;&lt; str.front() &lt;&lt; ' ' &lt;&lt; str.substr(1) &lt;&lt; endl; &#125;&#125; B. Digital root题目大意对于任意正整数$~x~$，将其十进制表示下的所有位的数字相加得到新的数字$~\\bar{x}~$，不断操作下去，最终会得到一个个位数，记为$~S(x)~$。问第$~k~$大的满足$~S=x~$的数是多少。 题解水题。不难发现每次操作均满足$~x=\\bar{x}\\mod9~$。于是答案即为$~9(k-1)+x~$。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; while (n--) &#123; long long k, x; cin &gt;&gt; k &gt;&gt; x; cout &lt;&lt; (k - 1) * 9 + x &lt;&lt; endl; &#125;&#125; C. Brutality题目大意给定一个小写字母串和同样长度的数值序列，字符串中每段连续的同字母字串所对应的数值序列中，最多取$~k~$个数，问最大的取值之和。 题解水题。直接模拟，用$~\\text{mulitset}~$或者$~\\text{priority_queue}~$维护均可。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;long long&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; string str; cin &gt;&gt; str; str.push_back('#'); a.push_back(0); ++n; priority_queue&lt;long long&gt; heap; heap.push(a.front()); long long res = 0; int cnt; for (int i = 1; i ^ n; ++i) &#123; if (str[i] ^ str[i - 1]) &#123; cnt = k; while (!heap.empty()) &#123; res += heap.top(); if (!--cnt) break; heap.pop(); &#125; while (!heap.empty()) heap.pop(); &#125; heap.push(a[i]); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. Compression题目大意给定一个$~n\\times n~$的$~01~$矩阵，问$~n~$的最大因子$~x~$，满足把大矩阵划分为$~\\frac{n}{x}\\times\\frac{n}{x}~$个$~x\\times x~$的小矩阵之后，所有的小矩阵均只有一个值。 题解水题？直接对每行每列取$~\\gcd~$即可。没看标解也看不懂标解。所以这场比赛有$~4~$个签到题？ 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5200;bitset&lt;maxn&gt; row[maxn], column[maxn];inline int calc(const bitset&lt;maxn&gt;&amp; bit, const int n) &#123; int last = !bit[0]; int ret = 0, cnt = 0; for (int i = 0; i ^ n; ++i) &#123; if (last ^ bit[i]) &#123; ret = __gcd(ret, cnt); cnt = 0; &#125; ++cnt; last = bit[i]; &#125; return __gcd(ret, cnt);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 0; i ^ n; ++i) &#123; string str; cin &gt;&gt; str; for (int j = 0; j ^ n &gt;&gt; 2; ++j) &#123; int x = isdigit(str[j]) ? str[j] - '0' : str[j] - 'A' + 10; for (int k = 0; k ^ 4; ++k) if (x &amp; 1 &lt;&lt; 3 - k) row[i].flip(j &lt;&lt; 2 ^ k); &#125; &#125; for (int i = 0; i ^ n; ++i) for (int j = 0; j ^ n; ++j) if (row[i][j]) column[j].flip(i); int res = 0; for (int i = 0; i ^ n; ++i) res = __gcd(res, __gcd(calc(row[i], n), calc(column[i], n))); cout &lt;&lt; res &lt;&lt; endl;&#125; G. Vasya and Maximum Profit题目大意给定两序列$~d_1,~d_2,~\\dots,~d_n~$和$~c_1,~c_2,~\\dots,~c_n~$，其中$~d~$严格单增。并定义 gap(l,~r)=\\begin{cases} \\max_{l\\leq i< r}(d_{i+1}-d_i)^2 &\\text{$l< r$} \\\\ 0 &\\text{$l=r$} \\end{cases}对于区间$~[l,~r]~$的价值，计算公式为 (r-l+1)a-\\sum_{i=l}^{r}c_i-gap(l,~r)问最大价值。 题解首先预处理$~(d_{i+1}-d_i)^2~$数组。考虑每个区间所对应的$~gap~$在该数组中的位置。用单调栈可以线性预处理出$~(d_{i+1}-d_i)^2~$在该数组中，左右边第一个比它大的位置。那么对于取到$~gap(l,~r)=(d_{i+1}-d_i)^2~$的区间$~[l,~r]~$。可以$~O(1)~$地确认区间的左右边界。暴力枚举每个$~(d_{i+1}-d_i)^2~$，接下来就是一个线段树维护区间求和的最大值问题了，在普通区间求和线段树的基础上，每个节点还需要维护包含左端点的最大区间和和包含右端点的最大区间和。总时间复杂度为$~O(n\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;long long d[maxn], c[maxn], del[maxn];pair&lt;int, int&gt; seg[maxn];struct Node &#123; long long sum, left, right;&#125; tree[maxn &lt;&lt; 2];#define mid (begin + end &gt;&gt; 1)#define lson (index &lt;&lt; 1)#define rson (index &lt;&lt; 1 ^ 1)void build(int begin, int end, int index) &#123; if (begin == end) &#123; if ((tree[index].sum = c[begin]) &gt; 0) tree[index].left = tree[index].right = c[begin]; return; &#125; build(begin, mid, lson); build(mid + 1, end, rson); tree[index].sum = tree[lson].sum + tree[rson].sum; tree[index].left = max(tree[lson].left, tree[lson].sum + tree[rson].left); tree[index].right = max(tree[rson].right, tree[rson].sum + tree[lson].right);&#125;long long query_sum(int left, int right, int begin, int end, int index) &#123; if (left &gt; end || right &lt; begin) return 0; if (left &lt;= begin &amp;&amp; right &gt;= end) return tree[index].sum; return query_sum(left, right, begin, mid, lson) + query_sum(left, right, mid + 1, end, rson);&#125;long long query_left(int left, int right, int begin, int end, int index) &#123; if (left &gt; end || right &lt; begin) return 0xc0c0c0c0c0c0c0c0; if (left &lt;= begin &amp;&amp; right &gt;= end) return tree[index].left; return max(query_left(left, right, begin, mid, lson), query_sum(left, right, begin, mid, lson) + query_left(left, right, mid + 1, end, rson));&#125;long long query_right(int left, int right, int begin, int end, int index) &#123; if (left &gt; end || right &lt; begin) return 0xc0c0c0c0c0c0c0c0; if (left &lt;= begin &amp;&amp; right &gt;= end) return tree[index].right; return max(query_right(left, right, mid + 1, end, rson), query_sum(left, right, mid + 1, end, rson) + query_right(left, right, begin, mid, lson));&#125;int main() &#123; int n; long long a; cin &gt;&gt; n &gt;&gt; a; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; d[i] &gt;&gt; c[i], c[i] = a - c[i]; build(1, n, 1); for (int i = 1; i ^ n; ++i) del[i] = (d[i + 1] - d[i]) * (d[i + 1] - d[i]); stack&lt;int&gt; tmp; for (int i = 1; i ^ n; ++i) &#123; while (!tmp.empty() &amp;&amp; del[tmp.top()] &lt; del[i]) &#123; seg[tmp.top()].second = i; tmp.pop(); &#125; tmp.push(i); &#125; while (!tmp.empty()) &#123; seg[tmp.top()].second = n; tmp.pop(); &#125; for (int i = n - 1; i; --i) &#123; while (!tmp.empty() &amp;&amp; del[tmp.top()] &lt; del[i]) &#123; seg[tmp.top()].first = i + 1; tmp.pop(); &#125; tmp.push(i); &#125; while (!tmp.empty()) &#123; seg[tmp.top()].first = 1; tmp.pop(); &#125; long long res = 0; for (int i = 1; i &lt;= n; ++i) res = max(res, c[i]); for (int i = 1; i ^ n; ++i) res = max(res, query_right(seg[i].first, i, 1, n, 1) + query_left(i + 1, seg[i].second, 1, n, 1) - del[i]); cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"JOISC 2014 Day3 电压","slug":"JOISC 2014 Day3 电压","date":"2019-02-14T08:46:58.469Z","updated":"2019-02-14T09:28:07.987Z","comments":true,"path":"2019/02/14/JOISC 2014 Day3 电压/","link":"","permalink":"http://yoursite.com/2019/02/14/JOISC 2014 Day3 电压/","excerpt":"","text":"LOJ2881 题目大意给定一个$~N~$个点$~M~$条边的无自环但可能有重边不连通的图，问有多少条边满足：存在一种点的二染色，使得其余其它$~M-1~$条边的端点均被二染色，但该边为单染色。数据范围$~2\\leq N\\leq10^5,~1\\leq M\\leq2\\times10^5~$。 题解一条边满足题意当且仅当图中的所有奇环均包含该边且所有偶环均不包含该边。考虑$~\\text{DFS}~$生成树，记链为以树上某点和它某祖先的简单路劲。那么途中的所有环均由这棵$~\\text{DFS}~$树上的一条链和不在树上的一条边组成。这样树上满足题意的边为奇环链的交减去偶环链的并，树外若也有边满足题意当且仅当改图只有一个奇环链。链交和链并可以用两个树上差分解决。在$~\\text{DFS}~$过程中点$~u~$的相邻点$~v~$已经遍历过，且不是通过$~u~$的父亲遍历到$~u~$的那条边，那么$~v~$必为$~u~$的祖先或后代。若为祖先，则确定了一个环，通过$~u~$和$~v~$的深度可以确定环的奇偶性。如果是奇环，则在点$~u~$的链交差分数组上加$~1~$，在点$~v~$的链并差分数组上减$~1~$。那么最后在自下往上的遍历过程中展开差分，对于权值等于奇环链数量的点，它连向它父亲的边必在链交之中。同理对链并的差分数组同样操作，判断时对于正权值的点，它连向它父亲的边必在链并之中。这样最后的总复杂度为$~O(N+M)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;vector&lt;int&gt; adj[maxn];bool vis[maxn], check[maxn], use[maxn], flag;int dep[maxn], even[maxn], odd[maxn], cnt, tot, cal;void dfs1(int u, int p) &#123; vis[u] = true; for (auto v : adj[u]) &#123; if (vis[v]) &#123; if (v == p &amp;&amp; !check[u]) &#123; check[u] = true; continue; &#125; if (dep[u] &lt; dep[v]) continue; if ((dep[u] ^ dep[v]) &amp; 1) &#123; ++even[u]; --even[v]; &#125; else &#123; if (flag) exit((cout &lt;&lt; 0 &lt;&lt; endl, 0)); ++cnt; ++odd[u]; --odd[v]; &#125; &#125; else &#123; ++tot; dep[v] = dep[u] + 1; dfs1(v, u); &#125; &#125;&#125;void dfs2(int u) &#123; use[u] = true; for (auto v : adj[u]) if (!use[v]) &#123; dfs2(v); even[u] += even[v]; odd[u] += odd[v]; &#125; if (even[u]) --tot; else if (odd[u] == cnt) ++cal;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; int res; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; cnt = cal = 0; dfs1(i, 0); dfs2(i); if (cnt) &#123; flag = true; res = cal; if (cnt == 1) ++res; &#125; &#125; if (!flag) res = tot; cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"http://yoursite.com/categories/刷题笔记/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"DFS树","slug":"DFS树","permalink":"http://yoursite.com/tags/DFS树/"},{"name":"树上差分","slug":"树上差分","permalink":"http://yoursite.com/tags/树上差分/"}]},{"title":"Codeforces Round 536 (Div. 2)","slug":"Codeforces Round 536 (Div. 2)","date":"2019-02-13T16:33:05.954Z","updated":"2019-02-13T16:33:11.033Z","comments":true,"path":"2019/02/14/Codeforces Round 536 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/02/14/Codeforces Round 536 (Div. 2)/","excerpt":"","text":"Codeforces Round #536 (Div. 2) A. Lunar New Year and Cross Counting题目大意水题。 题解水题。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;char mat[1 &lt;&lt; 9][1 &lt;&lt; 9];int main() &#123; memset(mat, '.', sizeof (mat)); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) cin &gt;&gt; mat[i][j]; int res = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (mat[i][j] == 'X' &amp;&amp; mat[i - 1][j - 1] == 'X' &amp;&amp; mat[i - 1][j + 1] == 'X' &amp;&amp; mat[i + 1][j - 1] == 'X' &amp;&amp; mat[i + 1][j + 1] == 'X') ++res; cout &lt;&lt; res &lt;&lt; endl;&#125; B. Lunar New Year and Food Ordering题目大意餐厅有$~n~$种菜，库存为$~a_1,~a_2,~\\dots,~a_n~$，价格为$~c_1,~c_2,~\\dots,~c_n~$。依次来$~m~$个客人，第$~i~$个人会点$~d_i~$个$~t_i~$菜。一份份上菜，如果库存没有了$~t_i~$菜，则选择库存里最便宜的菜继续一份份上，即使最终无法上满$~d_i~$份也要继续上，上不满则客人不付钱。输出每个客人要付多少钱。数据范围$~1\\leq n\\leq10^5,~1\\leq m\\leq10^5~$。 题解对价格排序以后双指针模拟即可。时间复杂度$~O(n\\log n+m)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;long long&gt; c(n); vector&lt;int&gt; a(n), p(n); for (auto&amp; in : a) cin &gt;&gt; in; for (auto&amp; in : c) cin &gt;&gt; in; iota(p.begin(), p.end(), 0); sort(p.begin(), p.end(), [&amp;c] (int x, int y) &#123;return c[x] &lt; c[y];&#125;); int index = 0; while (m--) &#123; int t, d; cin &gt;&gt; t &gt;&gt; d; long long res = 0; if (a[--t] &lt; d) &#123; res += c[t] * a[t]; d -= a[t]; a[t] = 0; while (index ^ n &amp;&amp; a[p[index]] &lt; d) &#123; res += c[p[index]] * a[p[index]]; d -= a[p[index]]; a[p[index++]] = 0; &#125; if (index ^ n) &#123; res += c[p[index]] * d; a[p[index]] -= d; &#125; else &#123; res = 0; &#125; &#125; else &#123; a[t] -= d; res = c[t] * d; &#125; cout &lt;&lt; res &lt;&lt; '\\n'; &#125;&#125; C. Lunar New Year and Number Division题目大意给定偶数个数字，要求划分为若干组，每组至少$~2~$个。记$~s~$为一组的总和，输出最小的$~\\sum s^2~$。 题解贪心。每组$~2~$个共$~\\frac{n}{2}~$组。其中最大值和最小值一组，次大值和次小值一组，以此类推。正确性可用$~\\text{Jensen}~$不等书证明。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;long long&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; sort(a.begin(), a.end()); long long res = 0; for (int i = 0; i ^ n &gt;&gt; 1; ++i) res += (a[i] + a[n - 1 - i]) * (a[i] + a[n - 1 - i]); cout &lt;&lt; res &lt;&lt; endl;&#125; D. Lunar New Year and a Wander题目大意给定一个$~n~$个点简单连通通图。从$~1~$开始遍历所有的点，根据每个点第一次经过的顺序，可以得到一个$~1,~2,~\\dots,~n~$的全排列。输出字典序最小的全排列。 题解类似$~\\text{Dijstra}~$或$~\\text{Prim}~$的思想，每次取与当前联通快相邻的编号最小的点即可。 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;vector&lt;int&gt; adj[maxn];bool vis[maxn];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; set&lt;int&gt; que; que.insert(1); vector&lt;int&gt; res; while (!que.empty()) &#123; int now = *que.begin(); vis[now] = true; res.push_back(now); que.erase(now); for (auto next : adj[now]) if (!vis[next]) que.insert(next); &#125; cout &lt;&lt; res.front(); for (int i = 1; i ^ res.size(); ++i) cout &lt;&lt; ' ' &lt;&lt; res[i]; cout &lt;&lt; endl;&#125; E. Lunar New Year and Red Envelopes题目大意再$~[1,~n]~$时间段内有$~k~$个红包，每个红包的出现时间段为$~[s,~t]~$，大小为$~w~$。且如果抢了它，则在$~[s,~d]~$以内无法再抢红包，其中$~s\\leq t\\leq d~$。现在$~\\text{Bob}~$抢红包的策略是如果当前时刻可以抢则会去抢$~w~$最大的那个，如果有多个则去抢$~d~$最大的那个（这个操作没看懂）。然后$~\\text{Alice}~$可以令$~\\text{Bob}~$在最多$~m~$个时刻无法抢红包，问$~\\text{Bob}~$的最小收益。数据范围$~1\\leq n\\leq10^5,~1\\leq k\\leq10^5,~1\\leq m\\leq200~$。 题解首先处理$~\\text{Bob}~$在每个时刻如果能抢红包，他抢的红包所对应的$~w~$和$~d~$是多少。这一步扫描线可以完成，用$~\\text{multiset}~$维护当前时刻所有的红包，然后每个红包在$~s~$秒加入$~t+1~$秒移除。接下来就是个动态规划问题，记$~dp[i][j]~$表示$~\\text{Alice}~$已经打断了$~i~$次在$~j~$时刻的最小收益，具体转移见代码。其中$~[i]~$维度可以滚动优化，总时间复杂度为$~O((n+k)\\log k+mn)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;vector&lt;pair&lt;pair&lt;long long, int&gt;, bool&gt;&gt; sweep[maxn];pair&lt;long long, int&gt; red[maxn];long long dp0[maxn], dp1[maxn];int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; while (k--) &#123; int s, t, d; long long w; cin &gt;&gt; s &gt;&gt; t &gt;&gt; d &gt;&gt; w; sweep[s].push_back(make_pair(make_pair(w, d), true)); sweep[t + 1].push_back(make_pair(make_pair(w, d), false)); &#125; multiset&lt;pair&lt;long long, int&gt;&gt; line; for (int i = 1; i &lt;= n; ++i) &#123; for (auto&amp; now : sweep[i]) &#123; if (now.second) line.insert(now.first); else line.erase(line.find(now.first)); &#125; if (line.empty()) red[i] = make_pair(0, i); else red[i] = *line.rbegin(); &#125; long long res = 0x3f3f3f3f3f3f3f3f; ++m; memset(dp1, 0x3f, sizeof (dp1)); dp1[1] = 0; while (m--) &#123; memcpy(dp0, dp1, sizeof (dp0)); memset(dp1, 0x3f, sizeof (dp1)); for (int i = 1; i &lt;= n; ++i) &#123; dp0[red[i].second + 1] = min(dp0[red[i].second + 1], dp0[i] + red[i].first); dp1[i + 1] = min(dp1[i + 1], dp0[i]); &#125; res = min(res, dp0[n + 1]); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; F. Lunar New Year and a Recursive Sequence题目大意已知一个序列$~f~$的递推公式是 f_i=\\left(\\prod_{j=1}^{k}f_{i-j}^{b_j}\\right)\\mod(p=998244353)现给出$~b_1,~b_2,~\\dots,~b_k~$且$~f_1=f_2=\\dots=f_{k-1}=1,~f_n=m~$，求$~f_k~$。数据范围$~1\\leq k\\leq100,~k&lt; n\\leq10^9,~1\\leq m&lt; p=998244353~$。 题解赤裸裸的线性递推套$~N~$次剩余。在不考虑序列$~f~$的前$~k~$项时，对于任意$~f_i~$，存在唯一的一组$~\\beta_i=(b_{i1},~b_{i2},~\\dots,~b_{ik})~$满足$~f_i=\\prod_{j=1}^{k}f_j^{b_j}\\mod p~$。于是得到了一个$~k~$维线性空间内的一个线性序列$~\\beta~$。由费马小定理，可以对$~\\beta~$每个维度都取模$~p-1~$意义下的值。于是有$~N~$次剩余方程$~f_k^{b_{nk}}=m\\mod p~$。用$~\\text{BSGS}~$算法可在$~O(\\sqrt{p}\\log p)~$内解出。线性递推部分用矩阵快速幂即可打到要求，总时间复杂度为$~O(k^3\\log n+\\sqrt{p}\\log p)~$。或者用$~O(k^2\\log n)~$的线性递推倍增算法优化，总时间复杂度为$~O(k^2\\log n+\\sqrt{p}\\log p)~$。注意线性递推部分是取模$~p-1~$。倍增算法部分还可以用模非质数的$~\\text{NTT}~$优化，总时间复杂度为$~O(k\\log k\\log n+\\sqrt{p}\\log p)~$。 代码（$~O(k^3\\log n+\\sqrt{p}\\log p)~$）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int root = 3;int base[100][100], power[100][100], tmp[100][100];inline int sub(const int&amp; a, const int&amp; b, const int&amp; p = mod) &#123;return a &lt; b ? a - b + p : a - b;&#125;inline int add(const int&amp; a, const int&amp; b, const int&amp; p = mod) &#123;return sub(a, p - b, p);&#125;inline int mul(const int&amp; a, const int&amp; b, const int&amp; p = mod) &#123;return 1LL * a * b % p;&#125;inline int fpow(int a, int n) &#123; int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;int bsgs(int n, int m) &#123; int sqr = sqrt(mod + 0.1); int inv = fpow(n, mod - 2); map&lt;int, int&gt; baby; for (int i = 0; i ^ sqr; ++i) &#123; baby[m] = i; m = mul(m, inv); &#125; n = fpow(n, sqr); int now = 1; for (int i = 0; i &lt;= sqr + 1; ++i) &#123; auto ite = baby.find(now); if (ite != baby.end()) return i * sqr + ite-&gt;second; now = mul(now, n); &#125; return -1;&#125;int get_root(int p) &#123; vector&lt;int&gt; factors; for (int i = 2, x = p - 1; true; ++i) &#123; if (!(x % i)) &#123; factors.push_back(i); while (!(x % i)) x /= i; &#125; if (1LL * i * i &gt; x) &#123; if (x ^ 1) factors.push_back(x); break; &#125; &#125; for (int ret = 1; true; ++ret) &#123; bool flag = true; for (auto f : factors) if (fpow(ret, (p - 1) / f) == 1) &#123; flag = false; break; &#125; if (flag) return ret; &#125; return -1;&#125;int exgcd(int a, int b, long long&amp; x, long long&amp; y) &#123; if (b) &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; return a ? (x = 1, y = 0, a) : -1;&#125;int power_mod(int n, int m, int p) &#123; int root = get_root(p); int y = bsgs(root, m); long long s = 0, t = 0; int d = exgcd(n, p - 1, s, t); if (y % d) return -1; if (s &lt; 0) s = s * y / d % (p - 1) * (2 - p) % (p - 1); else s = s * y / d % (p - 1); return fpow(root, s);&#125;void mul(int C[][100], int A[][100], int B[][100], int size) &#123; for (int i = 0; i ^ size; ++i) for (int j = 0; j ^ size; ++j) &#123; C[i][j] = 0; for (int k = 0; k ^ size; ++k) C[i][j] = add(C[i][j], mul(A[i][k], B[k][j], mod - 1), mod - 1); &#125;&#125;int main() &#123; int k, n, m; cin &gt;&gt; k; for (int i = 0; i ^ k; ++i) cin &gt;&gt; base[0][i], power[i][i] = 1; for (int i = 1; i ^ k; ++i) base[i][i - 1] = 1; cin &gt;&gt; n &gt;&gt; m; for (int t = n - k; t; t &gt;&gt;= 1) &#123; if (t &amp; 1) &#123; mul(tmp, power, base, k); memcpy(power, tmp, sizeof (power)); &#125; mul(tmp, base, base, k); memcpy(base, tmp, sizeof (base)); &#125; cout &lt;&lt; power_mod(power[0][0], m, mod) &lt;&lt; endl;&#125; 代码（$~O(k^2\\log n+\\sqrt{p}\\log p)~$）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;namespace BM &#123; typedef vector&lt;int&gt; vi; const int mod = 998244352; inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125; inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125; inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125; vi bm(vi&amp; c, long long n) &#123; int size = c.size(); if (size == 1) &#123; int ret = 1; for (int a = c.front(); n; n &gt;&gt;= 1) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); &#125; return vi(1, ret); &#125; vector&lt;vi&gt; base(size &lt;&lt; 1, vi(size, 0)), pow(64, vi(size, 0)); base[0][0] = 1; for (int i = 1; i ^ size &lt;&lt; 1; ++i) for (int j = 0; j ^ size; ++j) base[i][j] = add(mul(base[i - 1].back(), c[j]), j ? base[i - 1][j - 1] : 0); if (n &lt; (size &lt;&lt; 1)) return base[n]; pow[0][1] = 1; for (int i = 1; i ^ 64; ++i) &#123; vi tmp(size &lt;&lt; 1, 0); for (int j = 0; j ^ size; ++j) for (int k = 0; k ^ size; ++k) tmp[j + k] = add(tmp[j + k], mul(pow[i - 1][j], pow[i - 1][k])); for (int j = 0; j ^ size &lt;&lt; 1; ++j) for (int k = 0; k ^ size; ++k) pow[i][k] = add(pow[i][k], mul(tmp[j], base[j][k])); &#125; int index = 62; while ((1LL &lt;&lt; index) &gt; n) --index; vi ret = pow[index]; n ^= 1LL &lt;&lt; index; while (n) &#123; while ((1LL &lt;&lt; index) &gt; n) --index; n ^= 1LL &lt;&lt; index; vi tmp(size &lt;&lt; 1, 0); for (int i = 0; i ^ size; ++i) for (int j = 0; j ^ size; ++j) tmp[i + j] = add(tmp[i + j], mul(ret[i], pow[index][j])); fill(ret.begin(), ret.end(), 0); for (int i = 0; i ^ size &lt;&lt; 1; ++i) for (int j = 0; j ^ size; ++j) ret[j] = add(ret[j], mul(tmp[i], base[i][j])); &#125; return ret; &#125;&#125;const int mod = 998244353;const int root = 3;int base[100][100], power[100][100], tmp[100][100];inline int sub(const int&amp; a, const int&amp; b, const int&amp; p = mod) &#123;return a &lt; b ? a - b + p : a - b;&#125;inline int add(const int&amp; a, const int&amp; b, const int&amp; p = mod) &#123;return sub(a, p - b, p);&#125;inline int mul(const int&amp; a, const int&amp; b, const int&amp; p = mod) &#123;return 1LL * a * b % p;&#125;inline int fpow(int a, int n) &#123; int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;int bsgs(int n, int m) &#123; int sqr = sqrt(mod + 0.1); int inv = fpow(n, mod - 2); map&lt;int, int&gt; baby; for (int i = 0; i ^ sqr; ++i) &#123; baby[m] = i; m = mul(m, inv); &#125; n = fpow(n, sqr); int now = 1; for (int i = 0; i &lt;= sqr + 1; ++i) &#123; auto ite = baby.find(now); if (ite != baby.end()) return i * sqr + ite-&gt;second; now = mul(now, n); &#125; return -1;&#125;int get_root(int p) &#123; vector&lt;int&gt; factors; for (int i = 2, x = p - 1; true; ++i) &#123; if (!(x % i)) &#123; factors.push_back(i); while (!(x % i)) x /= i; &#125; if (1LL * i * i &gt; x) &#123; if (x ^ 1) factors.push_back(x); break; &#125; &#125; for (int ret = 1; true; ++ret) &#123; bool flag = true; for (auto f : factors) if (fpow(ret, (p - 1) / f) == 1) &#123; flag = false; break; &#125; if (flag) return ret; &#125; return -1;&#125;int exgcd(int a, int b, long long&amp; x, long long&amp; y) &#123; if (b) &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; return a ? (x = 1, y = 0, a) : -1;&#125;int power_mod(int n, int m, int p) &#123; int root = get_root(p); int y = bsgs(root, m); long long s = 0, t = 0; int d = exgcd(n, p - 1, s, t); if (y % d) return -1; if (s &lt; 0) s = s * y / d % (p - 1) * (2 - p) % (p - 1); else s = s * y / d % (p - 1); return fpow(root, s);&#125;void mul(int C[][100], int A[][100], int B[][100], int size) &#123; for (int i = 0; i ^ size; ++i) for (int j = 0; j ^ size; ++j) &#123; C[i][j] = 0; for (int k = 0; k ^ size; ++k) C[i][j] = add(C[i][j], mul(A[i][k], B[k][j], mod - 1), mod - 1); &#125;&#125;int main() &#123; int k, n, m; cin &gt;&gt; k; for (int i = 0; i ^ k; ++i) cin &gt;&gt; base[0][i], power[i][i] = 1; vector&lt;int&gt; vec; for (int i = k - 1; ~i; --i) vec.push_back(base[0][i]); for (int i = 1; i ^ k; ++i) base[i][i - 1] = 1; cin &gt;&gt; n &gt;&gt; m; vec = BM::bm(vec, n - 1); cout &lt;&lt; power_mod(vec.back(), m, mod) &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 534 (Div. 2)","slug":"Codeforces Round 534 (Div. 2)","date":"2019-02-13T15:11:35.224Z","updated":"2019-02-13T15:11:42.876Z","comments":true,"path":"2019/02/13/Codeforces Round 534 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/02/13/Codeforces Round 534 (Div. 2)/","excerpt":"","text":"Codeforces Round #534 (Div. 2) A. Splitting into digits题目大意水题。 题解水题。 代码12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; n &lt;&lt; endl; while (--n) cout &lt;&lt; 1 &lt;&lt; ' '; cout &lt;&lt; 1 &lt;&lt; endl;&#125; B. Game with string题目大意类似祖玛，两人轮流选择两个一样的相邻字符从字符串中消除，不能操作则失败。 题解模拟。一个字符串的可操作次数是固定的且与操作顺序无关。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; vector&lt;char&gt; chs; int cnt = 0; for (auto ch : str) &#123; if (!chs.empty() &amp;&amp; chs.back() == ch) &#123; ++cnt; chs.pop_back(); &#125; else &#123; chs.push_back(ch); &#125; &#125; if (cnt &amp; 1) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;&#125; C. Grid game题目大意一个$~4\\times4~$的大正方形内要放入若干$~1\\times2~$和$~2\\times1~$的小长方形，不能重叠，但是如果某行或者某列被占满则改行或者该列被清空。现给出小长方形的出现顺序，输出一种可行的放置方案。 题解前$~2~$排专门放竖的，第$~3~$排专门放横的即可。 代码12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; int a = 1, b = 1; for (auto ch : str) &#123; if (ch == '0') &#123; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; a++ &lt;&lt; endl; if (a == 5) a = 1; &#125; else &#123; cout &lt;&lt; 3 &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl; if (b == 1) b = 3; else b = 1; &#125; &#125;&#125; D. Game with modulo题目大意交互题。有个未知数$~a~$，每次只能询问一对数$~(x,~y)~$，如果在模$~a~$意义下满足$~x\\geq y~$，则返回$~x~$，否则返回$~y~$。在至多$~60~$次查询内确定$~a~$的大小。数据范围$~1\\leq a\\leq10^9~$。 题解倍增。如果有$~a&gt;x~$，则通过询问$~(x,~2x)~$得到$~a~$与$~2x~$的大小关系。所以在$~30~$次询问内，可以确认$~a=1~$或者$~a\\in(2^i,~2^{i+1}],~i\\in[0,~30)~$。对于$~a\\in(x,~y]~$，运用同样的思想，询问$~(x,~\\frac{x+y}{2})~$，可以确认$~a~$与$~\\frac{x+y}{2}~$的关系。于是再用至多$~30~$次询问即可得出答案。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;inline bool game() &#123; string str; cin &gt;&gt; str; return str == \"start\";&#125;inline bool query(const int&amp; x, const int&amp; y) &#123; cout &lt;&lt; \"? \" &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; char ch; cin &gt;&gt; ch; return ch == 'y';&#125;inline void solve(const int&amp; res) &#123;cout &lt;&lt; \"! \" &lt;&lt; res &lt;&lt; endl;&#125;int main() &#123; while (game()) &#123; int now = 1; while (query(now, now &lt;&lt; 1)) now &lt;&lt;= 1; if (now == 1) &#123; solve(query(2, 3) ? 2 : 1); continue; &#125; int left = now, right = now &lt;&lt; 1; while (right - left ^ 1) &#123; int mid = left + right &gt;&gt; 1; if (query(left, mid)) left = mid; else right = mid; &#125; solve(right); &#125;&#125; E. Johnny Solving题目大意给定一个$~n~$个点的简单连通图，且每个点的度数至少为$~3~$。再给出一个不大于$~n~$的正整数$~k~$。要求输出一条长度不小于$~\\frac{n}{k}~$的简单路径或者$~k~$个长度不是$~3~$的倍数的环，且每个环有个代表点，代表点不能再其他环内。 题解考虑$~\\text{DFS}~$生成树。如果有点的深度不小于$~\\frac{n}{k}~$，那么可以直接构造出简单路径。否则这棵树必有至少$~k~$个叶节点。考虑每个叶节点，由于每个点的度数至少为$~3~$且根据$~\\text{DFS}~$生成树的性质，这个叶节点必有至少$~2~$条边连向不同的非父亲祖先。这样每个叶节点可以找到$~3~$个环，可以自行证明必存在长度不是$~3~$的倍数的环。此时该叶节点也满足代表元性质，构造完毕。所有过程均为线性，不过我的代码不知道为什么不加剪枝会$~\\text{TLE}~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 18;vector&lt;int&gt; adj[maxn];bool vis[maxn];int fa[maxn], dep[maxn], n, m, k;vector&lt;vector&lt;int&gt;&gt; cycles;void dfs(int u, int d) &#123; vis[u] = true; if ((dep[u] = d) &gt; (n - 1) / k) &#123; cout &lt;&lt; \"PATH\\n\" &lt;&lt; d &lt;&lt; '\\n' &lt;&lt; u; for (int i = fa[u]; i; i = fa[i]) cout &lt;&lt; ' ' &lt;&lt; i; cout &lt;&lt; '\\n'; exit(0); &#125; bool flag = true; for (auto v : adj[u]) if (!vis[v]) &#123; fa[v] = u; dfs(v, d + 1); flag = false; &#125; while (flag) &#123; int index = 0; if (adj[u][index] == fa[u]) ++index; int x = adj[u][index++]; if (adj[u][index] == fa[u]) ++index; int y = adj[u][index]; vector&lt;int&gt; loop(1, u); while (loop.back() ^ x) loop.push_back(fa[loop.back()]); if (loop.size() % 3) &#123; cycles.push_back(loop); break; &#125; loop = vector&lt;int&gt;(1, u); while (loop.back() ^ y) loop.push_back(fa[loop.back()]); if (loop.size() % 3) &#123; cycles.push_back(loop); break; &#125; loop = vector&lt;int&gt;(1, u); if (dep[x] &lt; dep[y]) swap(x, y); loop.push_back(x); while (loop.back() ^ y) loop.push_back(fa[loop.back()]); cycles.push_back(loop); break; &#125; if (cycles.size() == k) &#123; cout &lt;&lt; \"CYCLES\\n\"; for (auto&amp; loop : cycles) &#123; cout &lt;&lt; loop.size() &lt;&lt; '\\n' &lt;&lt; loop.front(); for (int i = 1; i ^ loop.size(); ++i) cout &lt;&lt; ' ' &lt;&lt; loop[i]; cout &lt;&lt; '\\n'; &#125; exit(0); &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; dfs(1, 1);&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"CodeCraft-19 and Codeforces Round 537 (Div. 2)","slug":"CodeCraft-19 and Codeforces Round 537 (Div. 2)","date":"2019-02-11T13:15:42.885Z","updated":"2019-02-13T14:27:29.256Z","comments":true,"path":"2019/02/11/CodeCraft-19 and Codeforces Round 537 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/02/11/CodeCraft-19 and Codeforces Round 537 (Div. 2)/","excerpt":"","text":"CodeCraft-19 and Codeforces Round #537 (Div. 2) A. Superhero Transformation题目大意水题。 题解水题。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int check[128] = &#123;0&#125;; check['a'] = check['e'] = check['i'] = check['o'] = check['u'] = 1; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; if (s1.size() ^ s2.size()) return cout &lt;&lt; \"No\" &lt;&lt; endl, 0; for (int i = 0; i ^ s1.size(); ++i) if (check[s1[i]] ^ check[s2[i]]) return cout &lt;&lt; \"No\" &lt;&lt; endl, 0; cout &lt;&lt; \"Yes\" &lt;&lt; endl;&#125; B. Average Superhero Gang Power题目大意给顶一个序列，最多可以操作$~k~$次，或者移除一个元素，或者是一个元素加$~1~$，且每个元素至多操作$~m~$次。输出该序列最后平均数的最大值。 题解水题。排序后暴力枚举移除操作的次数即可。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;long long a[maxn], pre[maxn];int main() &#123; int n, k, m; scanf(\"%d%d%d\", &amp;n, &amp;k, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); sort(a, a + n + 1); for (int i = 1; i &lt;= n; ++i) pre[i] = pre[i - 1] + a[i]; double res = 0; for (int i = 0; i ^ min(n, m + 1); ++i) res = max(res, 1.0 * (pre[n] - pre[i] + min(1LL * (n - i) * k, 1LL * (m - i))) / (n - i)); printf(\"%f\\n\", res);&#125; C. Creative Snap题目大意需要处理一整段长度为$~2^n~$的数轴，数轴上有$~k~$个物品。对于每个区间可以选择二等分后分别处理或者直接处理。处理区间时，如果区间上有物品，则需要花费$~B\\cdot n_a\\cdot l$，其中$~n_a~$和$~l~$分别是该区间物品数量和长度。否则处理空区间的花费为$~A~$。问最小总花费。数据范围$~1\\leq n\\leq30,~1\\leq k\\leq10^5~$。 题解直接根据题意递归处理即可。考虑一棵完整的线段树，它有$~2^{n+1}~$个节点。但是注意到对于空区间的节点，其子树是不需要考虑的。且最后一层只有$~k~$个非空节点，所以所有需要经过的节点是$~O(nk)~$级别的。对于区间内的数量，可以用$~\\text{lower_bound}~$或$~\\text{upper_bound}~$来计算，总时间复杂度为$~O(nk\\log k)~$。当然你想写线段树动态开点也不是不可以。 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int n, k;long long A, B;vector&lt;int&gt; a;long long solve(int begin, int end) &#123; int size = upper_bound(a.begin(), a.end(), end) - upper_bound(a.begin(), a.end(), begin); if (!size) return A; long long ret = B * size * (end - begin); if (begin + 1 ^ end) ret = min(ret, solve(begin, begin + end &gt;&gt; 1) + solve(begin + end &gt;&gt; 1, end)); return ret;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k &gt;&gt; A &gt;&gt; B; a.resize(k); for (auto&amp; in : a) cin &gt;&gt; in; sort(a.begin(), a.end()); cout &lt;&lt; solve(0, 1 &lt;&lt; n) &lt;&lt; endl;&#125; D. Destroy the Colony题目大意给定一个偶数长度的大小写字符串和$~q~$次询问。每次询问输出有多少种字符串的重排列满足所有一样的字母在同侧且$~x~$和$~y~$位置上的字母也在同侧。数据范围$~1\\leq n\\leq10^5,~1\\leq q\\leq10^5~$。 题解先考虑存在性，则存在一种字母的二划分使得每个划分下的数量总和均为$~\\frac{n}{2}~$。设划分为 \\{a_1,~a_2,~\\dots,~a_k\\}=\\{b_1,~b_2,~\\dots,~b_s,~c_1,~c_2,~\\dots,~c_t\\} \\\\ \\sum_{i=1}^{s}b_i=\\sum_{i=1}^{t}c_i={\\frac{n}{2}}那么这种满足这种划分的重排列数量为 \\frac{(\\frac{n}{2})!}{\\prod_{i=1}^{s}(b_i)!}\\cdot\\frac{(\\frac{n}{2})!}{\\prod_{i=1}^{t}(c_i)!}=\\frac{((\\frac{n}{2})!)^2}{\\prod_{i=1}^{k}(a_i)!}那么只需要考虑有多少种合法的划分方案。注意到最多只有$~52~$种不一样的字母，即$~k\\leq52~$。那么可以用一个$~O(nk)~$的动态规划来算出对于任意$~0\\leq i\\leq n~$，有多少种子集的和为$~i~$。最后考虑询问，这相当于把某对$~a_i~$和$~a_j~$合并后计算，共$~\\binom{k}{2}~$种组合如果每种情况分别动态规划，预处理的时间复杂度为$~O(nk^3)~$，显然会$~\\text{TLE}~$。注意到每次动态规划的元素大部分是相同的，于是可以考虑可持久化动态规划的做法，在基于$~{a_1,~a_2,~\\dots,~a_k}~$的基础上删除$~a_i~$和$~a_j~$。这样每种组合的动态规划时间复杂度为$~O(n)~$，总时间复杂度为$~O(nk^2+q)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;int inv[maxn], fact[maxn], finv[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;void init(int n = maxn) &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ n; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125;&#125;int main() &#123; init(); string str; cin &gt;&gt; str; int size = str.size(); map&lt;char, int&gt; cnt; for (auto ch : str) ++cnt[ch]; vector&lt;int&gt; a, p(128, -1), dp(size + 1, 0); for (auto now : cnt) &#123; p[now.first] = a.size(); a.push_back(now.second); &#125; int base = mul(fact[size &gt;&gt; 1], fact[size &gt;&gt; 1]); dp[0] = 1; for (auto x : a) &#123; base = mul(base, finv[x]); for (int i = size; i &gt;= x; --i) dp[i] = add(dp[i], dp[i - x]); &#125; int res = mul(dp[size &gt;&gt; 1], base); int cal[52][52]; for (int i = 0; i ^ a.size(); ++i) for (int j = i + 1; j ^ a.size(); ++j) &#123; for (int k = a[i]; k &lt;= size; ++k) dp[k] = sub(dp[k], dp[k - a[i]]); for (int k = a[j]; k &lt;= size; ++k) dp[k] = sub(dp[k], dp[k - a[j]]); cal[i][j] = mul(add(dp[size &gt;&gt; 1], dp[size &gt;&gt; 1]), base); for (int k = size; k &gt;= a[i]; --k) dp[k] = add(dp[k], dp[k - a[i]]); for (int k = size; k &gt;= a[j]; --k) dp[k] = add(dp[k], dp[k - a[j]]); &#125; int q; cin &gt;&gt; q; while (q--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; x = p[str[x - 1]]; y = p[str[y - 1]]; if (x &gt; y) swap(x, y); if (x == y) cout &lt;&lt; res &lt;&lt; endl; else cout &lt;&lt; cal[x][y] &lt;&lt; endl; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 538 (Div. 2)","slug":"Codeforces Round 538 (Div. 2)","date":"2019-02-11T11:49:37.328Z","updated":"2019-02-13T14:25:30.110Z","comments":true,"path":"2019/02/11/Codeforces Round 538 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/02/11/Codeforces Round 538 (Div. 2)/","excerpt":"","text":"Codeforces Round #538 (Div. 2) A. Got Any Grapes?题目大意水题。 题解水题。 代码123456789#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int x, y, z, a, b, c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (a &lt; x || a + b &lt; x + y || a + b + c &lt; x + y + z) cout &lt;&lt; \"NO\" &lt;&lt; endl; else cout &lt;&lt; \"YES\" &lt;&lt; endl;&#125; B. Yet Another Array Partitioning Task题目大意定义一个序列的$~\\text{beauty}~$值为前$~m~$大的数值之和。现给定一个大序列，要求划分成$~k~$个连续的序列使得这$~k~$个序列的$~\\text{beauty}~$值总和最大，并输出划分的方案。 题解水题。原序列前$~mk~$大的数值之和就是最大值。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; vector&lt;pair&lt;int, int&gt;&gt; a(n); vector&lt;bool&gt; use(n); for (int i = 0; i ^ n; ++i) cin &gt;&gt; a[i].first, a[i].second = i; sort(a.begin(), a.end()); long long res = 0; for (int i = n - m * k; i ^ n; ++i) res += a[i].first, use[a[i].second] = true; int cnt = 0, tot = 0; cout &lt;&lt; res &lt;&lt; endl; for (int i = 0; i ^ n; ++i) if (use[i] &amp;&amp; ++cnt == m) &#123; cnt = 0; if (++tot == k) cout &lt;&lt; endl; else cout &lt;&lt; i + 1 &lt;&lt; ' '; &#125;&#125; C. Trailing Loves (or L’oeufs?)题目大意问数字$~n!~$在$~b~$进制下有多少个末尾$~0~$。 题解因式分解$~b~$后对所有质数计算$~n!~$中的幂指数。公式 f(n,~p)=\\sum_{i=1}^{\\infty}\\left\\lfloor\\frac{n}{p^i}\\right\\rfloor代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; long long n, b; cin &gt;&gt; n &gt;&gt; b; vector&lt;pair&lt;long long, int&gt;&gt; factors; for (long long p = 2; true; ++p) &#123; if (!(b % p)) &#123; int cnt; for (cnt = 0; !(b % p); ++cnt) b /= p; factors.push_back(make_pair(p, cnt)); &#125; if (p * p &gt; b) &#123; if (b ^ 1) factors.push_back(make_pair(b, 1)); break; &#125; &#125; long long res = 0x7fffffffffffffff; for (auto f : factors) &#123; long long temp = 0; for (long long x = n; x; x /= f.first) temp += x / f.first; res = min(res, temp / f.second); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. Flood Fill题目大意给定一个序列，选择一个起点，每次操作可以将包含起点的等值联通块全部改变为另一数值。问最少操作次数使得序列全部一样。数据范围$~1\\leq n\\leq5000~$。 题解首先对相邻等值的元素去重，于是每次操作可以使得包含起点的等值联通块大小增加$~1~$或者$~2~$。如果能增加$~2~$，说明存在$~2~$个一样的元素在起点的左右。于是只要找到最长回文子序列即可，这是一个区间$~\\text{DP}~$问题，具体实现见代码。时间复杂度为$~O(n^2)~$。 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; str; while (n--) &#123; int c; cin &gt;&gt; c; if (str.empty() || str.back() ^ c) str.push_back(c); &#125; int size = str.size(); vector&lt;vector&lt;int&gt;&gt; dp(size, vector&lt;int&gt;(size, 1)); for (int d = 2; d &lt; size; ++d) for (int l = 0; l + d ^ size; ++l) &#123; if (str[l] ^ str[l + d]) dp[l][l + d] = max(dp[l][l + d - 1], dp[l + 1][l + d]); else dp[l][l + d] = dp[l + 1][l + d - 1] + 2; &#125; cout &lt;&lt; size - 1 - (dp[0][size - 1] &gt;&gt; 1) &lt;&lt; endl;&#125; E. Arithmetic Progression题目大意交互题。现有一个乱序的等差数列，可以有两种询问：问是否存在一个数严格大于$~x~$，或者问第$~i~$个数的值。询问次数不超过$~60~$次，然后输出首项和公差。数据范围$~2\\leq n\\leq10^6~$。 题解通过二分可以在$~30~$次询问内找出最大值也就是末项。然后随机询问$~30~$个数值后与末项的差取$~\\gcd~$。算出的答案为真实的公差的概率等于$~n~$以内随机$~30~$个数互质的概率。注意代码实现尽量接近真正的随机，详见博客链接。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;mt19937 rand_fuck(chrono::steady_clock::now().time_since_epoch().count());int main() &#123; int n; cin &gt;&gt; n; int left = 0, right = 1e9, rem = 60; while (right - left ^ 1) &#123; --rem; int mid = left + right &gt;&gt; 1; cout &lt;&lt; \"&gt; \" &lt;&lt; mid &lt;&lt; endl; int in; cin &gt;&gt; in; if (in) left = mid; else right = mid; &#125; vector&lt;int&gt; p(n); iota(p.begin(), p.end(), 1); shuffle(p.begin(), p.end(), rand_fuck); rem = min(rem, n); int d = 0; for (int i = 0; i ^ rem; ++i) &#123; cout &lt;&lt; \"? \" &lt;&lt; p[i] &lt;&lt; endl; int in; cin &gt;&gt; in; d = __gcd(d, right - in); &#125; cout &lt;&lt; \"! \" &lt;&lt; right - (n - 1) * d &lt;&lt; ' ' &lt;&lt; d &lt;&lt; endl;&#125; F. Please, another Queries on Array?题目大意对序列区间乘以$~x~$或查询区间乘积的欧拉函数值。数据范围$~1\\leq n\\leq4\\cdot10^5,~1\\leq q\\leq2\\cdot10^5,~1\\leq a\\leq300,~1\\leq x\\leq300~$。 题解欧拉函数$~\\varphi(n)~$的定义为小于$~n~$且与$~n~$互质的正整数的数量，是个积性函数。对于$~n~$的所有质因子$~p~$，有如下公式 \\varphi(n)=n\\prod_{p\\mid n}\\frac{p-1}{p}对于乘积的操作可以用一棵区间乘法线段树完成，建树的时间复杂度为$~O(n)~$，单次修改操作或查询的时间复杂度为$~O(\\log^2n)~$。注意到$~x~$和$~a~$的数据范围，可以先预处理出所有可能的质数，事实上只有至多$~62~$个质数。那么对于线段树上的每一个节点，可以用一个$~64~$位的数据类型来储存状态压缩过后的质因子表。总时间复杂度为$~O(n+q\\cdot(\\log^2n+62))~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int fpow(int a, int n) &#123; int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;const int maxn = 1 &lt;&lt; 19;int a[maxn], euler[maxn];long long prime[301], mask;struct Node &#123; int cal, cal_; long long mask, mask_; void tage(const int&amp; x, const long long&amp; p) &#123; cal_ = mul(cal_, x); mask_ |= p; &#125; void calc(const int&amp; n) &#123; cal = mul(cal, fpow(cal_, n)); mask |= mask_; cal_ = 1; mask_ = 0; &#125;&#125; seg[maxn &lt;&lt; 1];#define lson (index &lt;&lt; 1)#define rson (index &lt;&lt; 1 ^ 1)#define mid (begin + end &gt;&gt; 1)void build(int begin, int end, int index) &#123; if (begin ^ mid) &#123; build(begin, mid, lson); build(mid, end, rson); seg[index].cal = mul(seg[lson].cal, seg[rson].cal); seg[index].mask = seg[lson].mask | seg[rson].mask; &#125; else &#123; seg[index].mask = prime[seg[index].cal = a[end]]; &#125; seg[index].cal_ = 1;&#125;void modify(int begin, int end, int index, int left, int right, int x) &#123; if (begin &gt;= left &amp;&amp; end &lt;= right) &#123; seg[index].tage(x, prime[x]); return; &#125; else &#123; seg[index].cal = mul(seg[index].cal, fpow(x, min(end, right) - max(begin, left))); seg[index].mask |= prime[x]; &#125; if (left &lt; mid) modify(begin, mid, lson, left, right, x); if (right &gt; mid) modify(mid, end, rson, left, right, x);&#125;int query(int begin, int end, int index, int left, int right) &#123; if (seg[index].mask_) &#123; if (begin ^ mid) &#123; seg[lson].tage(seg[index].cal_, seg[index].mask_); seg[rson].tage(seg[index].cal_, seg[index].mask_); &#125; seg[index].calc(end - begin); &#125; if (begin &gt;= left &amp;&amp; end &lt;= right) return mask |= seg[index].mask, seg[index].cal; if (end &lt;= left || begin &gt;= right) return 1; return mul(query(begin, mid, lson, left, right), query(mid, end, rson, left, right));&#125;int main() &#123; for (int i = 2, cnt = 0; i &lt;= 300; ++i) if (!prime[i]) &#123; for (int j = i; j &lt;= 300; j += i) prime[j] ^= 1LL &lt;&lt; cnt; euler[cnt++] = mul(i - 1, fpow(i, mod - 2)); &#125; int n, q; cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; build(0, n, 1); while (q--) &#123; string str; cin &gt;&gt; str; if (str.front() == 'M') &#123; int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; modify(0, n, 1, l - 1, r, x); &#125; else &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; mask = 0; int res = query(0, n, 1, l - 1, r); for (int i = 0; i ^ 62; ++i) if (mask &amp; 1LL &lt;&lt; i) res = mul(res, euler[i]); cout &lt;&lt; res &lt;&lt; '\\n'; &#125; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"最长单调子序列","slug":"最长单调子序列","date":"2019-01-18T06:48:52.987Z","updated":"2019-05-10T03:59:59.495Z","comments":true,"path":"2019/01/18/最长单调子序列/","link":"","permalink":"http://yoursite.com/2019/01/18/最长单调子序列/","excerpt":"","text":"最长上升子序列$~\\text{LIS}~$朴素算法动态规划，令$~dp_i~$表示以$~a_i~$结尾的$~\\text{LIS}~$的长度，则有状态转移式 dp_i=\\max\\lbrace~dp_j:~j< i,~a_j< a_i~\\rbrace+1这样的时间复杂度显然是$~O(n^2)~$。 123456789template&lt;typename T&gt;size_t lis(const vector&lt;T&gt;&amp; a) &#123; vector&lt;size_t&gt; dp(a.size()); for (size_t i = 0; i != a.size(); ++i) &#123; for (size_t j = 0; j != i; ++j) if (a[i] &gt;= a[j]) dp[i] = max(dp[i], dp[j]); ++dp[i]; &#125; return *max_element(dp.begin(), dp.end());&#125; 优化算法考虑集合$~S_k=\\lbrace~i:~dp_i=k~\\rbrace~$，它有这样的性质：对任意$~i\\neq j\\in S_k~$，如果$~i&lt; j~$，则必有$~a_i\\geq a_j~$。这是因为如果$~a_i&lt; a_j~$，那么$~dp_j\\geq dp_i+1~$，得出$~j\\not\\in S_k~$矛盾。设$~p_k=\\max S_k~$，这里规定如果$~S_k=\\varnothing~$，则$~p_k~$不存在。这样的序列$~p~$也有性质：对任意$~p_i,p_j~$存在，如果$~i&lt; j~$，则必有$~a_{p_i}&lt; a_{p_j}~$。考虑$~p_j\\in S_j~$，于是有前缀$~a_1,a_2,\\dots,a_{p_j}~$以$~a_{p_j}~$结尾的$~\\text{LIS}~$的长度为$~j~$。设这个$~\\text{LIS}~$的第$~i~$项的角标为$~q~$，显然$~q\\in S_i~$。于是$~p_i=\\max S_i\\geq q~$，结合之前的性质有$~a_{p_i}\\leq a_q&lt; a_{p_j}~$。考虑动态规划同时维护序列$~p~$，于是在状态转移的过程中，由前面第一个性质，只需要考虑$~dp_i~$从$~dp_{p_1},dp_{p_2},\\dots,dp_{p_k}~$转移。注意到第二个性质的单调性，可以通过二分找到$~p_j~$，满足$~a_{p_j}&lt; a_i~$，且$~j=k~$或$~a_{p_{j+1}}\\geq a_i~$。然后用$~i~$更新$~p_{j+1}~$。可以发现根本不需要维护$~dp~$，只需要维护$~p~$即可，最后序列$~p~$的长度就是$~\\text{LIS}~$的长度。因为二分，时间复杂度为$~O(n\\log n)~$。 1234567891011template&lt;typename T&gt;auto lis(const vector&lt;T&gt;&amp; a) &#123; vector&lt;size_t&gt; p; for (size_t i = 0; i != a.size(); ++i) &#123; auto cmp = [&amp;a] (const size_t&amp; x, const size_t&amp; y) &#123; return a[x] &lt; a[y]; &#125;; auto ite = lower_bound(p.begin(), p.end(), i, cmp); if (ite == p.end()) p.emplace_back(i); else *ite = i; &#125; return p.size();&#125; 对每次转移记忆化，可以得到一个$~\\text{LIS}~$的角标。 1234567891011121314151617template&lt;typename T&gt;auto lis(const vector&lt;T&gt;&amp; a) &#123; vector&lt;size_t&gt; p, from(a.size()), ret; if (a.empty()) return ret; for (size_t i = 0; i != a.size(); ++i) &#123; auto cmp = [&amp;a] (const size_t&amp; x, const size_t&amp; y) &#123; return a[x] &lt; a[y]; &#125;; auto ite = lower_bound(p.begin(), p.end(), i, cmp); if (ite == p.begin()) from[i] = -1; else from[i] = *prev(ite); if (ite == p.end()) p.emplace_back(i); else *ite = i; &#125; ret.emplace_back(p.back()); while (~from[ret.back()]) ret.emplace_back(from[ret.back()]); reverse(ret.begin(), ret.end()); return ret;&#125; Dilworth定理序列$~a_1,a_2,\\dots,a_n~$的不增子序列最小划分数等于最长上升子序列长度。 证明设序列$~a~$的不增子序列最小划分数为$~k~$，最长上升子序列长度为$~m~$。任取一条最长上升子序列$~b_1,~b_2,~\\dots,~b_m~$，则它们之中任意两个必然不在同一不增子序列划分中，所以必有$~k\\geq m~$。下面构造$~a~$的不增子序列$~m~$划分。在计算$~m~$的过程中，序列$~p~$的每一次更新都必然满足$~p_j~$不存在或者$~a_{p_j}\\geq a_i~$，那么$~p_j~$的更新链恰好构成$~a~$的一条不增子序列。而$~{\\mid p\\mid}=m~$，也就是说$~p~$有$~m~$条不交的更新链，它们恰好构成$~a~$的一个不增子序列$~m~$划分。于是$~k=m~$。 模板用角标记录，返回最长严格单增子序列和非严格单减子序列划分。 12345678910111213141516171819template&lt;typename T&gt;auto exlis(const vector&lt;T&gt;&amp; a) &#123; vector&lt;size_t&gt; from(a.size()), lis; vector&lt;vector&lt;size_t&gt;&gt; snisp; for (size_t i = 0; i != a.size(); ++i) &#123; auto cmp = [&amp;a] (const vector&lt;size_t&gt;&amp; x, const vector&lt;size_t&gt;&amp; y) &#123; return a[x.back()] &lt; a[y.back()]; &#125;; auto ite = lower_bound(snisp.begin(), snisp.end(), vector&lt;size_t&gt;(1, i), cmp); if (ite == snisp.begin()) from[i] = -1; else from[i] = prev(ite)-&gt;back(); if (ite == snisp.end()) snisp.emplace_back(1, i); else ite-&gt;emplace_back(i); &#125; lis.emplace_back(snisp.back().back()); while (~from[lis.back()]) lis.emplace_back(from[lis.back()]); reverse(lis.begin(), lis.end()); return make_pair(lis, snisp);&#125; 题目CF1097E代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;auto exlis(const vector&lt;T&gt;&amp; a) &#123; vector&lt;size_t&gt; from(a.size()), lis; vector&lt;vector&lt;size_t&gt;&gt; snisp; for (size_t i = 0; i != a.size(); ++i) &#123; auto cmp = [&amp;a] (const vector&lt;size_t&gt;&amp; x, const vector&lt;size_t&gt;&amp; y) &#123; return a[x.back()] &lt; a[y.back()]; &#125;; auto ite = lower_bound(snisp.begin(), snisp.end(), vector&lt;size_t&gt;(1, i), cmp); if (ite == snisp.begin()) from[i] = -1; else from[i] = prev(ite)-&gt;back(); if (ite == snisp.end()) snisp.emplace_back(1, i); else ite-&gt;emplace_back(i); &#125; lis.emplace_back(snisp.back().back()); while (~from[lis.back()]) lis.emplace_back(from[lis.back()]); reverse(lis.begin(), lis.end()); return make_pair(lis, snisp);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #define endl '\\n' const size_t maxn = 100000; vector&lt;size_t&gt; f; for (size_t i = 0; f.size() &lt;= maxn; ++i) for (size_t j = i; ~j; --j) f.emplace_back(i); size_t T; cin &gt;&gt; T; while (T--) &#123; size_t n; cin &gt;&gt; n; vector&lt;size_t&gt; a(n); vector&lt;vector&lt;size_t&gt;&gt; res; for (auto&amp; aa : a) cin &gt;&gt; aa; while (!a.empty()) &#123; auto tmp = exlis(a); if (tmp.first.size() &gt; f[a.size()]) &#123; vector&lt;size_t&gt; lis; for (const auto&amp; x : tmp.first) lis.emplace_back(a[x]); res.emplace_back(lis); auto ite = tmp.first.begin(); vector&lt;size_t&gt; b; for (size_t i = 0; i != a.size(); ++i) &#123; if (ite != tmp.first.end() &amp;&amp; *ite == i) ++ite; else b.emplace_back(a[i]); &#125; swap(a, b); &#125; else &#123; for (const auto&amp; vec : tmp.second) &#123; vector&lt;size_t&gt; nis; for (const size_t&amp; i : vec) nis.emplace_back(a[i]); res.emplace_back(nis); &#125; a.clear(); &#125; &#125; cout &lt;&lt; res.size() &lt;&lt; endl; for (const auto&amp; vec : res) &#123; cout &lt;&lt; vec.size(); for (const auto&amp; ans : vec) cout &lt;&lt; ' ' &lt;&lt; ans; cout &lt;&lt; endl; &#125; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"LIS","slug":"LIS","permalink":"http://yoursite.com/tags/LIS/"}]},{"title":"Hello 2019 (TBC)","slug":"Hello 2019 (TBC)","date":"2019-01-17T14:07:58.065Z","updated":"2019-02-11T16:21:52.398Z","comments":true,"path":"2019/01/17/Hello 2019 (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Hello 2019 (TBC)/","excerpt":"","text":"Hello 2019 A. Gennady and a Card Game题目大意给$~1~$张匹配扑克牌和$~5~$张手牌，判断是否存在$~1~$张手牌的花色或者数值和匹配牌一样。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str, hand; cin &gt;&gt; str; for (int i = 0; i ^ 5; ++i) &#123; cin &gt;&gt; hand; if (str.front() == hand.front() || str.back() == hand.back()) return cout &lt;&lt; \"YES\" &lt;&lt; endl, 0; &#125; cout &lt;&lt; \"NO\" &lt;&lt; endl;&#125; B. Petr and a Combination Lock题目大意一个$~360^\\circ~$的刻度盘，指针初始在$~0^\\circ~$处。给定每次旋转的度数$~a_1,~a_2,~\\dots,~a_n~$，但是旋转方向不定，判断是否存在一种旋转方式使得最后指针回到$~0^\\circ~$。数据范围$~1\\leq n\\leq15,~1\\leq a\\leq180~$。 题解爆搜即可。时间复杂度为$~O(2^n)~$。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto&amp; in : a) cin &gt;&gt; in; for (int i = 0; i ^ 1 &lt;&lt; n; ++i) &#123; int sum = 0; for (int j = 0; j ^ n; ++j) sum += i &amp; 1 &lt;&lt; j ? a[j] : 360 - a[j]; if (sum % 360 == 0) return cout &lt;&lt; \"YES\" &lt;&lt; endl, 0; &#125; cout &lt;&lt; \"NO\" &lt;&lt; endl;&#125; C. Yuhao and a Parenthesis题目大意给$~n~$个括号串，问最多多少括号穿有序对连在一起合法，每个串至多使用一次。 题解经典合法括号串问题。合法性考虑前缀和即可。 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;int&gt; cnt1(1 &lt;&lt; 19, 0), cnt2(1 &lt;&lt; 19, 0); int n; cin &gt;&gt; n; int res = 0; while (n--) &#123; string str; cin &gt;&gt; str; int pre = 0; bool flag = true; for (auto ch : str) &#123; ch == '(' ? ++pre : --pre; if (pre &lt; 0) flag = false; &#125; if (flag) &#123; if (pre) ++cnt1[pre]; else ++res; continue; &#125; int suf = -pre; for (auto ch : str) &#123; ch == ')' ? ++pre : --pre; if (pre &gt; 0) break; &#125; if (!pre) ++cnt2[suf]; &#125; res &gt;&gt;= 1; for (int i = 1; i ^ 1 &lt;&lt; 19; ++i) res += min(cnt1[i], cnt2[i]); cout &lt;&lt; res &lt;&lt; endl;&#125; D. Makoto and a Blackboard题目大意定义一种操作，对任何正整数$~x~$，它会等概率随机变为它的一个因子。现给两个数字$~n~$和$~k~$，问$~n~$经过$~k~$次操作后所得到的期望。数据范围$~1\\leq n\\leq10^{15},~1\\leq k\\leq10^4~$。 题解令$~\\xi(x,~y)~$表示$~x~$经过$~y~$次操作对应答案的随机变量，则此题的答案可用$~\\Bbb{E}(\\xi(n,~k))~$。将$~n~$因式分解为$~\\prod_{i=1}^{m}p_i^{\\alpha_i}~$，于是$~\\xi(n,~k)=\\prod_{i=1}^{m}\\xi(p_i^{\\alpha_i},~k)~$，且$~\\xi(p_i^{\\alpha_i},~k)~$之间相互独立。所以答案可以表示为 \\begin{aligned} \\Bbb{E}(\\xi(n,~k)) &=\\Bbb{E}\\left(\\prod_{i=1}^{m}\\xi(p_i^{\\alpha_i},~k)\\right) \\\\ &=\\prod_{i=1}^{m}\\Bbb{E}\\left(\\xi(p_i^{\\alpha_i},~k)\\right) \\\\ \\end{aligned}接下来计算$~\\Bbb{E}\\left(\\eta_k=\\xi(p^\\alpha,~k)\\right)~$。显然$~\\eta~$是个简单随机变量且值域$~\\eta(\\Omega)={1,~p,~\\dots,~p^\\alpha}~$。记$~f(x,~y)=P(\\eta_y=p^x)~$，不难得出$~y=1~$时，有 f(x,~1)=\\frac{1}{\\alpha+1},~0\\leq x\\leq\\alpha那么对于$~y&gt;1~$，有 f(x,~y)=\\sum_{i=x}^{\\alpha}\\frac{f(i,~y-1)}{i+1}直接递推即可。总时间复杂度为$~O(\\sqrt{n}+k\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;const int maxn = 1 &lt;&lt; 14;int inv[maxn], a[64], b[64];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int calc(long long pp, int n, int k) &#123; int p = pp % mod; for (int i = 0; i &lt;= n; ++i) a[i] = inv[n + 1]; b[n + 1] = 0; while (--k) &#123; for (int i = n; ~i; --i) b[i] = add(b[i + 1], mul(a[i], inv[i + 1])); memcpy(a, b, (n + 1) * sizeof (int)); &#125; int ret = 0; for (int i = 0, base = 1; i &lt;= n; ++i) &#123; if (i) base = mul(base, p); ret = add(ret, mul(a[i], base)); &#125; return ret;&#125;int main() &#123; inv[0] = inv[1] = 1; for (int i = 2; i ^ maxn; ++i) inv[i] = mul(inv[mod % i], mod - mod / i); long long n; int k; cin &gt;&gt; n &gt;&gt; k; vector&lt;pair&lt;long long, int&gt;&gt; factors; for (long long p = 2; p * p &lt;= n; ++p) if (n % p == 0) &#123; int cnt = 0; while (n % p == 0) n /= p, ++cnt; factors.push_back(make_pair(p, cnt)); &#125; if (n ^ 1) factors.push_back(make_pair(n, 1)); int res = 1; for (auto factor : factors) res = mul(res, calc(factor.first, factor.second, k)); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; E. Egor and an RPG game题目大意对于一个全排列$~a_1,~a_2,~\\dots,~a_n~$，将其划分为若干个单调子序列，记最少的数量为$~k~$。对于所有长度为$~n~$的全排列，所对应的$~k~$的最大值记为$~f(n)~$。现给出一个全排列$~a_1,~a_2,~\\dots,~a_n~$，输出一种不超过$~f(n)~$的单调子序列划分方式。数据范围$~1\\leq n\\leq10^5~$。 题解考虑全排列$~1,~3,~2,~6,~5,~4,~10,~9,~8,~7~$，显然它至少要划分为$~4~$个单调子序列。所以对于$~\\frac{k(k+1)}{2}\\leq n~$，必有$~f(n)\\geq k~$。那么对于$~\\frac{k(k+1)}{2}&gt;n~$，下面证明存在$~k-1~$个单调子序列划分。考虑当前序列的任意一个$~\\text{LIS}~$，如果$~{\\mid\\text{LIS}\\mid}\\geq k~$，那么将其划分，对于剩余的部分，此时有$~\\frac{k(k-1)}{2}&gt;n-{\\mid\\text{LIS}\\mid}~$，可以数学归纳。如果$~{\\mid\\text{LIS}\\mid}&lt; k~$，那么根据$~\\text{Dilworth}~$定理，可以将序列划分为$~\\mid\\text{LIS}\\mid~$个$~\\text{LDS}~$。这样总时间复杂度为$~O(n\\sqrt n\\log n)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;int&gt; lim; for (int i = 0; i ^ 500; ++i) for (int j = i; ~j; --j) lim.push_back(i); int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; now(n), tmp, to(n + 1); vector&lt;bool&gt; flag(n + 1, true); vector&lt;vector&lt;int&gt;&gt; res; for (auto&amp; in : now) cin &gt;&gt; in; while (!now.empty()) &#123; vector&lt;int&gt; lis; vector&lt;vector&lt;int&gt;&gt; rem; for (auto a : now) &#123; int idx = lower_bound(lis.begin(), lis.end(), a) - lis.begin(); if (idx) to[a] = lis[idx - 1]; else to[a] = a; if (idx == lis.size()) &#123; lis.push_back(a); rem.push_back(vector&lt;int&gt;(1, a)); &#125; else &#123; lis[idx] = a; rem[idx].push_back(a); &#125; &#125; if (lis.size() &gt; lim[now.size()]) &#123; for (int i = lis.size() - 2; ~i; --i) lis[i] = to[lis[i + 1]]; res.push_back(lis); for (auto a : lis) flag[a] = false; tmp.clear(); for (auto a : now) if (flag[a]) tmp.push_back(a); swap(now, tmp); &#125; else &#123; for (auto ans : rem) res.push_back(ans); now.clear(); &#125; &#125; cout &lt;&lt; res.size() &lt;&lt; endl; for (auto arr : res) &#123; cout &lt;&lt; arr.size(); for (auto a : arr) cout &lt;&lt; ' ' &lt;&lt; a; cout &lt;&lt; endl; &#125; &#125;&#125; F. Alex and a TV Show题目大意初始有$~n~$个空的可重集合$~S_1,~S_2,~\\dots,~S_n~$。接下有$~q~$次操作或询问： 把$~S_x~$变为$~{v}~$。 把$~S_x~$变为$~S_y\\bigcup S_z~$。 把$~S_x~$变为$~{\\gcd(a,~b)\\mid a\\in S_y,~b\\in S_z}~$。 输出$~S_x~$中$~v~$的数量模$~2~$。 数据范围$~1\\leq n\\leq10^5,~1\\leq q\\leq10^6,~1\\leq v\\leq7000~$。 题解先考虑这样的计数矩阵$~A_{n\\times7000}~$，其中$~a_{xv}~$表示$~S_x~$中$~v~$的数量。那么会发现操作$~3~$的复杂度为$~O(q^2)~$。于是考虑因子矩阵$~B_{n\\times7000}~$，其中$~b_{xv}~$表示$~S_x~$中$~v~$的倍数的数量。关于$~B~$能否唯一的表示$~A~$，只要存在可逆矩阵$~T~$，使得$~B=AT~$即可。令 t_{ij}=\\begin{cases} 1 &\\text{$j\\mid i$} \\\\ 0 &\\text{$j\\nmid i$} \\\\ \\end{cases}则$~B=AT~$成立（根据$~B~$的定义），且$~T~$是主对角线全为$~1~$的下三角矩阵，必定可逆，于是$~B~$所对应的集族的唯一性得到了保证。事实上$~T^{-1}~$是莫比乌斯函数矩阵 t_{ij}^{-1}=\\begin{cases} \\mu(ij^{-1}) &\\text{$j\\mid i$} \\\\ 0 &\\text{$j\\nmid i$} \\\\ \\end{cases}$~T^{-1}~$的构造过程可以利用容斥的思想，那么$~\\mu~$则是容斥系数。于是操作$~1~$等价于$~b_{x\\small\\bullet}=t_{v\\small\\bullet}~$，操作$~2~$等价于$~b_{x\\small\\bullet}=b_{y\\small\\bullet}+b_{z\\small\\bullet}~$，操作$~3~$等价于$~b_{x\\small\\bullet}=b_{y\\small\\bullet}\\times b_{z\\small\\bullet}~$，询问$~4~$等价于计算$~b_{x\\small\\bullet}\\cdot t_{v\\small\\bullet}^{-1}~$。注意到$~v~$的数据范围以及答案模$~2~$的要求，可以用$~\\text{bitset}~$来模拟集合对应的因子矩阵。总时间复杂度为$~O(v\\log v+\\frac{qv}{\\text{bitset}})~$，注意可能需要$~\\text{fastIO}~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); const int maxn = 1e5 + 5; const int maxv = 7e3 + 5; vector&lt;int&gt; prime, mu(maxv, 0); vector&lt;bool&gt; vis(maxv, false); mu[1] = 1; for (int i = 2; i ^ maxv; ++i) &#123; if (!vis[i]) &#123; prime.push_back(i); mu[i] = -1; &#125; for (auto p : prime) &#123; if (i * p &gt;= maxv) break; vis[i * p] = true; if (i % p) mu[i * p] = -mu[i]; else break; &#125; &#125; vector&lt;bitset&lt;maxv&gt;&gt; factor(maxv), inv(maxv), set(maxn); for (int i = 1; i ^ maxv; ++i) for (int j = i; j &lt; maxv; j += i) &#123; factor[j].flip(i); if (mu[j / i]) inv[i].flip(j); &#125; int n, q; cin &gt;&gt; n &gt;&gt; q; while (q--) &#123; int op, x, y, z, v; cin &gt;&gt; op; if (op == 1) &#123; cin &gt;&gt; x &gt;&gt; v; set[x] = factor[v]; &#125; if (op == 2) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; set[x] = set[y] ^ set[z]; &#125; if (op == 3) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; set[x] = set[y] &amp; set[z]; &#125; if (op == 4) &#123; cin &gt;&gt; x &gt;&gt; v; cout &lt;&lt; ((set[x] &amp; inv[v]).count() &amp; 1 ? '1' : '0'); &#125; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Educational Codeforces Round 58 (Rated for Div. 2)","slug":"Educational Codeforces Round 58 (Rated for Div. 2)","date":"2019-01-17T14:07:58.054Z","updated":"2019-01-17T14:16:45.369Z","comments":true,"path":"2019/01/17/Educational Codeforces Round 58 (Rated for Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Educational Codeforces Round 58 (Rated for Div. 2)/","excerpt":"","text":"Educational Codeforces Round 58 (Rated for Div. 2) A. Minimum Integer题目大意输出不在$~[l,~r]~$内的$~d~$的最小整数倍。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int q; cin &gt;&gt; q; while (q--) &#123; long long l, r, d; cin &gt;&gt; l &gt;&gt; r &gt;&gt; d; cout &lt;&lt; ((d &lt; l ? 0 : r / d) + 1) * d &lt;&lt; endl; &#125;&#125; B. Accordion题目大意输出给定字符串满足左边为$~\\text{[:}~$右边为$~\\text{:]}~$中间为任意（可以没有）数量的$~\\text{|}~$的子序列最大长度。 题解水题。 代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; int left = -1, right = -1, size = str.size(); bool flag = false; for (int i = 0; i ^ size; ++i) &#123; if (str[i] == '[') flag = true; if (str[i] == ':' &amp;&amp; flag) &#123; left = i; break; &#125; &#125; flag = false; for (int i = size - 1; ~i; --i) &#123; if (str[i] == ']') flag = true; if (str[i] == ':' &amp;&amp; flag) &#123; right = i; break; &#125; &#125; if (!~left || !~ right || left &gt;= right) return cout &lt;&lt; -1 &lt;&lt; endl, 0; int res = 4; for (int i = left + 1; i ^ right; ++i) if (str[i] == '|') ++res; cout &lt;&lt; res &lt;&lt; endl;&#125; C. Division and Union题目大意将$~n~$个给定的闭区间划分到两个集合之中，使得在这两个集合之中分别任选一个闭区间，它们不交。输出任意一种划分或者不存在。 题解首先，如果有合法的划分，当且仅当这两个集合分别并起来得到的两个数集不交。于是合法划分不存在当前仅当所有区间并起来还是一个区间。对所有的区间按左端点升序，先将第$~1~$个区间划分给集合$~1~$，然后按顺序看当前区间与第$~1~$个区间是否有交。如果有交则划分给集合$~1~$同时与第$~1~$个区间并起来。如果没有则后面所有的区间都划分给集合$~2~$，这样所有在集合$~2~$区间里的数都大于在集合$~1~$区间里的数。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; seg(n); for (int i = 0; i ^ n; ++i) &#123; cin &gt;&gt; seg[i].first.first &gt;&gt; seg[i].first.second; seg[i].second = i; &#125; sort(seg.begin(), seg.end()); vector&lt;int&gt; res(n); bool flag = true; for (int i = 0, back = seg.front().first.second; i ^ n; ++i) &#123; if (seg[i].first.first &lt;= back) &#123; back = max(back, seg[i].first.second); res[seg[i].second] = 1; &#125; else &#123; flag = false; for (int j = i; j ^ n; ++j) res[seg[j].second] = 2; cout &lt;&lt; res.front(); for (int j = 1; j ^ n; ++j) cout &lt;&lt; ' ' &lt;&lt; res[j]; cout &lt;&lt; endl; break; &#125; &#125; if (flag) cout &lt;&lt; -1 &lt;&lt; endl; &#125;&#125; D. GCD Counting题目大意给定一颗带点值的树，找出最长的简单路径满足路径上所有点值不互质。数据范围$~1\\leq n\\leq2\\cdot10^5,~1\\leq a\\leq2\\cdot10^5~$。 题解对于最长的合法路径，必存在一个质数$~p~$是路径上所有点值的公因数。注意到点值的数据范围，可以先预处理所有数字的所有质因子，这一步的时间复杂度为$~O(a\\log a)~$。树形$~\\text{DP}~$。任取一个点为根节点，考虑在以节点$~u~$为根的子树上经过$~u~$且有公因数$~p~$的最长路径$~cal[u][p]~$。先计算以$~u~$为一个端点，另一端点在子树中且公因数为$~p~$的最长路径路径$~len[u][p]~$。那么对于$~u~$的所有儿子$~v~$，在$~\\text{dfs}~$过程中用$~len[v][p]~$的最大值更新$~len[u][p]~$，最大值和次大值更新$~cal[u][p]~$。为节省空间，注意到$~a~$的不同质因子个数很少，可以用$~\\text{map}~$来维护$~len~$，且不用记录$~cal~$直接更新答案即可。总时间复杂度为$~O(a\\cdot\\log a+n\\cdot\\log a\\cdot\\log\\log a)~$。事实上可以写成$~O((n+a)\\log a)~$，但是没有必要。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;int a[maxn], res, max1[maxn], max2[maxn];vector&lt;int&gt; adj[maxn], prime[maxn];vector&lt;bool&gt; vis(maxn);map&lt;int, int&gt; len[maxn];void dfs(int u, int pa) &#123; for (auto v : adj[u]) if (v ^ pa) dfs(v, u); for (auto p : prime[a[u]]) max1[p] = max2[p] = 0; for (auto v : adj[u]) if (v ^ pa) for (auto p : prime[a[u]]) &#123; max2[p] = max(max2[p], len[v][p]); if (max1[p] &lt; max2[p]) swap(max1[p], max2[p]); &#125; if (a[u] == 1) return; int cal = 0; for (auto p : prime[a[u]]) &#123; cal = max(cal, max1[p] + max2[p]); len[u][p] = max1[p] + 1; &#125; res = max(res, ++cal);&#125;int main() &#123; for (int i = 2; i ^ maxn; ++i) if (!vis[i]) for (int j = i; j &lt; maxn; j += i) &#123; vis[j] = true; prime[j].push_back(i); &#125; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i ^ n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; dfs(1, 0); cout &lt;&lt; res &lt;&lt; endl;&#125; E. Polycarp’s New Job题目大意一共$~n~$次添加或者询问： 加入一个大小为$~x\\times y~$的矩形。 询问是否所有矩形都能被$~h\\times w~$的矩形包含。数据范围$~2\\leq n\\leq5\\cdot10^5,~1\\leq x,~y,~h,~w\\leq10^9~$。 题解首先离散化。注意到矩形可以翻转，不妨让$~x\\geq y,~h\\geq w~$。那么题目变成了平面加点和询问平面内所有点是否都在$~[0,~h]\\times[0,~w]~$或$~[0,~w]\\times[0,~h]~$内。空间范围显然不允许使用二维树状数组，但是可以将询问等价为所有点都在$~[0,~h]\\times[0,~h]~$内且不在$~(w,~\\infty)\\times(w,~\\infty)~$内。那么用两个一维树状数组维护即可。总时间复杂度$~O(n\\log n)~$。数据范围过大，注意$~\\text{IO}~$速度。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; struct Query &#123; char op; int x, y; &#125;; vector&lt;Query&gt; query(n); set&lt;int&gt; num; for (auto&amp; qry : query) &#123; cin &gt;&gt; qry.op &gt;&gt; qry.x &gt;&gt; qry.y; if (qry.x &lt; qry.y) swap(qry.x, qry.y); num.insert(qry.x); num.insert(qry.y); &#125; map&lt;int, int&gt; to; int maxn = 1; for (auto x : num) to[x] = maxn++; vector&lt;int&gt; bit1(maxn, 0), bit2(maxn, 0); #define lowbit(x) (x &amp; -x) int cnt = 0; for (auto qry : query) &#123; qry.x = to[qry.x]; qry.y = to[qry.y]; if (qry.op == '+') &#123; ++cnt; for (int i = qry.x; i &lt; maxn; i += lowbit(i)) ++bit1[i]; for (int i = qry.y; i; i -= lowbit(i)) ++bit2[i]; &#125; else &#123; int sum = 0; for (int i = qry.x; i; i -= lowbit(i)) sum += bit1[i]; for (int i = qry.y + 1; i &lt; maxn; i += lowbit(i)) sum -= bit2[i]; if (sum == cnt) cout &lt;&lt; \"YES\\n\"; else cout &lt;&lt; \"NO\\n\"; &#125; &#125;&#125; F. Trucks and Cities题目大意坐标轴上有$~n~$个城市和$~m~$趟卡车。给定城市坐标$~a~$，卡车的起点$~s~$、终点$~f~$、每公里耗油$~c~$和可中途加油次数$~r~$。问油箱的最小容量。 题解动态规划。记$~dp[r][s][f]~$为最优策略下卡车从$~a_s~$到$~a_f~$最多停靠加油$~r~$次的最长的两次停靠城市距离。那么答案则是$~\\max(dp[r][s][f]\\cdot c)~$。通过枚举最后一次停靠城市$~a_l~$，有状态转移式 dp[r][s][f]=\\min_{s< t< f}\\max(dp[r-1][s][t],~a[f]-a[t])此时总时间复杂度为$~O(n^4)~$显然会$~\\text{tle}~$。但是不难发现在固定$~r~$和$~s~$后，最优转移点$~t~$随着$~f~$递增，所以双指针优化后时间复杂度变为$~O(n^3)~$。但是直接开$~O(n^3)~$的三位数组空间复杂度很危险（擦着边其实可以过），那么对于所有的输入$~(s,~f,~c,~r)~$离线操作，按$~r~$升序，这样$~dp~$的$~r~$维度可以滚动数组实现。总时间复杂度为$~O(n^3+m\\log m)~$，空间复杂度为$~O(n^2+m)~$。 代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; vector&lt;vector&lt;int&gt;&gt; dp0(n + 1, vector&lt;int&gt;(n + 1)); vector&lt;vector&lt;int&gt;&gt; dp1(n + 1, vector&lt;int&gt;(n + 1)); for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; ++j) dp0[i][j] = a[j] - a[i]; struct Query &#123;int s, f, c, r;&#125;; vector&lt;Query&gt; query(m); for (auto&amp; qry : query) cin &gt;&gt; qry.s &gt;&gt; qry.f &gt;&gt; qry.c &gt;&gt; qry.r; sort(query.begin(), query.end(), [](Query a, Query b) &#123;return a.r &lt; b.r;&#125;); long long res = 0; int now = 0; for (auto qry : query) &#123; while (now ^ qry.r) &#123; for (int j = 1; j &lt;= n; ++j) for (int k = j, l = j; k &lt;= n; ++k) &#123; while (l &lt; k &amp;&amp; max(dp0[j][l], a[k] - a[l]) &gt; max(dp0[j][l + 1], a[k] - a[l + 1])) ++l; dp1[j][k] = max(dp0[j][l], a[k] - a[l]); &#125; swap(dp0, dp1); ++now; &#125; res = max(res, 1LL * qry.c * dp0[qry.s][qry.f]); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; G. (Zero XOR Subset)-less题目大意给定数列$~a_1,~a_2,~\\dots,~a_n~$，要划分为若干个连续子序列$~A_1,~A_2,~\\dots,~A_k~$。令每个子序列的$~\\text{xor}~$和记为$~\\alpha_i,~i=1,~2,~\\dots,~k~$，集合$~S={\\alpha_1,~\\alpha_2,~\\dots,~\\alpha_k}~$。问满足$~S~$的所有非空子集的$~\\text{xor}~$和互不相同的最大$~k~$或不存在。数据范围$~1\\leq n\\leq2\\cdot10^5,~0\\leq a\\leq10^9~$。 题解记录$~a_1,~a_2,~\\dots,~a_n~$的前缀$~\\text{xor}~$和$~pre_1,~pre_2,~\\dots,~pre_n~$，显然如果$~pre_n=0~$则答案不存在，反之存在。再考虑合法集合$~S~$，记$~\\alpha_1,~\\alpha_2,~\\dots,~\\alpha_k~$的前缀$~\\text{xor}~$和为$~\\beta_1,~\\beta_2,~\\dots,~\\beta_k~$，则不难发现$~\\bar{S}={\\beta_1,~\\beta_2,~\\dots,~\\beta_k}~$也是合法集合。且根据定义$~\\beta~$也是$~a~$的前缀$~\\text{xor}~$和，所以$~\\bar{S}\\subseteq{pre_1,~pre_2,~\\dots,~pre_n}~$。对于所有正整数，考虑二进制表示的$~01~$向量，可以等价于$~\\Bbb{Z}_2~$上的某向量空间的向量，合法集合可以看作是这个向量空间上的一个线性无关组。这是一个线性基问题，答案是包含$~pre~$的最小空间的维数。时间复杂度为$~O(n\\log a)~$。 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), base; cin &gt;&gt; a.front(); for (int i = 1; i ^ n; ++i) cin &gt;&gt; a[i], a[i] ^= a[i - 1]; if (!a.back()) return cout &lt;&lt; -1 &lt;&lt; endl, 0; for (auto e : a) &#123; for (auto v : base) e = min(e, e ^ v); if (e) base.push_back(e); &#125; cout &lt;&lt; base.size() &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Educational Codeforces Round 57 (Rated for Div. 2)","slug":"Educational Codeforces Round 57 (Rated for Div. 2)","date":"2019-01-17T14:07:58.047Z","updated":"2019-01-17T14:09:23.552Z","comments":true,"path":"2019/01/17/Educational Codeforces Round 57 (Rated for Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Educational Codeforces Round 57 (Rated for Div. 2)/","excerpt":"","text":"Educational Codeforces Round 57 (Rated for Div. 2) A. Find Divisible题目大意输出任意一组$~(x,~y)\\in [l,~r]^2~$满足$~x~$整除$~y~$，保证有解。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; l * 2 &lt;&lt; endl; &#125;&#125; B. Substring Removal题目大意给定一个小写字母串，询问有多少子串那满足删去子串后剩余部分仅有$~1~$种字母，保证输入串至少含$~2~$种字母。 题解显然剩余的串必须为单字母构成前缀或后缀，或者字母一样的前后缀。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const int mod = 998244353; int n; string str; cin &gt;&gt; n &gt;&gt; str; int l, r; for (l = 0; l ^ n &amp;&amp; str[l] == str.front(); ++l); for (r = n - 1; ~r &amp;&amp; str[r] == str.back(); --r); if (str.front() == str.back()) cout &lt;&lt; (long long)(l + 1) * (n - r) % mod &lt;&lt; endl; else cout &lt;&lt; l + n - r &lt;&lt; endl;&#125; C. Polygon for the Angle题目大意给一个在$~1^\\circ~$到$~179^\\circ~$之间的整数度数，输出最小的$~n~$满足正$~n~$边形上可以取$~3~$个点构成这个角度。 题解不难得出正$~n~$边形可以得到的角度为$~\\frac{1}{n}\\times180^\\circ,~\\frac{2}{n}\\times180^\\circ,~\\dots,~\\frac{n-2}{n}\\times180^\\circ~$这一结论。考虑分数$~\\frac{ang}{180}~$的最简形式$~\\frac{p}{q}~$，答案即为$~q~$或者$~2q~$（如果$~p=q-1~$）。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int ang; cin &gt;&gt; ang; int gcd = __gcd(ang, 180); cout &lt;&lt; (gcd + ang ^ 180 ? 180 : 360) / gcd &lt;&lt; endl; &#125;&#125; D. Easy Problem题目大意给一个字符串以及删除每个字符的花费$~a_i~$，输出使得字符串不包含$~\\text{hard}~$这一子序列的最小删除花费。 题解动态规划。记$~dp[i][j]~$表示考虑到第$~i~$位，已经构成了$~\\text{hard}~$前$~j~$个字符的最小花费。从左至右模拟即可，时间复杂度为$~O(n)~$。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; string str; cin &gt;&gt; n &gt;&gt; str; vector&lt;long long&gt; a(n); for (auto&amp; arr : a) cin &gt;&gt; arr; vector&lt;vector&lt;long long&gt;&gt; dp(n + 1, vector&lt;long long&gt;(4)); dp[0][0] = 0; dp[0][1] = dp[0][2] = dp[0][3] = 0x3f3f3f3f; for (int i = 1; i &lt;= n; ++i) &#123; dp[i][0] = dp[i - 1][0]; dp[i][1] = dp[i - 1][1]; dp[i][2] = dp[i - 1][2]; dp[i][3] = dp[i - 1][3]; if (str[i - 1] == 'h') &#123; dp[i][0] += a[i - 1]; dp[i][1] = min(dp[i][1], dp[i - 1][0]); &#125; if (str[i - 1] == 'a') &#123; dp[i][1] += a[i - 1]; dp[i][2] = min(dp[i][2], dp[i - 1][1]); &#125; if (str[i - 1] == 'r') &#123; dp[i][2] += a[i - 1]; dp[i][3] = min(dp[i][3], dp[i - 1][2]); &#125; if (str[i - 1] == 'd') &#123; dp[i][3] = dp[i][3] + a[i - 1]; &#125; &#125; cout &lt;&lt; min(min(dp[n][0], dp[n][1]), min(dp[n][2], dp[n][3])) &lt;&lt; endl;&#125; E. The Top Scorer题目大意有$~p~$个人比赛，每人都有未知的非负得分$~a_i~$，但总和$~\\sum_{i=1}^{p}{a_i}=s~$已知。分数最高的一人获胜，如果最高分有多人同分，则他们的获胜概率均等。现已知$~\\text{Hason}~$的分数至少为$~r~$，所有不同的结果出现的概率均等，求他获胜的概率。数据范围$~1\\leq p\\leq 100,~0\\leq r\\leq s\\leq5000~$。 题解先将$~\\text{Hason}~$的分数和总分数减去$~r~$，那么插板法可以算出所有合法的结果数量为 \\binom{p+s-r-1}{p-1}接下来枚举$~\\text{Hason}~$的得分$~i=r,~r+1,~\\dots,~s~$，有$~j=1,~2,~\\dots,~\\lfloor \\frac{s}{i}\\rfloor~$人与他同分（算上$~\\text{Hason}~$他自己），且其余的得分均小于$~i~$的情况。此时$~\\text{Hason}~$获胜的结果数量期望为 \\frac{1}{j}\\binom{p-1}{p-j}f(p-j,~i,~s-ij)其中$~f(x,~y,~z)~$表示$~x~$人得分均小于$~y~$且总和为$~z~$的合法结果数量。对于$~f(x,~y,~z)~$的计算，先考虑在没有$~y~$的限制下，用插板法可以得到答案为$~g(x,~z)=\\binom{x+z-1}{x-1}~$。那么将条件变为$~x~$人，至少有$~w~$人得分不少于$~y~$，且总和为$~z~$，则它的结果数量等于$~\\binom{x}{w}g(x,~z-wy)~$。于是通过容斥，得到$~f(x,~y,~z)~$的计算式 \\begin{aligned} f(x,~y,~z) &=\\sum_{i=0}^{\\min(x,~\\lfloor\\frac{z}{y}\\rfloor)}{(-1)^i\\binom{x}{i}g(x,~z-iy)} \\\\ &=\\sum_{i=0}^{\\min(x,~\\lfloor\\frac{z}{y}\\rfloor)}{(-1)^i\\binom{x}{i}\\binom{x+z-iy-1}{x-1}} \\\\ \\end{aligned}注意特判$~f(x=0,~y,~z)~$的情况。总时间复杂度为$~O(p^2s)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 6e3;int inv[maxn], fact[maxn], finv[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int bino(const int&amp; a, const int&amp; b) &#123;return mul(mul(fact[a], finv[b]), finv[a - b]);&#125;inline int binv(const int&amp; a, const int&amp; b) &#123;return mul(mul(finv[a], fact[b]), fact[a - b]);&#125;inline int calc(const int&amp; n, const int&amp; up, const int&amp; s) &#123; if (!n) return s == 0; int ret = 0; for (int i = 0; i &lt;= n &amp;&amp; i * up &lt;= s; ++i) &#123; int temp = mul(bino(n + s - i * up - 1, n - 1), bino(n, i)); ret = i &amp; 1 ? sub(ret, temp) : add(ret, temp); &#125; return ret;&#125;int main() &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125; int p, s, r; cin &gt;&gt; p &gt;&gt; s &gt;&gt; r; int cnt = 0; for (int i = r; i &lt;= s; ++i) for (int j = 1; j &lt;= p &amp;&amp; i * j &lt;= s; ++j) cnt = add(cnt, mul(mul(calc(p - j, i, s - i * j), inv[j]), bino(p - 1, j - 1))); cout &lt;&lt; mul(cnt, binv(p - r + s - 1, p - 1)) &lt;&lt; endl;&#125; F. Inversion Expectation题目大意给一个不完整的全排列，输出逆序对期望数。数据范围$~1\\leq n\\leq 2\\cdot10^5~$。 题解记总共有$~m~$个未知数，分为$~4~$种情况讨论： 所有已知数与已知数对于逆序对的贡献。即为计算一个序列的逆序对数量，用排序或者树状数组均可实现，时间复杂度为$~O(n\\log n)~$。 所有未知数与未知数对于逆序对的贡献。对于任意一种可能的未知数的排列，将其翻转后原来的逆序对变为顺序对，顺序对变为逆序对。于是任意一对未出现的数字，在所有可能的排列情况种它们一半为顺序对，一半为逆序对。所以$~m~$个未知数相互之间对于逆序对的贡献期望为$~\\binom{m}{2}\\frac{m!}{2}~$。 所有已知数与未知数对于逆序对的贡献。先单独考虑一个已知数$~p_i~$与它左边比它大的未知数对于逆序对的贡献。设它左边有$~left_i~$个未知数，所有未知数种有$~lgreater_{p_i}~$个比$~p_i~$大，那么逆序对的期望则是$~left_i\\cdot lgreater_{p_i}\\cdot m^{-1}~$。同理对于$~p_i~$与它右边比它小的未知数对于逆序对期望则是$~right_j\\cdot rsmaller_{p_j}\\cdot m^{-1}~$。这些都可以在线性时间里处理完。总时间复杂度为$~(n\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 2e5 + 5;int inv[maxn], a[maxn], exist[maxn], blank[maxn], bit[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;#define lowbit(x) (x &amp; -x)int main() &#123; inv[1] = 1; for (int i = 2; i ^ maxn; ++i) inv[i] = mul(inv[mod % i], mod - mod / i); int n; cin &gt;&gt; n; int cnt = 0, res = 0; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; if (~a[i]) &#123; blank[i] = blank[i - 1]; exist[a[i]] = 1; res = add(res, i - cnt - 1); for (int j = a[i]; j; j -= lowbit(j)) res = sub(res, bit[j]); for (int j = a[i]; j &lt; maxn; j += lowbit(j)) ++bit[j]; &#125; else &#123; blank[i] = ++cnt; &#125; &#125; for (int i = 1; i &lt;= n; ++i) exist[i] += exist[i - 1]; res = add(res, mul(mul(cnt, cnt - 1), inv[4])); for (int i = 1; i &lt;= n; ++i) if (~a[i]) res = add(res, mul(add(mul(blank[i], cnt + exist[a[i]] - a[i]), mul(cnt - blank[i], a[i] - exist[a[i]])), inv[cnt])); cout &lt;&lt; res &lt;&lt; endl;&#125; G. Lucky Tickets题目大意问有多少个可以首零的$~n~$（偶数）位数字满足前一半的各位数数字之和与后一半的各位数数字之和一样。限定这个数只能由$~d_1,~d_2,~\\dots,~d_k~$组成。数据范围$~2\\leq n\\leq2\\cdot10^5,~1\\leq k\\leq10~$。 题解考虑所有前$~\\frac{n}{2}~$位数加起来可以得到的总和$~s~$，令$~calc(s)~$为所有满足各位数数字之和位$~s~$的合法的$~\\frac{n}{2}~$位数的数量，则答案为$~\\sum_{s=0}^{5n}calc^2(s)~$。考虑这样一个多项式 f(x)=\\sum_{i=1}^{k}x^{d_i}则$~calc(s)~$即为$~f^\\frac{n}{2}(x)~$的$~s~$次系数。于是$~\\text{NTT}~$即可得出答案。时间复杂度$~O(n\\log n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int root = 3;const int maxn = 1 &lt;&lt; 20;int f[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;#define lowbit(x) (x &amp; -x)inline int fpow(int a, int n) &#123; if (n &lt; 0) n = (2LL - mod) * n % (mod - 1); int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;inline void to_pow2(int&amp; x) &#123;while (x ^ lowbit(x)) x += lowbit(x);&#125;inline void bit_reverse(int f[], int size) &#123; for (int i = 1, j = size &gt;&gt; 1; i ^ size - 1; ++i) &#123; if (i &lt; j) swap(f[i], f[j]); int k = size &gt;&gt; 1; while (j &gt;= k) &#123; j -= k; k &gt;&gt;= 1; &#125; if (j &lt; k) j += k; &#125;&#125;inline void ntt(int f[], int size, int op = 1) &#123; bit_reverse(f, size); for (int i = 2; i &lt;= size; i &lt;&lt;= 1) &#123; int wn = fpow(root, op * (1 - mod) / i); for (int j = 0; j ^ size; j += i) &#123; int w = 1; for (int k = j; k ^ j + (i &gt;&gt; 1); ++k) &#123; int u = f[k]; int v = mul(w, f[k + (i &gt;&gt; 1)]); f[k] = add(u, v); f[k + (i &gt;&gt; 1)] = sub(u, v); w = mul(w, wn); &#125; &#125; &#125; if (!~op) &#123; int inv = fpow(size, -1); for (int i = 0; i ^ size; ++i) f[i] = mul(f[i], inv); &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; while (k--) &#123; int d; cin &gt;&gt; d; f[d] = 1; &#125; int size = n * 5; to_pow2(size); ntt(f, size); for (int i = 0; i ^ size; ++i) f[i] = fpow(f[i], n &gt;&gt; 1); ntt(f, size, -1); int res = 0; for (int i = 0; i ^ size; ++i) res = add(res, mul(f[i], f[i])); cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Educational Codeforces Round 56 (Rated for Div. 2)","slug":"Educational Codeforces Round 56 (Rated for Div. 2)","date":"2019-01-17T14:07:58.042Z","updated":"2019-01-17T14:09:21.495Z","comments":true,"path":"2019/01/17/Educational Codeforces Round 56 (Rated for Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Educational Codeforces Round 56 (Rated for Div. 2)/","excerpt":"","text":"Educational Codeforces Round 56 (Rated for Div. 2) A. Dice Rolling题目大意一个点数为$~2~$至$~7~$的骰子，求任意一种可能的次数使得点数之和为$~x~$。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int x; cin &gt;&gt; x; cout &lt;&lt; (x &gt;&gt; 1) &lt;&lt; endl; &#125;&#125; B. Letters Rearranging题目大意给一个小写字母串，输出任意一种不回文重排列。 题解水题。排序即可。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; string str; cin &gt;&gt; str; sort(str.begin(), str.end()); if (str.front() == str.back()) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; str &lt;&lt; endl; &#125;&#125; C. Mishka and the Last Exam题目大意输出一个长度为$~n~$的数列${a_n}$满足对称位之差为给定的数列$~{b_\\frac{n}{2}}~$。 题解水题。从数列边缘向内部贪心，左边尽量小，右边尽量大。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; n &gt;&gt;= 1; vector&lt;long long&gt; left(n), right(n); for (int i = 0; i ^ n; ++i) &#123; long long b; cin &gt;&gt; b; right[i] = b - (left[i] = (i ? max(left[i - 1], b - right[i - 1]) : 0)); &#125; for (auto res : left) cout &lt;&lt; res &lt;&lt; ' '; long long last = right.front(); reverse(right.begin(), right.end()); right.pop_back(); for (auto res : right) cout &lt;&lt; res &lt;&lt; ' '; cout &lt;&lt; last &lt;&lt; endl;&#125; D. Beautiful Graph题目大意给一个简单图（无重边无自环可能不连通），求点的$~{1,~2,~3}~$染色方案数，使得每条边两边加起来是奇数。 题解考虑染色的奇偶性，显然对于每个点，它相邻的点均与它奇偶性不同。所以如果存在奇环，则答案为$~0~$。跑一遍$~\\text{DFS}~$然后对于每个联通块的方案数乘起来即是答案。时间复杂度为$~O(n)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 3e5 + 5;vector&lt;int&gt; adj[maxn];int two[maxn], color[maxn], cnt[2];bool vis[maxn], flag;inline int add(const int&amp; a, const int&amp; b) &#123;return a + b &lt; mod ? a + b : a + b - mod;&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;void dfs(int u, int c = 0) &#123; vis[u] = true; ++cnt[color[u] = c]; for (auto v : adj[u]) &#123; if (vis[v]) flag &amp;= (color[u] ^ color[v]); else dfs(v, !c); &#125;&#125;int main() &#123; two[0] = 1; for (int i = 1; i ^ maxn; ++i) two[i] = add(two[i - 1], two[i - 1]); int t; cin &gt;&gt; t; while (t--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) adj[i].clear(); while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; memset(vis + 1, 0, n * sizeof (bool)); flag = true; int res = 1; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; cnt[0] = cnt[1] = 0; dfs(i); if (flag) res = mul(res, add(two[cnt[0]], two[cnt[1]])); else break; &#125; cout &lt;&lt; (flag ? res : 0) &lt;&lt; endl; &#125;&#125; E. Intersection of Permutations题目大意给定$~1,~\\dots,~n~$的两个全排列$~a~$和$~b~$，和$~q~$个查询或修改操作。查询操作给出$~l_a,~r_a,~l_b,~r_b~$，输出$~a_{[l_a,~r_a]}~$和$~b_{[l_b,~r_b]}~$之间相同同的数字个数。修改操作给出$~x~$和$~y~$，交换$~b_x~$和$~b_y~$。 题解应为$~a~$不会被修改，那么做置换使得$~a_i=i~$，这样对于询问操作，只要输出$~[l_a,~r_a]~$在$~b_{[l_b,~r_b]}~$中出现的次数。考虑二维坐标系上的$~n~$个点$~(b_i,~i),~i=1,~2,~\\dots,~n~$，查询操作等价于输出$~[la,~ra]\\times[lb,~rb]~$内的点的个数；修改操作等价于将$~(b_x,~x)~$和$~(b_y,~y)~$变为$~(b_y,~x)~$和$~(b_x,~y)~$。用树状数组维护$~\\text{treap}~$即可，时间复杂度为$~O(n\\log^2n)~$。由于我不会写$~\\text{treap}~$，所以使用了$~\\text{pb_ds}~$库，常数比较大。 代码（使用$~\\text{pb_ds}~$库）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;using namespace std;using namespace __gnu_pbds;const int maxn = 2e5 + 5;int a[maxn], b[maxn];tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; bit[maxn];#define lowbit(x) (x &amp; -x)int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; int in; cin &gt;&gt; in; a[in] = i; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int in; cin &gt;&gt; in; b[i] = a[in]; for (int j = i; j &lt;= n; j += lowbit(j)) bit[j].insert(b[i]); &#125; while (m--) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; int la, ra, lb, rb; cin &gt;&gt; la &gt;&gt; ra &gt;&gt; lb &gt;&gt; rb; int res = 0; for (int i = rb; i; i -= lowbit(i)) &#123; auto ite = bit[i].upper_bound(ra); if (ite == bit[i].end()) res += bit[i].size(); else res += bit[i].order_of_key(*ite); &#125; for (int i = rb; i; i -= lowbit(i)) &#123; auto ite = bit[i].upper_bound(la - 1); if (ite == bit[i].end()) res -= bit[i].size(); else res -= bit[i].order_of_key(*ite); &#125; for (int i = lb - 1; i; i -= lowbit(i)) &#123; auto ite = bit[i].upper_bound(ra); if (ite == bit[i].end()) res -= bit[i].size(); else res -= bit[i].order_of_key(*ite); &#125; for (int i = lb - 1; i; i -= lowbit(i)) &#123; auto ite = bit[i].upper_bound(la - 1); if (ite == bit[i].end()) res += bit[i].size(); else res += bit[i].order_of_key(*ite); &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; else &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; for (int i = x; i &lt;= n; i += lowbit(i)) bit[i].erase(b[x]); for (int i = y; i &lt;= n; i += lowbit(i)) bit[i].erase(b[y]); swap(b[x], b[y]); for (int i = x; i &lt;= n; i += lowbit(i)) bit[i].insert(b[x]); for (int i = y; i &lt;= n; i += lowbit(i)) bit[i].insert(b[y]); &#125; &#125;&#125; F. Vasya and Array题目大意一个长度为$~n~$的数列由$~1,~\\dots,~k~$组成，部分位置的值已给定。求有多少个数列满足所有长度为$~len~$的区间内至少由$~2~$种不同的数字。 题解动态规划，有点复杂。记$~pre[i][j]~$为区间$~[1,~i]~$中至多有多少$~j~$，从而计算$~fuck[i][j]~$，表示区间$~(i-len,~i]~$是否有可能全部为$~j~$。记$~dp[i][j][0/1]~$为区间$~[1,~i]~$上满足$~a[i]=j~$的合法或非法数量，记求和$~sum[i][0/1]=\\sum_{j=1}^k{dp[i][j][0/1]}~$以及$~cnt[i]=sum[i][0]+sum[i][1]~$。于是有状态转移式 \\begin{aligned} dp[i][j][0] &=sum[i-1][0]+\\begin{cases} sum[i-len][1]-dp[i-len][j][1] &\\text{$flag[i][j]$} \\\\ 0 &\\text{$!flag[i][j]$}\\end{cases} \\\\ dp[i][j][1] &=cnt[i-1]-dp[i][j][0] \\\\ \\end{aligned}所有的状态转移都是$~O(1)~$的，所以时间复杂度与空间复杂度均为$~O(nk)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 1e5 + 5;const int maxk = 105;int a[maxn], pre[maxn][maxk], cnt[maxn], sum[maxn][2], dp[maxn][maxk][2];bool fuck[maxn][maxk];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;int main() &#123; int n, k, len; cin &gt;&gt; n &gt;&gt; k &gt;&gt; len; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; if (~a[i]) pre[i][a[i]] = 1; else for (int j = 1; j &lt;= k; ++j) pre[i][j] = 1; &#125; if (len == 1) return cout &lt;&lt; 0 &lt;&lt; endl, 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= k; ++j) &#123; pre[i][j] += pre[i - 1][j]; if (i &gt;= len &amp;&amp; pre[i][j] - pre[i - len][j] == len) fuck[i][j] = true; &#125; if (~a[1]) &#123; cnt[1] = sum[1][1] = dp[1][a[1]][1] = 1; &#125; else &#123; for (int i = 1; i &lt;= k; ++i) dp[1][i][1] = 1; cnt[1] = sum[1][1] = k; &#125; sum[0][1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (~a[i]) &#123; cnt[i] = cnt[i - 1]; dp[i][a[i]][0] = sum[i - 1][0]; if (fuck[i][a[i]]) dp[i][a[i]][0] = add(dp[i][a[i]][0], sub(sum[i - len][1], dp[i - len][a[i]][1])); dp[i][a[i]][1] = sum[i][1] = sub(cnt[i], sum[i][0] = dp[i][a[i]][0]); &#125; else &#123; for (int j = 1; j &lt;= k; ++j) &#123; dp[i][j][0] = sum[i - 1][0]; if (fuck[i][j]) dp[i][j][0] = add(dp[i][j][0], sub(sum[i - len][1], dp[i - len][j][1])); sum[i][0] = add(sum[i][0], dp[i][j][0]); dp[i][j][1] = sub(cnt[i - 1], dp[i][j][0]); &#125; sum[i][1] = sub(cnt[i] = mul(cnt[i - 1], k), sum[i][0]); &#125; &#125; cout &lt;&lt; sum[n][1] &lt;&lt; endl;&#125; G. Multidimensional Queries题目大意给定$~k~$维空间的$~n~$个点，和$~q~$次修改或查询操作。修改为重新赋值第$~i~$个点，查询为区间$~[l,~r]~$的最大曼哈顿距离。数据范围$~1\\leq n\\leq2\\times10^5,~1\\leq k\\leq5,~1\\leq q\\leq2\\times10^5,~-10^6\\leq a_{ij}\\leq10^6,~$。 题解考虑曼哈顿距离公式 \\begin{aligned} \\sum_{i=1}^{k}\\mid a_{xi}-a_{yi}\\mid &=\\max\\sum_{i=1}^{k}c_i(a_{xi}-a_{yi}) \\\\ &=\\max\\left(\\sum_{i=1}^{k}c_i a_{xi}-\\sum_{i=1}^{k}c_i a_{xi}\\right) \\\\ c_i &=\\pm1 \\\\ \\end{aligned}注意到$~k~$的数据范围很小，上式的系数列的取法共$~2^k~$种，那么建立$~2^{k+1}~$棵线段树维护$~\\sum_{i=1}^{k}c_i a_{xi}~$的最大最小值即可。时间复杂度为$~O((n+q)2^k\\log n)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;int size, seg[maxn &lt;&lt; 2][32][2], a[maxn][32], b[5], idx[maxn], cal[32][2];void build(int begin, int end, int index) &#123; if (begin == end) &#123; for (int i = 0; i ^ size; ++i) seg[index][i][0] = seg[index][i][1] = a[begin][i]; idx[begin] = index; return; &#125; int mid = begin + end &gt;&gt; 1; build(begin, mid, index &lt;&lt; 1); build(mid + 1, end, index &lt;&lt; 1 ^ 1); for (int i = 0; i ^ size; ++i) &#123; seg[index][i][0] = min(seg[index &lt;&lt; 1][i][0], seg[index &lt;&lt; 1 ^ 1][i][0]); seg[index][i][1] = max(seg[index &lt;&lt; 1][i][1], seg[index &lt;&lt; 1 ^ 1][i][1]); &#125;&#125;void push_up(int pos) &#123; int index = idx[pos]; for (int i = 0; i ^ size; ++i) seg[index][i][0] = seg[index][i][1] = a[pos][i]; while (index ^ 1) &#123; index &gt;&gt;= 1; for (int i = 0; i ^ size; ++i) &#123; seg[index][i][0] = min(seg[index &lt;&lt; 1][i][0], seg[index &lt;&lt; 1 ^ 1][i][0]); seg[index][i][1] = max(seg[index &lt;&lt; 1][i][1], seg[index &lt;&lt; 1 ^ 1][i][1]); &#125; &#125;&#125;void push_down(int begin, int end, int index, int l, int r) &#123; if (begin &gt;= l &amp;&amp; end &lt;= r) &#123; for (int i = 0; i ^ size; ++i) &#123; cal[i][0] = min(cal[i][0], seg[index][i][0]); cal[i][1] = max(cal[i][1], seg[index][i][1]); &#125; return; &#125; int mid = begin + end &gt;&gt; 1; if (mid &gt;= l) push_down(begin, mid, index &lt;&lt; 1, l, r); if (mid &lt; r) push_down(mid + 1, end, index &lt;&lt; 1 ^ 1, l, r);&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; size = 1 &lt;&lt; k; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j ^ k; ++j) cin &gt;&gt; b[j]; for (int j = 0; j ^ 1 &lt;&lt; k; ++j) for (int l = 0; l ^ k; ++l) j &amp; (1 &lt;&lt; l) ? a[i][j] += b[l] : a[i][j] -= b[l]; &#125; build(1, n, 1); int q; cin &gt;&gt; q; while (q--) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; int pos; cin &gt;&gt; pos; for (int i = 0; i ^ k; ++i) cin &gt;&gt; b[i]; memset(a[pos], 0, size * sizeof (int)); for (int i = 0; i ^ size; ++i) for (int j = 0; j ^ k; ++j) i &amp; (1 &lt;&lt; j) ? a[pos][i] += b[j] : a[pos][i] -= b[j]; push_up(pos); &#125; else &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; for (int i = 0; i ^ size; ++i) cal[i][0] = ~(1 &lt;&lt; 31), cal[i][1] = 1 &lt;&lt; 31; push_down(1, n, 1, l, r); int res = 0; for (int i = 0; i ^ size; ++i) res = max(res, cal[i][1] - cal[i][0]); cout &lt;&lt; res &lt;&lt; endl; &#125; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 532 (Div. 2)","slug":"Codeforces Round 532 (Div. 2)","date":"2019-01-17T14:07:58.033Z","updated":"2019-02-07T13:04:13.353Z","comments":true,"path":"2019/01/17/Codeforces Round 532 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round 532 (Div. 2)/","excerpt":"","text":"Codeforces Round #532 (Div. 2) A. Roman and Browser题目大意给定一个长度为$~n~$的$~\\pm1~$串，在不考虑所有角标模$~k~$结果一样的位置上的值，问剩下的和的绝对值的最大值。 题解水题。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n), b(k, 0); for (auto&amp; in : a) cin &gt;&gt; in; int sum = accumulate(a.begin(), a.end(), 0), res = 0; for (int i = 0; i ^ n; ++i) b[i % k] += a[i]; for (auto x : b) res = max(res, abs(sum - x)); cout &lt;&lt; res &lt;&lt; endl;&#125; B. Build a Contest题目大意在可重集合里加入$~m~$个数字，每次加入时如果集合里$~1,~2,~\\dots,~n~$都至少有$~1~$个，则都删去$~1~$个然后输出$~1~$，否则输出$~0~$。数据范围$~1\\leq n,~m\\leq10^5~$。 题解直接暴力地维护这个集合时间复杂度为$~O(nm)~$显然会$~\\text{TLE}~$。不做删除操作，而是开$~2~$个数组维护集合：数组$~tot[i]~$表示有多少种数字在集合里至少有$~i~$个；数组$~cnt[i]~$表示数字$~i~$在集合里出现的次数。那么每加入一个数字$~a~$则更新$~cnt[a]~$和$~tot[cnt[a]]~$，输出$~1~$当且仅当$~tot[cnt[a]]=n~$。总时间复杂度为$~O(m)~$。 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; tot(m, 0), cnt(n, 0); int now = 0; while (m--) &#123; int a; cin &gt;&gt; a; ++tot[cnt[a - 1]++]; if (tot[now] == n) &#123; cout &lt;&lt; 1; ++now; &#125; else &#123; cout &lt;&lt; 0; &#125; &#125; cout &lt;&lt; endl;&#125; C. NN and the Optical Illusion题目大意一个中心圆和$~n~$个外圆外切，外圆半径一样且外切构成一个环，给出中心圆半径$~r~$，输出外圆半径$~R~$。 题解平面几何。答案是$~\\frac{r}{\\csc\\frac{\\pi}{n}-1}~$。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; double n, r; cin &gt;&gt; n &gt;&gt; r; printf(\"%.7f\\n\", r / (1 / sin(acos(-1) / n) - 1));&#125; D. Dasha and Chess题目大意交互题。初始在$~999\\times999~$的国际象棋棋盘上有$~\\text{NN}~$的$~1~$个$~\\text{king}~$和$~\\text{Dasha}~$的$~666~$个$~\\text{rook}~$。由$~\\text{NN}~$先走，规则和国际象棋的$~\\text{king}~$一样但是不能走到任意一个$~\\text{rook}~$所在的位置上（不能不动）。如果$~\\text{NN}~$走完后按国际象棋规则被将军，则获胜。这里的$~\\text{rook}~$的规则是任意闪现到空的位置上且不能将军（可以不动）。要求不能超过$~2000~$回合，否则$~\\text{NN}~$失败。 题解别问为什么，先让$~\\text{king}~$走到中心点$~(500,~500)~$。根据抽屉原理，四个角落必有一角落的$~\\text{rook}~$数量不超过$~166~$，于是在某两个方向上的$~\\text{rook}~$数量之和至少是$~500~$，走斜线必然胜利。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;bool vis[1 &lt;&lt; 10][1 &lt;&lt; 10];pair&lt;int, int&gt; chess[667];void query(int x, int y) &#123; vis[chess-&gt;first][chess-&gt;second] = false; if (vis[chess-&gt;first + x][chess-&gt;second + y]) vis[chess-&gt;first][chess-&gt;second += y] = true; else vis[chess-&gt;first += x][chess-&gt;second += y] = true; cout &lt;&lt; chess-&gt;first &lt;&lt; ' ' &lt;&lt; chess-&gt;second &lt;&lt; endl; int k; cin &gt;&gt; k &gt;&gt; x &gt;&gt; y; if (!~k) exit(0); vis[chess[k].first][chess[k].second] = false; vis[chess[k].first = x][chess[k].second = y] = true;&#125;int main() &#123; for (int i = 0; i ^ 667; ++i) &#123; cin &gt;&gt; chess[i].first &gt;&gt; chess[i].second; vis[chess[i].first][chess[i].second] = true; &#125; while (chess-&gt;first &lt; 500) query(1, 0); while (chess-&gt;first &gt; 500) query(-1, 0); while (chess-&gt;second &lt; 500) query(0, 1); while (chess-&gt;second &gt; 500) query(0, -1); int up_left = 0, down_left = 0, up_right = 0, down_right = 0; for (int i = 1; i ^ 1000; ++i) for (int j = 1; j ^ 1000; ++j) if (vis[i][j]) &#123; if (i &lt; 500 &amp;&amp; j &lt; 500) ++up_left; if (i &gt; 500 &amp;&amp; j &lt; 500) ++down_left; if (i &lt; 500 &amp;&amp; j &gt; 500) ++up_right; if (i &gt; 500 &amp;&amp; j &gt; 500) ++down_right; &#125; int minn = min(min(up_left, down_left), min(up_right, down_right)); if (minn == up_left) while(true) query(1, 1); if (minn == down_left) while(true) query(-1, 1); if (minn == up_right) while(true) query(1, -1); if (minn == down_right) while(true) query(-1, -1);&#125; E. Andrew and Taxi题目大意给一个$~n~$个点$~m~$条边的无自环带边权有向图，通过将边的方向翻转使得新图是一个$~\\text{DAG}~$。问所有翻转的边的边权的最大值最小是多少。 题解对答案二分，那么所有当前二分值以下的边都可以选择翻转或者不翻转。这时如果存在一种变为$~\\text{DAG}~$的翻转方式，当且仅当将所有二分值以下的边删除之后的图是$~\\text{DAG}~$。判断是否有环即可，由于还需要输出翻转的方案，所以用拓扑排序。总时间复杂度为$~O((n+m)\\log c)~$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;vector&lt;int&gt; adj[maxn];bool vis[maxn];int n, m, deg[maxn], topo[maxn];pair&lt;pair&lt;int, int&gt;, int&gt; edge[maxn];bool topo_sort(int lim) &#123; memset(deg, 0, sizeof (deg)); for (int i = 0; i ^ maxn; ++i) adj[i].clear(); for (int i = 1; i &lt;= m; ++i) if (edge[i].second &gt; lim) &#123; adj[edge[i].first.first].push_back(edge[i].first.second); ++deg[edge[i].first.second]; &#125; queue&lt;int&gt; que; for (int i = 0; i ^ maxn; ++i) if (!deg[i]) que.push(i); int rk = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); topo[u] = rk++; for (auto v : adj[u]) if (!--deg[v]) que.push(v); &#125; return rk == maxn;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; edge[i].first.first &gt;&gt; edge[i].first.second &gt;&gt; edge[i].second; int l = -1, r = 0x3f3f3f3f; while (r - l ^ 1) &#123; int m = l + r &gt;&gt; 1; if (topo_sort(m)) r = m; else l = m; &#125; topo_sort(r); vector&lt;int&gt; res; for (int i = 1; i &lt;= m; ++i) if (topo[edge[i].first.first] &gt; topo[edge[i].first.second]) res.push_back(i); cout &lt;&lt; r &lt;&lt; ' ' &lt;&lt; res.size() &lt;&lt; endl; for (auto out : res) &#123; cout &lt;&lt; out; out == res.back() ? cout &lt;&lt; endl : cout &lt;&lt; ' '; &#125;&#125; F. Ivan and Burgers题目大意给定数列$~c_1,~c_2,~\\dots,~c_n~$和$~q~$次询问，问在$~c_l,~c_{l+1},~\\dots,~c_r~$中取若干个数所得到的最大$~\\text{xor}~$和。数据范围$~1\\leq n,~q\\leq5\\cdot10^5,~0\\leq c\\leq10^6~$。 题解显然是个线性基问题，可以用线段树维护，但是递归写法的线段树常数很大会$~\\text{TLE}~$，所以选择常数小的$~\\text{CDQ}~$分治写法。总时间复杂度为$~O((n+q)\\log n\\log c)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 19;int c[maxn];pair&lt;int, int&gt; seg[maxn];struct Vec &#123; vector&lt;int&gt; base; Vec() &#123;base.clear();&#125; Vec(const vector&lt;int&gt;&amp; vec) &#123;base = vec;&#125; bool push(int e) &#123; for (auto v : base) e = min(e, e ^ v); if (e) base.push_back(e); return e; &#125; int max() &#123; int ret = 0; for (auto v : base) ret = std::max(ret, ret ^ v); return ret; &#125; void join(const Vec&amp; vec) &#123;for (auto v : vec.base) push(v);&#125; Vec operator + (const Vec&amp; vec) const &#123; Vec ret(base); ret.join(vec); return ret; &#125; void clear() &#123;base.clear();&#125;&#125;res[maxn], vec[maxn], tmp;void cdq(auto&amp; que,int l, int r) &#123; if (l == r) &#123; for (auto i : que) res[i].push(c[l]); return; &#125; int m = l + r &gt;&gt; 1; tmp.clear(); for (int i = m; i &gt;= l; --i) &#123; tmp.push(c[i]); vec[i] = tmp; &#125; tmp.clear(); for (int i = m + 1; i &lt;= r; ++i) &#123; tmp.push(c[i]); vec[i] = tmp; &#125; vector&lt;int&gt; left, right; for (auto i : que) &#123; if (seg[i].second &lt;= m) left.push_back(i); else if (seg[i].first &gt; m) right.push_back(i); else res[i] = vec[seg[i].first] + vec[seg[i].second]; &#125; que.clear(); cdq(left, l, m); cdq(right, m + 1, r);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; int q; cin &gt;&gt; q; vector&lt;int&gt; que(q); iota(que.begin(), que.end(), 0); for (int i = 0; i ^ q; ++i) cin &gt;&gt; seg[i].first &gt;&gt; seg[i].second; cdq(que, 1, n); for (int i = 0; i ^ q; ++i) cout &lt;&lt; res[i].max() &lt;&lt; '\\n';&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 530 (Div. 2)","slug":"Codeforces Round 530 (Div. 2)","date":"2019-01-17T14:07:58.028Z","updated":"2019-02-07T13:04:10.770Z","comments":true,"path":"2019/01/17/Codeforces Round 530 (Div. 2)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round 530 (Div. 2)/","excerpt":"","text":"Codeforces Round #530 (Div. 2) A. Snowball题目大意山坡滚雪球，每秒雪球会增加当前高度的质量然后下落$~1~$米。有$~2~$个石头，每撞一次减少对应的质量最小变为$~0~$。输雪球滚到坡底的质量。 题解水题。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int w, h, u1, d1, u2, d2; cin &gt;&gt; w &gt;&gt; h &gt;&gt; u1 &gt;&gt; d1 &gt;&gt; u2 &gt;&gt; d2; if (d1 &lt; d2) &#123; swap(u1, u2); swap(d1, d2); &#125; for (int i = h; i &gt;= d1; --i) w += i; w = max(0, w - u1); for (int i = d1 - 1; i &gt;= d2; --i) w += i; w = max(0, w - u2); for (int i = d2 - 1; i; --i) w += i; cout &lt;&lt; w &lt;&lt; endl;&#125; B. Squares and Segments要画$~n~$个$~1\\times1~$的正方形格子，每一笔的长度只能为$~1~$。对于以画出的横（竖）的的线段，可以垂直（水平）地平移复制。问至少要画多少不复制的线段。 题解即输出$~\\min(a+b),~ab\\geq n~$。 代码1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int sqr = sqrt(n + 0.5); if (sqr * sqr == n) cout &lt;&lt; (sqr &lt;&lt; 1) &lt;&lt; endl; else if (sqr * sqr + sqr &gt;= n) cout &lt;&lt; (sqr &lt;&lt; 1) + 1 &lt;&lt; endl; else cout &lt;&lt; (sqr + 1 &lt;&lt; 1) &lt;&lt; endl;&#125; C. Postcard题目大意给一个小写字母和?*组成的字符串。字符?代表前一个字母可以删除或保留，字符*代表前一个字母可以删除或保留或重复若干次。输出任意由它生成的长度为$~k~$的字符串或不存在。 题解直接模拟。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; int k; cin &gt;&gt; str &gt;&gt; k; int cnt = 0, tot = 0; for (auto ch : str) &#123; if (ch == '?') ++cnt; if (ch == '*') ++tot; &#125; if (k &lt; str.size() - (cnt + tot &lt;&lt; 1) || !tot &amp;&amp; k &gt; str.size() - cnt) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; string res; int rem = k - str.size() + cnt + tot; if (rem &gt; 0) &#123; bool flag = true; for (auto ch : str) &#123; if (isalpha(ch)) res.push_back(ch); if (ch == '*' &amp;&amp; flag) &#123; flag = false; while (rem--) res.push_back(res.back()); &#125; &#125; &#125; else &#123; for (auto ch : str) &#123; if (isalpha(ch)) &#123; res.push_back(ch); &#125; else if (rem) &#123; res.pop_back(); ++rem; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; D. Sum in the tree题目大意有一颗非负点权树，根的深度为$~1~$。给出根到所有奇数深度的点的链上的点权值之和$~s_u=\\sum_{v\\in L(1,~u)}a_v,~2\\nmid dep_u~$。输出最小的可能的点权之和$~\\sum_{i=1}^{n}a_i~$或不存在。 题解对于偶数度数的点的$~s_u~$值，取所有儿子的最大值，再和它的父亲比较合法性即可。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; son(n + 1); vector&lt;int&gt; p(n + 1); vector&lt;long long&gt; s(n + 1, 0); for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i]; son[p[i]].push_back(i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; if (~s[i] &amp;&amp; i ^ 1 &amp;&amp; s[i] &lt; s[p[p[i]]]) return cout &lt;&lt; -1 &lt;&lt; endl, 0; &#125; queue&lt;int&gt; que; que.push(1); long long res = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (auto v : son[u]) que.push(v); if (!~s[u]) &#123; s[u] = 0x3f3f3f3f3f3f3f3f; for (auto v : son[u]) s[u] = min(s[u], s[v]); if (s[u] == 0x3f3f3f3f3f3f3f3f) s[u] = s[p[u]]; &#125; res += s[u] - s[p[u]]; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; E. Nice table题目大意给一个由$~\\text{ATCG}~$组成的字母矩阵，输出一个同样大小的的字母矩阵满足所有$~2\\times2~$均由$~\\text{ATCG}~$组成，且使的两矩阵尽量相同。 题解对于任意的合法矩阵，若第$~1~$行的字母超过$~2~$个，则不难推断出每列均由$~2~$个字母组成且奇偶性相同的列所用的字母组成一样。于是合法矩阵必满足每行（或列）均由$~2~$个字母组成，且相同的行（或列）所用的字母组成一样。枚举头$~2~$个字母组成的所有情况即可。考验代码能力。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;char&gt; ch&#123;'A', 'T', 'C', 'G'&#125;; vector&lt;int&gt; p(4); iota(p.begin(), p.end(), 0); int n, m; cin &gt;&gt; n &gt;&gt; m; string res, str, tmp(n * m, '#'); for (int i = 0; i ^ n * m; ++i) &#123; char ch; cin &gt;&gt; ch; str += ch; &#125; int same = 0; do &#123; int tot = 0, cnt[2]; for (int i = 0; i ^ n; ++i) &#123; cnt[0] = cnt[1] = 0; for (int j = 0; j ^ m; ++j) for (int k = 0; k ^ 2; ++k) if (str[i * m + j] == ch[p[(i &amp; 1) &lt;&lt; 1 ^ k]]) ++cnt[(j ^ k) &amp; 1]; if (cnt[0] &lt; cnt[1]) for (int j = 0; j ^ m; ++j) tmp[i * m + j] = ch[p[(i &amp; 1) &lt;&lt; 1 ^ j &amp; 1 ^ 1]]; else for (int j = 0; j ^ m; ++j) tmp[i * m + j] = ch[p[(i &amp; 1) &lt;&lt; 1 ^ j &amp; 1]]; tot += max(cnt[0], cnt[1]); &#125; if (same &lt; tot) &#123; same = tot; res = tmp; &#125; tot = 0; for (int j = 0; j ^ m; ++j) &#123; cnt[0] = cnt[1] = 0; for (int i = 0; i ^ n; ++i) for (int k = 0; k ^ 2; ++k) if (str[i * m + j] == ch[p[(j &amp; 1) &lt;&lt; 1 ^ k]]) ++cnt[(i ^ k) &amp; 1]; if (cnt[0] &lt; cnt[1]) for (int i = 0; i ^ n; ++i) tmp[i * m + j] = ch[p[(j &amp; 1) &lt;&lt; 1 ^ i &amp; 1 ^ 1]]; else for (int i = 0; i ^ n; ++i) tmp[i * m + j] = ch[p[(j &amp; 1) &lt;&lt; 1 ^ i &amp; 1]]; tot += max(cnt[0], cnt[1]); &#125; if (same &lt; tot) &#123; same = tot; res = tmp; &#125; &#125; while (next_permutation(p.begin(), p.end())); for (int i = 0; i ^ n; ++i) &#123; for (int j = 0; j ^ m; ++j) cout &lt;&lt; res[i * m + j]; cout &lt;&lt; endl; &#125;&#125; F. Cookies题目大意给定一颗大小为$~n~$的树，根为$~1~$，每个节点上$~i~$有$~x_i~$个饼干，每个饼干要花费$~t_i~$的时间吃掉，经过连接节点$~u\\neq1~$和它父亲的边的时间花费为$~l_u~$。游戏开始前$~\\text{Mitya}~$在根节点，每一回合$~\\text{Mitya}~$走向当前节点的某一儿子，然后$~\\text{Vasya}~$剪去$~\\text{Mitya}~$所在节点与某一儿子的路径。当$~\\text{Mitya}~$选择结束时他必须通过简单路径走回根节点，过程中可以吃路上的饼干。在总时间花费不超过$~T~$的条件下，问$~\\text{Mitya}~$最多能吃多少饼干。数据范围$~2\\leq n\\leq10^5,~1\\leq T\\leq10^{18},~1\\leq x_i\\leq10^6,~1\\leq t_i\\leq10^6,~0\\leq l_i\\leq10^9~$。 题解先不考虑$~\\text{Vasya}~$的选择。对于每个节点$~u~$，计算它到根节点的路径上$~\\text{Mitya}~$最多能吃到的饼干数量$~cal_u~$。显然为了最大化$~cal_u~$，必须先吃路径上花费时间少的饼干。注意到$~t~$的数据范围，那么可以在$~\\text{dfs}~$过程中维护节点$~u~$到根节点的$~L(u,~1)~$这条路径上单位时间花费为$~t~$的饼干数量$~cnt_t~$。于是当前节点的答案就是在$~T-2\\sum_v l_v,~v\\in L(u,~1)~$的范围内最大化$~cnt~$的前缀和。这个过程可以用二分树状数组，线段树二分，或者树状数组二分来维护。在计算出所有的$~cal_i,~1\\leq i\\leq n~$之后，考虑终点在节点$~u~$的子树上时的答案$~res_u~$。若$~u~$为叶节点，则$~res_u=cal_u~$。若$~u~$为非根非叶节点，考虑到$~\\text{Vasya}~$的存在，则$~res_u=\\max(cal_u,~res_v)~$，其中$~res_v~$为$~u~$的所有儿子的次大$~res~$值给根节点$~1~$增加一个$~cal=\\inf~$的儿子，则可以$~\\text{DFS}~$线性地计算出最终答案$~res_1~$。总时间复杂度为：二分树状数组$~O(n\\log^2n)~$，线段树二分$~O(n\\log n)~$，树状数组二分$~O(n\\log n)~$。据说我的树状数组二分写法就是$~\\text{zkw}~$，但是由于$~\\text{Codeforces}~$的玄学优化，上面$~3~$种数据结构速度基本一样。。。 代码（二分树状数组$~O(n\\log^2n)~$）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;const int maxt = 1 &lt;&lt; 20;int p[maxn], t[maxn];bool vis[maxn], cut[maxn];long long x[maxn], l[maxn], cal[maxn], bit1[maxt], bit2[maxt];vector&lt;int&gt; son[maxn];#define lowbit(x) (x &amp; -x)void dfs1(int u, long long rem) &#123; rem -= l[u] &lt;&lt; 1; for (int i = t[u]; i &lt; maxt; i += lowbit(i)) bit1[i] += x[u], bit2[i] += x[u] * t[u]; if (rem &gt; 0) &#123; int l = 0, r = maxt - 1; long long sum = 0; for (int i = r; i; i -= lowbit(i)) cal[u] += bit1[i], sum += bit2[i]; if (sum &gt; rem) &#123; while (r - l ^ 1) &#123; int mid = l + r &gt;&gt; 1; sum = 0; for (int i = mid; i; i -= lowbit(i)) sum += bit2[i]; if (sum &gt; rem) r = mid; else l = mid; &#125; cal[u] = sum = 0; for (int i = l; i; i -= lowbit(i)) cal[u] += bit1[i], sum += bit2[i]; cal[u] += (rem - sum) / r; &#125; &#125; for (auto v : son[u]) dfs1(v, rem); for (int i = t[u]; i &lt; maxt; i += lowbit(i)) bit1[i] -= x[u], bit2[i] -= x[u] * t[u];&#125;long long dfs2(int u) &#123; long long max1 = u ^ 1 ? 0 : 0x3f3f3f3f3f3f3f3f, max2 = 0; for (auto v : son[u]) &#123; long long temp = dfs2(v); if (max2 &lt; temp) max2 = temp; if (max1 &lt; max2) swap(max1, max2); &#125; return max(max2, cal[u]);&#125;int main() &#123; int n; long long T; cin &gt;&gt; n &gt;&gt; T; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; x[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; t[i]; for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i] &gt;&gt; l[i]; son[p[i]].push_back(i); &#125; dfs1(1, T); cout &lt;&lt; dfs2(1) &lt;&lt; endl;&#125; 代码（线段树二分$~O(n\\log n)~$）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;const int maxt = 1 &lt;&lt; 20;int p[maxn], t[maxn];long long x[maxn], l[maxn], cal[maxn], seg1[maxt &lt;&lt; 2], seg2[maxt &lt;&lt; 2];vector&lt;int&gt; son[maxn];void push_up(int begin, int end, int index, int pos, long long del) &#123; seg1[index] += del; seg2[index] += del * pos; if (begin + 1 == end) return; int mid = begin + end &gt;&gt; 1; if (pos &gt; mid) push_up(mid, end, index &lt;&lt; 1 ^ 1, pos, del); else push_up(begin, mid, index &lt;&lt; 1, pos, del);&#125;long long push_down(int begin, int end, int index, long long rem) &#123; if (begin + 1 == end) return min(rem / end, seg1[index]); int mid = begin + end &gt;&gt; 1; return rem &lt; seg2[index &lt;&lt; 1] ? push_down(begin, mid, index &lt;&lt; 1, rem) : seg1[index &lt;&lt; 1] + push_down(mid, end, index &lt;&lt; 1 ^ 1, rem - seg2[index &lt;&lt; 1]); &#125;void dfs1(int u, long long rem) &#123; push_up(0, maxt, 1, t[u], x[u]); if ((rem -= l[u] &lt;&lt; 1) &gt; 0) cal[u] = push_down(0, maxt, 1, rem); for (auto v : son[u]) dfs1(v, rem); push_up(0, maxt, 1, t[u], -x[u]);&#125;long long dfs2(int u) &#123; long long max1 = u ^ 1 ? 0 : 0x3f3f3f3f3f3f3f3f, max2 = 0; for (auto v : son[u]) &#123; long long temp = dfs2(v); if (max2 &lt; temp) max2 = temp; if (max1 &lt; max2) swap(max1, max2); &#125; return max(max2, cal[u]);&#125;int main() &#123; int n; long long T; cin &gt;&gt; n &gt;&gt; T; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; x[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; t[i]; for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i] &gt;&gt; l[i]; son[p[i]].push_back(i); &#125; dfs1(1, T); cout &lt;&lt; dfs2(1) &lt;&lt; endl;&#125; 代码（树状数组二分$~O(n\\log n)~$）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;const int maxt = 1 &lt;&lt; 20;int p[maxn], t[maxn];bool vis[maxn], cut[maxn];long long x[maxn], l[maxn], cal[maxn], bit1[maxt + 1], bit2[maxt + 1];vector&lt;int&gt; son[maxn];#define lowbit(x) (x &amp; -x)void dfs1(int u, long long rem) &#123; for (int i = t[u]; i &lt; maxt; i += lowbit(i)) bit1[i] += x[u], bit2[i] += x[u] * t[u]; int now = maxt; long long temp = (rem -= l[u] &lt;&lt; 1); for (int i = maxt, j = 0; rem &gt; 0; i &gt;&gt;= 1) &#123; if (i == 1) &#123; cal[u] += j &amp; 1 ? min(temp / (j + 1), bit1[j + 1] - bit1[j]) : min(temp / (j ^ 1), bit1[j ^ 1]); break; &#125; if (temp &gt; bit2[i &gt;&gt; 1 ^ j]) &#123; cal[u] += bit1[i &gt;&gt; 1 ^ j]; temp -= bit2[i &gt;&gt; 1 ^ j]; j ^= i &gt;&gt; 1; &#125; &#125; for (auto v : son[u]) dfs1(v, rem); for (int i = t[u]; i &lt; maxt; i += lowbit(i)) bit1[i] -= x[u], bit2[i] -= x[u] * t[u];&#125;long long dfs2(int u) &#123; long long max1 = u ^ 1 ? 0 : 0x3f3f3f3f3f3f3f3f, max2 = 0; for (auto v : son[u]) &#123; long long temp = dfs2(v); if (max2 &lt; temp) max2 = temp; if (max1 &lt; max2) swap(max1, max2); &#125; return max(max2, cal[u]);&#125;int main() &#123; int n; long long T; cin &gt;&gt; n &gt;&gt; T; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; x[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; t[i]; for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i] &gt;&gt; l[i]; son[p[i]].push_back(i); &#125; dfs1(1, T); cout &lt;&lt; dfs2(1) &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 530 (Div. 1) (TBC)","slug":"Codeforces Round 530 (Div. 1) (TBC)","date":"2019-01-17T14:07:58.024Z","updated":"2019-02-07T13:04:08.724Z","comments":true,"path":"2019/01/17/Codeforces Round 530 (Div. 1) (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round 530 (Div. 1) (TBC)/","excerpt":"","text":"Codeforces Round #530 (Div. 1) A. Sum in the tree题目大意有一颗非负点权树，根的深度为$~1~$。给出根到所有奇数深度的点的链上的点权值之和$~s_u=\\sum_{v\\in L(1,~u)}a_v,~2\\nmid dep_u~$。输出最小的可能的点权之和$~\\sum_{i=1}^{n}a_i~$或不存在。 题解对于偶数度数的点的$~s_u~$值，取所有儿子的最大值，再和它的父亲比较合法性即可。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; son(n + 1); vector&lt;int&gt; p(n + 1); vector&lt;long long&gt; s(n + 1, 0); for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; p[i]; son[p[i]].push_back(i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; if (~s[i] &amp;&amp; i ^ 1 &amp;&amp; s[i] &lt; s[p[p[i]]]) return cout &lt;&lt; -1 &lt;&lt; endl, 0; &#125; queue&lt;int&gt; que; que.push(1); long long res = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (auto v : son[u]) que.push(v); if (!~s[u]) &#123; s[u] = 0x3f3f3f3f3f3f3f3f; for (auto v : son[u]) s[u] = min(s[u], s[v]); if (s[u] == 0x3f3f3f3f3f3f3f3f) s[u] = s[p[u]]; &#125; res += s[u] - s[p[u]]; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125; B. Nice table题目大意给一个由$~\\text{ATCG}~$组成的字母矩阵，输出一个同样大小的的字母矩阵满足所有$~2\\times2~$均由$~\\text{ATCG}~$组成，且使的两矩阵尽量相同。 题解对于任意的合法矩阵，若第$~1~$行的字母超过$~2~$个，则不难推断出每列均由$~2~$个字母组成且奇偶性相同的列所用的字母组成一样。于是合法矩阵必满足每行（或列）均由$~2~$个字母组成，且相同的行（或列）所用的字母组成一样。枚举头$~2~$个字母组成的所有情况即可。考验代码能力。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;char&gt; ch&#123;'A', 'T', 'C', 'G'&#125;; vector&lt;int&gt; p(4); iota(p.begin(), p.end(), 0); int n, m; cin &gt;&gt; n &gt;&gt; m; string res, str, tmp(n * m, '#'); for (int i = 0; i ^ n * m; ++i) &#123; char ch; cin &gt;&gt; ch; str += ch; &#125; int same = 0; do &#123; int tot = 0, cnt[2]; for (int i = 0; i ^ n; ++i) &#123; cnt[0] = cnt[1] = 0; for (int j = 0; j ^ m; ++j) for (int k = 0; k ^ 2; ++k) if (str[i * m + j] == ch[p[(i &amp; 1) &lt;&lt; 1 ^ k]]) ++cnt[(j ^ k) &amp; 1]; if (cnt[0] &lt; cnt[1]) for (int j = 0; j ^ m; ++j) tmp[i * m + j] = ch[p[(i &amp; 1) &lt;&lt; 1 ^ j &amp; 1 ^ 1]]; else for (int j = 0; j ^ m; ++j) tmp[i * m + j] = ch[p[(i &amp; 1) &lt;&lt; 1 ^ j &amp; 1]]; tot += max(cnt[0], cnt[1]); &#125; if (same &lt; tot) &#123; same = tot; res = tmp; &#125; tot = 0; for (int j = 0; j ^ m; ++j) &#123; cnt[0] = cnt[1] = 0; for (int i = 0; i ^ n; ++i) for (int k = 0; k ^ 2; ++k) if (str[i * m + j] == ch[p[(j &amp; 1) &lt;&lt; 1 ^ k]]) ++cnt[(i ^ k) &amp; 1]; if (cnt[0] &lt; cnt[1]) for (int i = 0; i ^ n; ++i) tmp[i * m + j] = ch[p[(j &amp; 1) &lt;&lt; 1 ^ i &amp; 1 ^ 1]]; else for (int i = 0; i ^ n; ++i) tmp[i * m + j] = ch[p[(j &amp; 1) &lt;&lt; 1 ^ i &amp; 1]]; tot += max(cnt[0], cnt[1]); &#125; if (same &lt; tot) &#123; same = tot; res = tmp; &#125; &#125; while (next_permutation(p.begin(), p.end())); for (int i = 0; i ^ n; ++i) &#123; for (int j = 0; j ^ m; ++j) cout &lt;&lt; res[i * m + j]; cout &lt;&lt; endl; &#125;&#125; C. Construct a tree题目大意给定两个数$~n~$和$~s~$，输出一个大小为$~n~$的树满足所有子树的大小之和为$~s~$或不存在，若存在输出的树必须满足最大分叉$~k~$尽量小。数据范围$~2\\leq n\\leq10^5,~1\\leq s\\leq10^{10}~$。 题解考虑所有节点$~u~$对于$~s~$的贡献，当且仅当子树的根$~v~$为$~u~$的祖先时，$~u~$才会对答案贡献$~1~$。所以$~s=\\sum_{i=1}^{n}dep_i\\in[2n-1,~\\frac{n(n+1)}{2}]~$。对于$~k~$叉树，$~s~$值的下限随着$~k~$增大减小。所以考虑二分，可以得出最小的$~k~$值。先构造出最小的$~k-1~$叉树，然后移动深的点即可。时间复杂度为$~O(n\\log n)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int num[maxn], lim[maxn], dep[maxn], sta[maxn], son[maxn];int main() &#123; int n; long long s; cin &gt;&gt; n &gt;&gt; s; if (1LL * n * (n + 1) &lt; s &lt;&lt; 1 || n &lt;&lt; 1 &gt; s + 1) return cout &lt;&lt; \"No\" &lt;&lt; endl, 0; cout &lt;&lt; \"Yes\" &lt;&lt; endl; if (1LL * n * (n + 1) == s &lt;&lt; 1) &#123; cout &lt;&lt; 1; for (int i = 2; i ^ n; ++i) cout &lt;&lt; ' ' &lt;&lt; i; cout &lt;&lt; endl; return 0; &#125; int l = 1, r = n - 1; while (r - l ^ 1) &#123; int m = l + r &gt;&gt; 1; long long rem = n - 1, cnt = 1, cal = 1; for (int i = 2; rem; ++i) &#123; cnt *= m; if (rem &lt; cnt) cal += rem * i, rem = 0; else cal += cnt * i, rem -= cnt; &#125; cal &gt; s ? (l = m) : (r = m); &#125; int right = r; long long flr = 1; for (int i = 1, tot = 0; tot ^ n; ++i, flr *= l) &#123; if (tot + flr &gt; n) num[i] = n - tot, tot = n; else num[i] = flr, tot += flr; &#125; lim[1] = 1; for (int i = 1; 1LL * lim[i] * r &lt; n &lt;&lt; 1; ++i) lim[i + 1] = lim[i] * r; long long cnt = 0; for (r = 1; num[r]; ++r) cnt += 1LL * r * num[r]; l = 2; cnt -= s; while (cnt) &#123; if (num[l] == lim[l]) ++l; if (!num[r]) --r; if (cnt &lt; r - l) &#123; --num[r]; ++num[r - cnt]; break; &#125; --num[r]; ++num[l]; cnt += l - r; &#125; sta[1] = 1; for (int i = 1, d = 1; i &lt;= n; ++i) &#123; dep[i] = d; if (!--num[d]) sta[++d] = i + 1; &#125; for (int i = 2; i ^ n; ++i) &#123; cout &lt;&lt; sta[dep[i] - 1] &lt;&lt; ' '; if (++son[sta[dep[i] - 1]] == right) ++sta[dep[i] - 1]; &#125; cout &lt;&lt; sta[dep[n] - 1] &lt;&lt; endl;&#125; D. Eels题目大意大鱼吃小鱼，小鱼吃虾米。鱼缸里如果有$~n~$条鱼，则会发生$~n-1~$次生死$~\\text{solo}~$，最终一人吃鸡。小鱼被大鱼吃掉后质量也送给了大鱼，类似于球球大作战。定义质量为$~a\\leq b~$的两条鱼生死$~\\text{solo}~$是危险的，如果$~a\\leq b\\leq2a~$。一个鱼缸的危险值定义为最多可能发生的危险$~\\text{solo}~$次数。最开始鱼缸为空，每次加一条或者减一条质量为$~x~$的鱼，输出每次的危险值。数据范围$~1\\leq q\\leq5\\cdot10^5,~1\\leq x\\leq10^9~$。 题解对所有鱼的质量升序得到$~a_1,~a_2,~\\dots,~a_n~$。定义如果$~a_i&gt;2\\sum_{j&lt; i}a_j~$，则称它为肥鱼（算上第一只$~a_1~$）。设当前鱼缸有$~k~$只肥鱼，则下面证明危险值为$~n-k~$： 对于肥鱼，它一定不会在危险$~\\text{solo}~$中作为大鱼出现，所以危险值的上限为$~n-k~$。 在每次选择最小的两只鱼$~\\text{solo}~$，这样危险$~\\text{solo}~$的总次数为$~n-k~$。所以现在对于每次操作，算出当前的$~k~$值即可。考虑区间$~[1,~2),~[2,~4),~\\dots,~[2^m,~2^{m+1}),~\\dots~$，显然每个区间至多一只肥鱼。那么用$~\\text{multiset}~$来维护每个区间的鱼，这样每次操作就能在$~O(\\log q\\log x)~$内算出$~k~$值。总时间复杂度为$~O(q\\log q\\log x)~$。 注意数据范围过大，可能需要$~\\text{fastIO}~$。 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); multiset&lt;long long&gt; seg[32]; long long sum[32] = &#123;0&#125;; int q, cnt = 0; cin &gt;&gt; q; while (q--) &#123; char op; long long x; cin &gt;&gt; op &gt;&gt; x; int idx = 0; for (int i = 1; i &lt; x; i &lt;&lt;= 1, ++idx); if (op == '+') &#123; seg[idx].insert(x); sum[idx] += x; ++cnt; &#125; else &#123; seg[idx].erase(seg[idx].find(x)); sum[idx] -= x; --cnt; &#125; int res = cnt; long long tot = 0; for (int i = 0; i ^ 32; tot += sum[i++]) if (sum[i] &amp;&amp; *(seg[i].begin()) &gt; tot &lt;&lt; 1) --res; cout &lt;&lt; res &lt;&lt; '\\n'; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 527 (Div. 3) (TBC)","slug":"Codeforces Round 527 (Div. 3) (TBC)","date":"2019-01-17T14:07:58.020Z","updated":"2019-02-07T13:04:06.866Z","comments":true,"path":"2019/01/17/Codeforces Round 527 (Div. 3) (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round 527 (Div. 3) (TBC)/","excerpt":"","text":"Codeforces Round #527 (Div. 3) A. Uniform String题目大意输出任意长度为$~n~$且由前$~k~$个小写字母组成的串，要求出现次数最少的尽量多。 题解水题。 代码12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; while (n--) cout &lt;&lt; char('a' + n % k); cout &lt;&lt; endl; &#125;&#125; B. Teams Forming题目大意给$~n~$个数字，每个数字可以加若干次$~1~$，求最少次数使得这$~n~$个数字可以两两配对，每对都一样大。 题解水题。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, a[100]; cin &gt;&gt; n; for (int i = 0; i ^ n; ++i) cin &gt;&gt; a[i]; sort(a, a + n); int res = 0; for (int i = 0; i ^ n; ++i) res += i &amp; 1 ? a[i] : -a[i]; cout &lt;&lt; res &lt;&lt; endl;&#125; C. Prefixes and Suffixes题目大意一个长度为$~n~$的串的$~n-1~$个前缀和后缀打乱顺序给出。输出任意合法的划分，使得存在一个长度为$~n~$的串，它的所有前缀和后缀均和该划分一致。 题解暴力先枚举两个给定串合成的长度为$~n~$的串然后判断。代码的时间复杂度上限是$~O(n^3)~$，但在枚举的过程中最多$~4~$次即可枚举出合法的原串，所以实际时间复杂度为$~O(n^2)~$。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int size = n - 1 &lt;&lt; 1; vector&lt;string&gt; strs(size), fuck[n]; for (auto&amp; str : strs) &#123; cin &gt;&gt; str; fuck[(int)str.size()].push_back(str); &#125; set&lt;string&gt; ggsimida; for (int i = 1; i ^ n; ++i) for (int j = 0; j ^ 2; ++j) for (int k = 0; k ^ 2; ++k) &#123; string now = fuck[i][j] + fuck[n - i][k]; if (ggsimida.find(now) != ggsimida.end()) continue; vector&lt;bool&gt; use(size, false); string res(size, 0); int cal = 0; for (int len = 1; len ^ n; ++len) &#123; string pre(now, 0, len); for (int idx = 0; idx ^ size; ++idx) if (!use[idx] &amp;&amp; strs[idx] == pre) &#123; use[idx] = true; res[idx] = 'P'; ++cal; break; &#125; string suf(now, len, n - len); for (int idx = 0; idx ^ size; ++idx) if (!use[idx] &amp;&amp; strs[idx] == suf) &#123; use[idx] = true; res[idx] = 'S'; ++cal; break; &#125; &#125; if (cal == size) return cout &lt;&lt; res &lt;&lt; endl, 0; ggsimida.insert(now); &#125;&#125; D1. Great Vova Wall (Version 1)题目大意铺砖，宽度为$~n~$，初始每个位置已经铺了一些$~1\\times1~$的砖在最下面。问是否能继续放若干个$~2\\times1~$的砖（横竖均可），使得最后顶面是平的。 题解考虑黑白染色，可以铺平当前仅当黑白数量一致。 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int cnt = 0; while (n--) &#123; int a; cin &gt;&gt; a; (n ^ a) &amp; 1 ? ++cnt : --cnt; &#125; if (abs(cnt) &lt; 2) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl;&#125; D2. Great Vova Wall (Version 2)题目大意上一题的基础上禁止竖着放砖。 题解单调栈模拟。 代码1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; stack&lt;int&gt; fuck; int shit = 0; while (n--) &#123; int a; cin &gt;&gt; a; shit = max(shit, a); if (fuck.empty()) fuck.push(a); else if (fuck.top() &lt; a) return cout &lt;&lt; \"NO\" &lt;&lt; endl, 0; else if (fuck.top() == a) fuck.pop(); else fuck.push(a); &#125; if (fuck.empty() || fuck.size() == 1 &amp;&amp; fuck.top() == shit) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl;&#125; E. Minimal Diameter ForestF. Tree with Maximum Cost题目大意给定一个大小为$~n~$的有点权树，两点之间的距离定义为最短路径上的边数。定义$~cost(u)=\\sum_{v=1}^n{dist(u,~v)\\cdot a_i}~$，求$~\\min{cost(u)}~$。 题解考虑相邻两个点$~u~$和$~v~$之间的答案转移。删去$~edge(u,~v)~$，则原树被划分为两个子树，记点集分别为$~S_u~$和$~S_v~$。则有等式 \\begin{aligned} res_u+\\sum_{i\\in S_u}{a_i} &=res_v+\\sum_{S_v}{a_i} \\\\ res_u &=res_v+\\sum_{i=1}^n{a_i}-2\\sum_{i\\in S_u}{a_i} \\\\ \\end{aligned}那么任取一点为根，第一遍$~\\text{DFS}~$找出对于所有子树上子树根的$~cost~$和子树的权值之和$~\\sum_{i\\in S_u}{a_i}~$，第二遍$~\\text{DFS}~$更新所有点的答案。时间复杂度为$~O(n)~$。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;long long a[maxn], res[maxn], ans;vector&lt;int&gt; adj[maxn];long long dfs1(int u = 1, int p = 0) &#123; for (auto v : adj[u]) if (v ^ p) res[u] += dfs1(v, u), a[u] += a[v]; return res[u] += a[u];&#125;void dfs2(int u = 1, int p = 0) &#123; ans = max(ans, res[u] = res[p] + a[1] - (a[u] &lt;&lt; 1)); for (auto v : adj[u]) if (v ^ p) dfs2(v, u);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; while (--n) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); adj[v].push_back(u); &#125; res[0] = dfs1(); dfs2(); cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Codeforces Round 526 (Div. 2) (TBC)","slug":"Codeforces Round 526 (Div. 2) (TBC)","date":"2019-01-17T14:07:58.013Z","updated":"2019-02-07T13:04:04.119Z","comments":true,"path":"2019/01/17/Codeforces Round 526 (Div. 2) (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Codeforces Round 526 (Div. 2) (TBC)/","excerpt":"","text":"Codeforces Round #526 (Div. 2) A. The Fair Nut and Elevator题目大意有$~N~$个楼层，第$~i~$层住着$~a_i~$个人。每天每人都要坐两次电梯，第一次从第$~i~$层坐电梯到第$~1~$层，第二次从第$~1~$层坐电梯到第$~i~$层。电梯一次只能载一个人且有一个初始位置第$~x~$层。电梯的运行每次必须先从第$~x~$层到起点层，再到终点层，再回到$~x~$层。求$~x~$的最优解使得每天电梯的运行距离最短，输出这个最短距离。 题解水题。贪心。显然$~x=1~$是最优解。输出$~4\\sum a_i(i-1)~$即可。证明略。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int res = 0; for (int i = 0; i ^ n; ++i) &#123; int a; cin &gt;&gt; a; res += a * i; &#125; cout &lt;&lt; (res &lt;&lt; 2) &lt;&lt; endl;&#125; B. Kvass and the Fair Nut题目大意给定$~n~$个数$~v_1,~v_2,~\\dots,~v_n~$，让他们一共减去$~s~$，使得最小值最大，输出这个最小值。 题解贪心。有巨坑。说多都是泪。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; long long s; cin &gt;&gt; n &gt;&gt; s; long long minn = 0x3f3f3f3f3f3f3f3f, sum = 0; for (int i = 0; i ^ n; ++i) &#123; long long v; cin &gt;&gt; v; minn = min(minn, v); sum += v; &#125; if (sum &lt; s) cout &lt;&lt; -1 &lt;&lt; endl; else if (n * minn + s &lt; sum) cout &lt;&lt; minn &lt;&lt; endl; else cout &lt;&lt; (sum - s) / n &lt;&lt; endl;&#125; C. The Fair Nut and String题目大意给定一个小写字母串，求生成的全$~a~$串数量，满足相邻的两个$~a~$在原串中必有一个$~b~$在这两个$~a~$之间。 题解水题。原串中相邻的两个$~b~$之间若有$~n~$个$~a~$，则至多在这$~n~$个$~a~$中选$~1~$个，显然有$~n+1~$种选法（包括不选）。答案则是$~{\\prod(n_i+1)}-1~$，因为要减去空串。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; const int mod = 1e9 + 7; int res = 1, cnt = 1; for (auto ch : str) &#123; if (ch == 'a') ++cnt; if (ch == 'b') res = 1LL * res * cnt % mod, cnt = 1; &#125; cout &lt;&lt; 1LL * res * cnt % mod - 1 &lt;&lt; endl;&#125; D. The Fair Nut and the Best Path题目大意给一个树，有非负整数点权$~w~$和正整数边权$~c~$，一条链的值为$~\\sum{w}-\\sum{c}~$。求出最大的链值（单个点视为退化链也算）。 题解树形$~\\text{DP}~$。任取一个点为树根，每个点记录以它为一个端点，另一个端点为它后代的最大链值$~x~$，对于叶子有$~x=c~$。那么考虑经过点$~u~$且在以$~u~$为根的子树上的链的最大值$~max_u~$，对$~u~$的所有儿子$~v~$的$~x_v~$值与连接它们的边权$~w_v~$做差，加入两个$~x=w=0~$的虚点，则可以用这些差$~x_v-w_v~$的最大值来更新$~x_u~$，最大值和次大值来更新$~max_u~$。于是可以在$~\\text{DFS}~$过程中线性地更新出答案。由于数据范围允许时间复杂度为$~O(n\\log{n})~$，于是可以用排序来简化求最大值和次大值的代码。 已更新简便线性做法。 代码（$~O(n\\log{n})~$）123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;long long c[maxn];vector&lt;pair&lt;int, long long&gt;&gt; adj[maxn];long long dfs(int u = 1, int p = 0) &#123; long long ret = 0; vector&lt;long long&gt; sons(2, 0LL); for (auto son : adj[u]) if (son.first ^ p) &#123; ret = max(ret, dfs(son.first, u)); sons.push_back(c[son.first] - son.second); &#125; sort(sons.begin(), sons.end()); reverse(sons.begin(), sons.end()); c[u] += sons[0]; return max(ret, c[u] + sons[1]);&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; while (--n) &#123; int u, v; long long w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; adj[u].push_back(make_pair(v, w)); adj[v].push_back(make_pair(u, w)); &#125; cout &lt;&lt; dfs() &lt;&lt; endl;&#125; 代码（$~O(n)~$）123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;long long c[maxn], dp[maxn], res;vector&lt;pair&lt;int, long long&gt;&gt; adj[maxn];void dfs(int u = 1, int p = 0) &#123; res = max(res, dp[u] = c[u]); for (auto v : adj[u]) if (v.first ^ p) &#123; dfs(v.first, u); res = max(res, dp[u] + dp[v.first] - v.second); dp[u] = max(dp[u], c[u] + dp[v.first] - v.second); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; while (--n) &#123; int u, v; long long w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; adj[u].push_back(make_pair(v, w)); adj[v].push_back(make_pair(u, w)); &#125; dfs(); cout &lt;&lt; res &lt;&lt; endl;&#125; E. The Fair Nut and Strings题目大意找出$~k~$个长度为$~n~$且字典序在$~s~$和$~t~$之间的$~ab~$串，使得不一样的前缀的数量最多，输出最大的不同前缀数。 题解考虑所有$~ab~$串构成的$~\\text{trie}~$树，这显然是一个完全二叉树。再考虑所求的$~k~$个$~ab~$串构成的$~\\text{trie}~$树，则答案是节点数量，且第$~i~$层的节点数量至多为$~\\min{|t_i|-|s_i|,~k}~$个。其中$~|str_i|~$表示字符串$~str~$前$~i~$个字符构成的前缀所对应的二进制数值。自上而下模拟更新答案即可。 代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, k; string s, t; cin &gt;&gt; n &gt;&gt; k &gt;&gt; s &gt;&gt; t; long long res = 1LL * n * k; for (int i = 0, dif = 0; i ^ n &amp;&amp; (dif = (dif &lt;&lt; 1) + (t[i] == 'b') - (s[i] == 'b')) &lt; k; ++i) res -= k - dif - 1; cout &lt;&lt; res &lt;&lt; endl;&#125; F. Max Mex题目大意给一棵大小为$~n~$的树，所有节点的初始值为$~0,~1,~\\dots,~n-1~$的一个全排列。对于这棵树上的任意一条链$~l~$，$~V(l)~$表示$~l~$上所有点的集合。有$~q~$次修改或查询操作，修改为交换$~2~$个节点的值，查询为输出$~\\max{mex(V(l))}~$。 注：$~mex(S)~$表示不在集合$~S~$中的最小自然数，即$~\\min{x\\in\\Bbb{N}:x\\not\\in S}~$。 题解老子现在不会。据说是线段树维护各值所在点之间的连接关系。","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"Avito Cool Challenge 2018 (TBC)","slug":"Avito Cool Challenge 2018 (TBC)","date":"2019-01-17T14:07:57.977Z","updated":"2019-01-17T14:08:58.238Z","comments":true,"path":"2019/01/17/Avito Cool Challenge 2018 (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Avito Cool Challenge 2018 (TBC)/","excerpt":"","text":"Avito Cool Challenge 2018 A. Definite Game题目大意给一个正整数$~n~$，每次减去一个互质的数，输出最小结果。 题解水题。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; (n ^ 2 ? 1 : 2) &lt;&lt; endl;&#125; B. Farewell Party题目大意原本有一个数列$~b_1,~b_2,~\\dots,~b_n~$，先已知每个数在这个数列中有多少个其他的数与它不一样的数列$~a_1,~a_2,~\\dots,~a_n~$，输出任意合法的$~{b_n}~$。 题解如果两个数字$~x~$和$~y~$在$~{b_n}~$中出现的次数一样，则对应的$~{a_n}~$也一样于是考虑$~z~$在$~{a_n}~$中出现的次数$~cnt~$，则必有$~cnt\\mid n-z~$。直接模拟即可。 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; arr(n), cnt(n); vector&lt;stack&lt;int&gt;&gt; res(n); for (auto&amp; a : arr) cin &gt;&gt; a, ++cnt[a]; for (int i = 0, now = 1; i ^ n; ++i) &#123; if (cnt[i] % (n - i)) return cout &lt;&lt; \"Impossible\" &lt;&lt; endl, 0; for (int j = 0, tot = cnt[i] / (n - i); j ^ tot; ++j, ++now) for (int k = i; k ^ n; ++k) res[i].push(now); &#125; cout &lt;&lt; \"Possible\" &lt;&lt; endl; int last = arr.back(); arr.pop_back(); for (auto a : arr) &#123; cout &lt;&lt; res[a].top() &lt;&lt; ' '; res[a].pop(); &#125; cout &lt;&lt; res[last].top() &lt;&lt; endl;&#125; C. Colorful Bricks题目大意对连续相邻的$~n~$块砖进行$~m~$染色，使得有$~k~$块砖和左边的不一样（第一块不算），求所有染色可能数量。 题解数学推导发现答案就是$~\\binom{n-1}{k}m(m-1)^k~$。 代码1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 1 &lt;&lt; 11;int inv[maxn], fact[maxn], finv[maxn];inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline int fpow(int a, int n) &#123; int ret = 1; while (n) &#123; if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; cout &lt;&lt; mul(mul(mul(mul(fact[n - 1], finv[k]), finv[n - k - 1]), m), fpow(m - 1, k)) &lt;&lt; endl;&#125; D. Maximum Distance题目大意一个给定一个$~n~$个点$~m~$条边的联通图（可以有重边自环），有边权$~w_e~$并给定$~k~$个关键点。对于每条简单路径$~L(u,~v)~$，定义路径的花费$~cost(L(u,~v))=\\max_{e\\in L(u,~v)}{w_e}~$。定义距离$~dist(u,~v)=\\min{cost(L(u,~v))}~$。输出离每个关键点最远的关键点的距离。 题解考虑$~\\text{Kruskal}~$做法的最小生成树，那么$~dist(u,~v)~$即为$~\\text{MST}~$上两点间的路径花费。不难发现这时候关键点的最远距离都一样，为$~\\text{Kruskal}~$构造$~\\text{MST}~$过程中第一个联通所有关键点的边权。为维护关键点的连通性，在并查集的过程中不要按秩合并，而是尽量以关键点为父亲，记录合并关键点连通性的次数，到$~k-1~$次时直接输出答案即可。时间复杂度上限为$~O(n\\log n+m\\log m)~$。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int fa[maxn];int find(const int&amp; a) &#123;return fa[a] ^ a ? (fa[a] = find(fa[a])) : a;&#125;int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) fa[i] = i; vector&lt;bool&gt; vip(n + 1, false); for (int i = 0; i ^ k; ++i) &#123; int x; cin &gt;&gt; x; vip[x] = true; &#125; vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; edge(m); for (auto&amp; e : edge) cin &gt;&gt; e.second.first &gt;&gt; e.second.second &gt;&gt; e.first; sort(edge.begin(), edge.end()); int cnt = 1; for (auto e : edge) &#123; int a = find(e.second.first); int b = find(e.second.second); if (a == b) continue; if (vip[a]) fa[b] = a; else fa[a] = b; if (vip[a] &amp;&amp; vip[b]) if (++cnt == k) &#123; for (int i = 1; i ^ k; ++i) cout &lt;&lt; e.first &lt;&lt; ' '; cout &lt;&lt; e.first &lt;&lt; endl; return 0; &#125; &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"区间DP与平行四边形优化","slug":"区间DP与平行四边形优化","date":"2019-01-17T13:54:41.803Z","updated":"2019-02-14T08:59:34.931Z","comments":true,"path":"2019/01/17/区间DP与平行四边形优化/","link":"","permalink":"http://yoursite.com/2019/01/17/区间DP与平行四边形优化/","excerpt":"","text":"区间DP对于询问区间最优解的问题，可以先考虑较小区间的最优解，然后通过合并小区间得到大区间最有解。动态规划状态转移式 dp[i][j]=\\min\\{dp[i][k]+dp[k+1][j]\\}+f[i][j]算法实现过程中通常要用到三层$~\\text{for}~$循环，从外到里分别维护区间宽度$~j-i~$，区间端点$~i~$和区间分割点$~k~$，复杂度为$~O(N^3)~$。 四边形不等式如果$~\\forall~a\\leq b\\leq c\\leq d~$，$~f~$满足 f(a,~c)+f(b,~d)\\leq f(a,~d)+f(b,~c)则称$~f~$满足四边形不等式。 区间包含单调性如果$~\\forall~I_1\\subseteq I_2~$，$~f~$满足f(I_1)\\leq f(I_2)则称$~f~$满足区间包含单调性。 平行四边形优化考虑状态转移过程中的最优转移点，记$~k[i][j]~$为$~dp[i][j]~$的最优转移点，即 dp[i][j]=dp[i][k[i]][j]]+dp[k[i][j]+1][j]+f[i][j]如果$~dp~$和$~f~$都满足四边形不等式和区间包含单调性，则必有 k[i][j-1]\\leq k[i][j]\\leq k[i+1][j]那么缩小状态转移点的区间范围，在更新$~dp[i][j]~$的同时更新$~k[i][j]~$，时间复杂度可以优化至$~O(n^2)~$。区间范围和时间复杂度的证明目前没看懂，先放个百度百科的链接。反正百度到的CSDN和博客园都是抄来抄去那破尿性，更加看不懂，先凑合着用。 题目HDU3506题目大意给定一个大小为$~N~$的环，每次合并相邻区间$~A~$和$~B~$的花费是$~(\\sum A+\\sum B)*(|A|+|B|)~$，求将这个环合并为一个集合的最小总花费。 题解动态规划，记$~dp[i][j]~$为将$~i,~\\dots,~j~$合并的最小花费。注意到这题是环形数组，则可以将数组扩大一倍，令$~a[n+i]=a[i],~i=1,~2,~\\dots,~n-1~$，同时用平行四边形优化。时间复杂度$~O(N^2)~$。 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 11;int dp[maxn][maxn], s[maxn][maxn], pre[maxn];int main() &#123; int n; while (cin &gt;&gt; n) &#123; memset(dp, 0x3f, sizeof (dp)); for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; pre[i], pre[i + n] = pre[i]; for (int i = 1; i ^ n &lt;&lt; 1; ++i) pre[i] += pre[i - 1], dp[i][i] = 0, s[i][i] = i; for (int len = 1; len ^ n; ++len) for (int i = 1; i + len ^ n &lt;&lt; 1; ++i) &#123; int j = i + len; for (int k = s[i][j - 1]; k &lt;= s[i + 1][j]; ++k) if (dp[i][j] &gt; dp[i][k] + dp[k + 1][j] + pre[j] - pre[i - 1]) &#123; s[i][j] = k; dp[i][j] = dp[i][k] + dp[k + 1][j] + pre[j] - pre[i - 1]; &#125; &#125; int res = 0x3f3f3f3f; for (int i = 1; i &lt;= n; ++i) res = min(res, dp[i][i + n - 1]); cout &lt;&lt; res &lt;&lt; endl; &#125;&#125; HDU4632题目大意给定一个字符串，求出所有的回文子序列个数模$~10007~$的答案，时间复杂度要求在$~O(n^2)~$以内。 题解动态规划，记$~dp[i][j]~$为区间$~[i,~j]~$内的回文子序列个数。则根据容斥原理，有状态转移式 dp[i][j]=\\begin{cases} dp[i][j-1]+dp[i+1][j]-dp[i+1][j] &str[i]\\not=str[j] \\\\ dp[i][j-1]+dp[i+1][j]+1 &str[i]=str[j] \\end{cases}代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 10007;const int maxn = 1 &lt;&lt; 10;int dp[maxn][maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;int main() &#123; for (int i = 0; i ^ maxn; ++i) dp[i][i] = 1; int t; cin &gt;&gt; t; for (int cas = 1; cas &lt;= t; ++cas) &#123; string str; cin &gt;&gt; str; int size = (int)str.size(); for (int i = 1; i ^ size; ++i) &#123; if (str[i - 1] ^ str[i]) dp[i - 1][i] = 2; else dp[i - 1][i] = 3; &#125; for (int len = 2; len &lt; size; ++len) for (int i = 0; i + len ^ size; ++i) &#123; int j = i + len; dp[i][j] = add(dp[i + 1][j], dp[i][j - 1]); if (str[i] ^ str[j]) dp[i][j] = sub(dp[i][j], dp[i + 1][j - 1]); else dp[i][j] = add(dp[i][j], 1); &#125; cout &lt;&lt; \"Case \" &lt;&lt; cas &lt;&lt; \": \" &lt;&lt; dp[0][size - 1] &lt;&lt; endl; &#125;&#125; HDU4745题目大意给一个大小为$~N~$的环形数组，要求分别顺时针逆时针一圈以内各选一个子序列，使得子序列一样，求最大的子序列长度。 题解其实差不多就是求最大的回文子序列长度，注意细节，具体看代码。 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 11;int dp[maxn][maxn], a[maxn];int main() &#123; for (int i = 0; i ^ maxn; ++i) dp[i][i] = 1; int n; while (true) &#123; cin &gt;&gt; n; if (!n) break; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i], a[n + i] = a[i]; for (int len = 1; len ^ n; ++len) for (int i = 1; i + len &lt;= n &lt;&lt; 1; ++i) &#123; int j = i + len; if (a[i] == a[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); &#125; int res = 0; for (int i = 1; i &lt;= n; ++i) res = max(res, max(dp[i][i + n - 1], dp[i][i + n - 2] + 1)); cout &lt;&lt; res &lt;&lt; endl; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"区间DP","slug":"区间DP","permalink":"http://yoursite.com/tags/区间DP/"}]},{"title":"斜率优化DP","slug":"斜率优化DP","date":"2019-01-17T13:54:41.798Z","updated":"2019-02-14T09:00:07.811Z","comments":true,"path":"2019/01/17/斜率优化DP/","link":"","permalink":"http://yoursite.com/2019/01/17/斜率优化DP/","excerpt":"","text":"斜率优化DP思想对于状态转移公式满足如下条件的动态规划 dp[i]=\\min_{j","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"斜率DP","slug":"斜率DP","permalink":"http://yoursite.com/tags/斜率DP/"}]},{"title":"队列优化DP","slug":"队列优化DP","date":"2019-01-17T13:54:38.281Z","updated":"2019-02-14T08:59:17.037Z","comments":true,"path":"2019/01/17/队列优化DP/","link":"","permalink":"http://yoursite.com/2019/01/17/队列优化DP/","excerpt":"","text":"队列优化DP思想对于状态转移公式满足如下条件的动态规划 dp[i]=(\\min\\text{or}\\max)\\{f[j]\\}+g[i],~j\\in[\\alpha[i],\\beta[i]]其中$~f~$和$~g~$均可线性时间内求出，且$\\alpha~$和$~\\beta~$单调递增。朴素的做法是直接暴力循环计算状态转移，时间复杂度为$~O(n^2)~$。但是注意到区间$~[\\alpha,~\\beta]~$的单调递增性质，可以用一个叫做单调队列的数据结构来维护区间的最值。 单调队列的性质 可以用双端队列或者双指针数组实现，内部的任意元素$~que[i]~$表示$~f~$的角标。 角标有序储存，即$~que[i]&lt;que[j],~\\forall~i&lt;j~$。 角标对应的数组值单调，即$~f[que[i]]~$单调递增或者单调递减。 单调队列的操作（单调递减队列维护区间最大值） 每次更新区间时，从小到大考虑新加入的角标$~now~$，将所有队列$~que~$中满足$~que[cmp]&lt;que[now]~$的元素$~cmp~$从队列$~que~$中移除。由于单调队列的性质，只需要让$~now~$与队列$~que~$的尾部元素$~last~$比较即可。 将$~now~$放入队列$~que~$尾部，经过上一个操作，单调队列性质依然保持。 将队列$~que~$头部所有不在区间$~[\\alpha,~\\beta]~$的元素$~head~$从队列$~que~$中移除。由于区间$~[\\alpha,~\\beta]~$的单调递增性质，单调队列性质依然保持，且此时$~\\max{f[i]}=f[que[head]]~$。 复杂度计算每个角标$~i~$至多被放入队列$~que~$或者从队列$~que~$中移除一次，所以是线性复杂度$~O(n)~$。 题目HDU3401题目大意炒股，一共$~T~$天，第$~i~$天股票的买价是$~ap[i]~$、最多可以买$~as[i]~$股，卖价是$~bp[i]~$、最多可以卖$~bs[i]~$股，且每两次交易之间相隔必须大于$~W~$天，最大屯股量为$~maxp~$，问最后的最大收益。 题解动态规划，记$~dp[i][j]~$表示在第$~i~$天还剩下$~j~$股的最大收益，则有$~3~$种状态更新 dp[i][j]=\\max\\begin{cases} dp[i-1][j] &\\text{null} \\\\ dp[i-w-1][j-k]-ap[i]*k &\\text{$k\\leq\\min(j,~as[i])$} \\\\ dp[i-w-1][j+k]+bp[i]*k &\\text{$k\\leq\\min(maxp-j~,bs[i])$} \\\\ \\end{cases}这样的时间复杂度为$~O(T\\cdot maxp^2)~$，显然会$~\\text{TLE}~$。但观察$~dp[i][j]~$的第二种状态更新，有 \\begin{aligned} dp[i][j] &=\\max\\alpha[l]-ap[i]*j \\\\ \\alpha[l] &=dp[i-w-1][l]+ap[i]*[l] \\\\ l &\\in[\\max(0,~j-as[i]),~j] \\\\ \\end{aligned}第三种状态更新同理 \\begin{aligned} dp[i][j] &=\\max\\beta[l]-bp[i]*j \\\\ \\beta[l] &=dp[i-w-1][l]+bp[i]*[l] \\\\ l &\\in[j,~\\min(maxp,~j+bs[i])] \\\\ \\end{aligned}于是可以用单调队列来维护$~\\max(\\alpha,\\beta)~$。这样对于每个$~dp[i][j]~$状态转移的平均复杂度为$~O(1)~$，总时间复杂度为$~O(T\\cdot maxp)~$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1 &lt;&lt; 11;int ap[maxn], bp[maxn], as[maxn], bs[maxn], temp[maxn], dp[maxn &lt;&lt; 1][maxn];int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int n, maxp, w; cin &gt;&gt; n &gt;&gt; maxp &gt;&gt; w; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; ap[i] &gt;&gt; bp[i] &gt;&gt; as[i] &gt;&gt; bs[i]; for (int i = 0; i &lt;= w; ++i) &#123; dp[i][0] = 0; for (int j = 1; j &lt;= maxp; ++j) dp[i][j] = -inf; &#125; deque&lt;int&gt; que; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= maxp; ++j) dp[i + w][j] = dp[i + w - 1][j]; que.clear(); for (int j = 0; j &lt;= maxp; ++j) &#123; temp[j] = dp[i - 1][j] + ap[i] * j; while (!que.empty() &amp;&amp; temp[que.back()] &lt; temp[j]) que.pop_back(); que.push_back(j); while (que.front() &lt; j - as[i]) que.pop_front(); dp[i + w][j] = max(dp[i + w][j], temp[que.front()] - ap[i] * j); &#125; que.clear(); for (int j = 0; j &lt;= maxp; ++j) temp[j] = dp[i - 1][j] + bp[i] * j; for (int j = 0; j ^ bs[i]; ++j) &#123; while (!que.empty() &amp;&amp; temp[que.back()] &lt; temp[j]) que.pop_back(); que.push_back(j); &#125; for (int j = 0; j &lt;= maxp; ++j) &#123; if (j + bs[i] &lt;= maxp) &#123; while (!que.empty() &amp;&amp; temp[que.back()] &lt; temp[j + bs[i]]) que.pop_back(); que.push_back(j + bs[i]); &#125; while (que.front() &lt; j) que.pop_front(); dp[i + w][j] = max(dp[i + w][j], temp[que.front()] - bp[i] * j); &#125; &#125; cout &lt;&lt; dp[n + w][0] &lt;&lt; endl; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"队列DP","slug":"队列DP","permalink":"http://yoursite.com/tags/队列DP/"}]},{"title":"Good Bye 2018 (TBC)","slug":"Good Bye 2018 (TBC)","date":"2019-01-17T12:54:33.346Z","updated":"2019-01-17T14:08:29.227Z","comments":true,"path":"2019/01/17/Good Bye 2018 (TBC)/","link":"","permalink":"http://yoursite.com/2019/01/17/Good Bye 2018 (TBC)/","excerpt":"","text":"Good Bye 2018 A. New Year and the Christmas Ornament题目大意给$~3~$个数$~y,~b,~r~$，求最大的$~sum=a+(a+1)+(a+2)~$，满足$~a\\leq y,~a+1\\leq b,~a+2\\leq r$。 题解水题。 代码12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; 3 * min(a + 1, min(b, c - 1)) &lt;&lt; endl;&#125; B. New Year and the Treasure Geolocation题目大意给定$~n~$个坐标和$~n~$个向量，存在一种坐标和向量一一配对的方式，使得$~n~$个坐标为起点经向量所指向的终点一样，输出这个终点。 题解平均坐标即是答案，注意数据范围会爆$~\\text{int}~$。 代码1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; long long x = 0, y = 0, a, b; for (int i = 0; i ^ n &lt;&lt; 1; ++i) &#123; cin &gt;&gt; a &gt;&gt; b; x += a; y += b; &#125; cout &lt;&lt; x / n &lt;&lt; ' ' &lt;&lt; y / n &lt;&lt; endl;&#125; C. New Year and the Sphere Transmission题目大意数字$~1,~2,~\\dots,~n~$逆时针排成一圈，起点在$~1~$。逆时针每$~k~$个数取一个，直到恰好回到$~1~$处，所有取的数得到一个总和$~sum(k)~$。将所有可能的$~sum(k)~$从小到达输出。 题解不难发现每$~k~$个数去一个与每$~\\gcd(k,~n)~$个数去一个所得到的总和一样。那么只考虑$~k\\mid n~$的情况。此时 sum(k)=\\sum_{i=0}^{\\frac{n}{k}-1}ik+1=\\frac{1}{2}\\left(\\frac{n(n+2)}{k}-n\\right)枚举$~n~$的因子$~k~$即可，时间复杂度为$~O(\\sqrt{n})~$。对于有序输出答案以及去重，由于数据范围不大，可以用$~\\text{set}~$维护，时间复杂度为$~O(\\sqrt{n}\\log n)~$。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; long long n; cin &gt;&gt; n; set&lt;long long&gt; res; int sqr = sqrt(n + 1); for (int i = 1; i &lt;= sqr; ++i) if (!(n % i)) &#123; res.insert((n + 2) * i - n &gt;&gt; 1); res.insert((n + 2) * n / i - n &gt;&gt; 1); &#125; cout &lt;&lt; 1; res.erase(res.find(1)); for (auto out : res) cout &lt;&lt; ' ' &lt;&lt; out; cout &lt;&lt; endl;&#125; D. New Year and the Permutation Concatenation题目大意序列$~p~$由$~1,~2,~\\dots,~n~$的所有全排列按字典序连在一起，长度为$~n\\cdot n!~$。输出$~p~$中有多少长度为$~n~$的连续子序列满足总和为$~\\frac{n(n+1)}{2}~$。 题解首先每一个原生的全排列一定满足总和为$~\\frac{n(n+1)}{2}~$。接下来不难发现所有符合条件的长度为$~n~$的连续子序列也必定是一个全排，于是答案变成了$~p~$中有多少个全排列。对于非原生的全排列，它必定由一个原生全排列的后缀接上下一个原生全排列的前缀。再注意到原生全排列按字典序排列，于是一对原生全排列要通过前面的后缀加后面的前缀生成新的全排列，必须满足两者的前缀一样。于是对于公共前缀长度不小于$~k~$的相邻原生全排列对，均可通过取前者长度为$~n-k~$的后缀和后者长度为$~k~$的前缀，构造出新的全排列，共计$~\\frac{n!}{(n-k)!}((n-k)!-1)~$个。枚举$~1\\leq k\\leq n-2~$，答案为 n!+\\sum_{k=1}^{n-2}\\frac{n!}{(n-k)!}((n-k)!-1)=n!(n-\\sum_{i=1}^{n-1}\\frac{1}{k!})代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 1 &lt;&lt; 20;int inv[maxn], fact[maxn], finv[maxn];inline int sub(const int&amp; a, const int&amp; b) &#123;return a &lt; b ? a - b + mod : a - b;&#125;inline int add(const int&amp; a, const int&amp; b) &#123;return sub(a, mod - b);&#125;inline int mul(const int&amp; a, const int&amp; b) &#123;return 1LL * a * b % mod;&#125;inline void init() &#123; inv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1; for (int i = 2; i ^ maxn; ++i) &#123; inv[i] = mul(inv[mod % i], mod - mod / i); fact[i] = mul(fact[i - 1], i); finv[i] = mul(finv[i - 1], inv[i]); &#125;&#125;int main() &#123; init(); int n; cin &gt;&gt; n; int res = 0; for (int i = 1; i ^ n; ++i) res = add(res, finv[i]); cout &lt;&lt; mul(fact[n], sub(n, res)) &lt;&lt; endl;&#125; E. New Year and the Acquaintance Estimation题目大意给定$~n~$个点的度数，问是否可以加一个新的度数，使得这$~n+1~$个点能构成一个简单无向图。将所有可能的度数升序输出。 题解题目里已经给出了相关理论的$~\\text{wiki}~$链接。根据$~\\text{Erdo2s-Gallai}~$定理，以$~d_1\\geq d_2\\geq\\dots\\geq d_n~$为度数可以构成简单图的充要条件是$~2\\mid\\sum_{i=1}^{n}d_i~$，且 \\sum_{i=1}^{k}d_i\\leq k(k-1)+\\sum_{i=k+1}^{n}\\min(d_i,~k),~\\forall~1\\leq k\\leq n将$~d~$改为升序，用$~n-k~$代替$~k~$，则不等式变为 \\sum_{i=k+1}^{n}d_i\\leq (n-k)(n-k-1)+\\sum_{i=1}^{k}\\min(d_i,~n-k),~\\forall~0\\leq k< n不难发现答案必为连续的一段且奇偶性相同。先不考虑奇偶性，如果新加的度数$~deg~$不合法，则考虑上式不成立时$~deg~$在上式的左边还是右边。如果在左边，说明$~deg~$过大，反之如果在右边，则$~deg~$过小。左右都出现的话则说明无解。二分$~deg~$即可。时间复杂度$~O(n\\log n)~$或$~O(n\\log^2n)~$均可接受。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1 &lt;&lt; 19;long long vec[maxn], deg[maxn], pre[maxn];int size;inline int cal(const long long&amp; rem) &#123; memcpy(deg, vec, size * sizeof (long long)); deg[size - 1] = rem; for (int i = size - 1; i &amp;&amp; deg[i - 1] &gt; deg[i]; --i) swap(deg[i - 1], deg[i]); int pos1 = lower_bound(deg, deg + size, rem) - deg; int pos2 = upper_bound(deg, deg + size, rem) - deg; for (int i = 0; i ^ size; ++i) pre[i + 1] = pre[i] + deg[i]; int pos = 0; bool flag1 = false, flag2 = false; for (int k = size - 1; ~k; --k) &#123; while (pos ^ size &amp;&amp; deg[pos] &lt; size - k) ++pos; if (pre[size] - pre[k] &gt; (size - k) * (size - min(k, pos) - 1LL) + pre[min(k, pos)]) &#123; flag1 |= k &gt; pos1; flag2 |= k &lt; pos2; &#125; &#125; if (flag1 &amp;&amp; flag2) exit((cout &lt;&lt; -1 &lt;&lt; endl, 0) ); return flag1 ? -1 : flag2;&#125;int main() &#123; int n; cin &gt;&gt; n; size = n + 1; int parity = 0; for (int i = 0; i ^ n; ++i) cin &gt;&gt; vec[i], parity ^= vec[i] &amp; 1; sort(vec, vec + n); int left, right; if (!cal(0)) &#123; left = 0; &#125; else &#123; int l = 0, r = n; while (r - l ^ 1) &#123; int mid = l + r &gt;&gt; 1; if (~cal(mid)) r = mid; else l = mid; &#125; left = r; &#125; if (!cal(n)) &#123; right = n; &#125; else &#123; int l = left, r = n; while (r - l ^ 1) &#123; int mid = l + r &gt;&gt; 1; if (cal(mid) ^ 1) l = mid; else r = mid; &#125; right = l; &#125; cout &lt;&lt; (left &amp; 1 ^ parity ? left + 1 : left); for (int i = left + 2; i &lt;= right; ++i) if (!(i &amp; 1 ^ parity)) cout &lt;&lt; ' ' &lt;&lt; i; cout &lt;&lt; endl; return 0;&#125; F. New Year and the Mallard Expedition题目大意有$~3~$种地形和行动方式，分别是草地、水、火山和走、游泳、飞，行动的耗时分别为$~1~$米$~5~$秒、$~1~$米$~3~$秒、$~1~$米$~1~$秒。可以反向行动且随时可以无花费地切换行动方式。走和游泳分别只能在草地和水上使用，飞行可以在任何地形使用，但是飞行需要能量。能量一开始为$~0~$，每走或者游$~x~$米均可获得$~x~$能量，每飞$~x~$米则会消耗$~x~$能量。全路程共计$~n~$段，给出的地形和长度，问最短耗时。 题解现根据各种地形对应的行动方式模拟一遍，算出答案的上界并记录到每一段时能量还剩余多少（有可能需要为了补充能量需而原地打转）。然后从终点向起点模拟，在保证每处剩余能量非负的情况下，先尽量在草地上飞，如果还有能量剩余则在水上飞。需要注意细节。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;long long&gt; len(n + 1, 0), rem(n + 1, 0); for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; len[i]; string str; cin &gt;&gt; str; str = 'A' + str; long long res = 0; bool flag = false; for (int i = 1; i &lt;= n; ++i) &#123; if (str[i] ^ 'L') &#123; rem[i] = rem[i - 1] + len[i]; flag |= str[i] == 'W'; res += len[i] * (str[i] == 'W' ? 3 : 5); &#125; else &#123; if (rem[i - 1] &lt; len[i]) &#123; rem[i] = 0; res += (len[i] - rem[i - 1]) * (flag ? 4 : 6) + rem[i - 1]; &#125; else &#123; rem[i] = rem[i - 1] - len[i]; res += len[i]; &#125; &#125; &#125; long long cnt = 0, minn = 0x3f3f3f3f3f3f3f3f; for (int i = n; i; --i) &#123; minn = min(minn, rem[i]); if (str[i] == 'G') &#123; auto sub = min(minn, len[i] &lt;&lt; 1); res -= sub &lt;&lt; 1; minn -= sub; cnt += sub; &#125; &#125; cout &lt;&lt; res + cnt - rem[n] &lt;&lt; endl;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/categories/Codeforces/"}],"tags":[]},{"title":"线性基","slug":"线性基","date":"2019-01-17T07:46:42.873Z","updated":"2019-05-10T05:02:15.369Z","comments":true,"path":"2019/01/17/线性基/","link":"","permalink":"http://yoursite.com/2019/01/17/线性基/","excerpt":"","text":"线性基问题对于非负整数区间$~[0,2^n)~$，可以按二进制$~01~$表示映射到域$~\\Bbb{Z}_2~$上的$~n~$维向量空间$~\\Bbb{Z}_2^n~$。记上述的映射为$~f:[0,~2^n)\\to\\Bbb{Z}_2^n,~x\\mapsto v~$，这里$~v~$是$~x~$在二进制下的$~01~$表示，显然$~f~$是双射。之后的内容中，对于向量$~v\\in\\Bbb{Z}_2^n~$，都用$~f^{-1}(v)\\in[0,2^n)~$来表示。那么对于若干整数的$~\\text{xor}~$运算问题，则转化为向量空间$~\\Bbb{Z}_2^n~$上的加法运算问题，通常称为线性基问题。 线性基向量空间$~\\Bbb{Z}_2^n~$上任意$~n~$个线性无关的向量，称作该向量空间上的一组线性基。显然$~1,2,4,\\dots,2^{n-1}~$是$~\\Bbb{Z}_2^n~$的一组线性基，称作标准线性基。且向量空间$~\\Bbb{Z}_2^n~$的任意一个子空间$~V~$必同构于向量空间$~\\Bbb{Z}_2^m,~0\\leq m\\leq n~$，于是$~{\\mid V\\mid}=2^m~$。 最小生成子空间对于向量空间$~\\Bbb{Z}_2^n~$的一个子集$~A=\\lbrace~a_1,a_2,\\dots,a_m~\\rbrace~$，子空间$~V~$称作$~A~$在$~\\Bbb{Z}_2^n~$上的最小生成子空间，当且仅当$~A\\subseteq V\\subseteq~\\Bbb{Z}_2^n~$，且对于$~\\Bbb{Z}_2^n~$的所有子空间$~W~$满足：如果$~A\\subseteq W~$，则必有$~V\\subseteq W~$。如果$~a_1,~a_2,~\\dots,~a_m~$线性无关，则它们构成$~V~$的一组线性基。于是有推论：对于$~A~$的最小生成子空间$~V~$，满足$~\\dim V\\leq{\\mid A\\mid}~$。 空间的扩张对于向量空间$~\\Bbb{Z}_2^n~$的子空间$~V~$和向量$~a~$，定义$~V(a)=\\lbrace~a+b:~b\\in V\\rbrace\\cup V~$。显然$~V(a)~$是包含$~V~$和$~a~$的最小空间，称$~V(a)~$是$~V~$的扩张。如果$~a\\in V~$，则显然$~V(a)=V~$，称作平凡扩张；否则称作不平凡扩张，且$~\\dim V(a)=\\dim V+1~$。对于不平凡扩张，设$~b_1,~b_2,~\\dots,~b_{\\dim V}~$是$~V~$的一组线性基，因为$~a\\notin V~$，$~a~$无法被$~b_1,~b_2,~\\dots,~b_{\\dim V}~$线性表出，所以$~b_1,~b_2,~\\dots,~b_{\\dim V},~a~$线性无关，它们是$~V(a)~$的一组线性基。 代码实现存储对于任意线性无关组，显然它的最小生成子空间是唯一的。所以可以用$~\\text{vector}~$来储存这个线性无关组来表示一个线性空间。 123456struct Vec &#123; vector&lt;uint64_t&gt; base; Vec() &#123;&#125; void clear() &#123; base.clear(); &#125; size_t size() const &#123; return base.size(); &#125;&#125;; 扩张自行理解。 1234567891011bool add(uint64_t e) &#123; for (const auto&amp; v : base) e = std::min(e, e ^ v); if (e) base.emplace_back(e); return e;&#125;void join(const Vec&amp; vec) &#123; for (const auto&amp; v : vec.base) add(v); &#125;Vec operator + (const Vec&amp; vec) const &#123; Vec ret = *this; ret.join(vec); return ret;&#125; 最值最小值为非$~0~$最小值，其余自行理解。 123456uint64_t min() &#123; return *min_element(base.begin(), base.end()); &#125;uint64_t max() &#123; uint64_t ret = 0; for (const auto&amp; v : base) ret = std::max(ret, ret ^ v); return ret;&#125; 标准化自行理解。 12345void sort() &#123; std::sort(base.begin(), base.end()); for (size_t i = 1; i != base.size(); ++i) for (size_t j = i - 1; ~j; --j) base[i] = std::min(base[i], base[i] ^ base[j]);&#125; 有序查找从$~0~$开始，需要标准化，其余自行理解。 123456uint64_t find_by_rank(const uint64_t&amp; k) &#123; uint64_t ret = 0; for (size_t i = 0; i != base.size(); ++i) if (k &amp; uint64_t(1) &lt;&lt; uint64_t(i)) ret ^= base[i]; return ret;&#125; 模板12345678910111213141516171819202122232425262728293031323334struct Vec &#123; vector&lt;uint64_t&gt; base; Vec() &#123;&#125; void clear() &#123; base.clear(); &#125; size_t size() const &#123; return base.size(); &#125; bool add(uint64_t e) &#123; for (const auto&amp; v : base) e = std::min(e, e ^ v); if (e) base.emplace_back(e); return e; &#125; void join(const Vec&amp; vec) &#123; for (const auto&amp; v : vec.base) add(v); &#125; Vec operator + (const Vec&amp; vec) const &#123; Vec ret = *this; ret.join(vec); return ret; &#125; uint64_t min() &#123; return *min_element(base.begin(), base.end()); &#125; uint64_t max() &#123; uint64_t ret = 0; for (const auto&amp; v : base) ret = std::max(ret, ret ^ v); return ret; &#125; void sort() &#123; std::sort(base.begin(), base.end()); for (size_t i = 1; i != base.size(); ++i) for (size_t j = i - 1; ~j; --j) base[i] = std::min(base[i], base[i] ^ base[j]); &#125; uint64_t find_by_rank(const uint64_t&amp; k) &#123; uint64_t ret = 0; for (size_t i = 0; i != base.size(); ++i) if (k &amp; uint64_t(1) &lt;&lt; uint64_t(i)) ret ^= base[i]; return ret; &#125;&#125;; 题目CF1101G代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const size_t maxn = 1 &lt;&lt; 19;uint64_t c[maxn];pair&lt;size_t, size_t&gt; seg[maxn];struct Vec &#123; vector&lt;uint64_t&gt; base; Vec() &#123;&#125; void clear() &#123; base.clear(); &#125; bool add(uint64_t e) &#123; for (const auto&amp; v : base) e = std::min(e, e ^ v); if (e) base.emplace_back(e); return e; &#125; void join(const Vec&amp; vec) &#123; for (const auto&amp; v : vec.base) add(v); &#125; Vec operator + (const Vec&amp; vec) const &#123; Vec ret = *this; ret.join(vec); return ret; &#125; uint64_t max() &#123; uint64_t ret = 0; for (const auto&amp; v : base) ret = std::max(ret, ret ^ v); return ret; &#125;&#125; res[maxn], vec[maxn], tmp;void cdq(auto&amp; que, const size_t&amp; l, const size_t&amp; r) &#123; if (l == r) &#123; for (const auto&amp; i : que) res[i].add(c[l]); return; &#125; size_t m = (l + r) &gt;&gt; 1; tmp.clear(); for (size_t i = m; i &gt;= l; --i) &#123; tmp.add(c[i]); vec[i] = tmp; &#125; tmp.clear(); for (size_t i = m + 1; i &lt;= r; ++i) &#123; tmp.add(c[i]); vec[i] = tmp; &#125; vector&lt;size_t&gt; left, right; for (const auto&amp; i : que) &#123; if (seg[i].second &lt;= m) left.emplace_back(i); else if (seg[i].first &gt; m) right.emplace_back(i); else res[i] = vec[seg[i].first] + vec[seg[i].second]; &#125; que.clear(); cdq(left, l, m); cdq(right, m + 1, r);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); size_t n; cin &gt;&gt; n; for (size_t i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; size_t q; cin &gt;&gt; q; vector&lt;size_t&gt; que(q); iota(que.begin(), que.end(), 0); for (size_t i = 0; i != q; ++i) cin &gt;&gt; seg[i].first &gt;&gt; seg[i].second; cdq(que, 1, n); for (size_t i = 0; i != q; ++i) cout &lt;&lt; res[i].max() &lt;&lt; '\\n';&#125; CF1100F代码;12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), base; cin &gt;&gt; a.front(); for (int i = 1; i ^ n; ++i) cin &gt;&gt; a[i], a[i] ^= a[i - 1]; if (!a.back()) return cout &lt;&lt; -1 &lt;&lt; endl, 0; for (auto e : a) &#123; for (auto v : base) e = min(e, e ^ v); if (e) base.push_back(e); &#125; cout &lt;&lt; base.size() &lt;&lt; endl;&#125; HDU3949代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;struct Vec &#123; vector&lt;uint64_t&gt; base; Vec() &#123;&#125; size_t size() const &#123; return base.size(); &#125; bool add(uint64_t e) &#123; for (const auto&amp; v : base) e = std::min(e, e ^ v); if (e) base.emplace_back(e); return e; &#125; void sort() &#123; std::sort(base.begin(), base.end()); for (size_t i = 1; i != base.size(); ++i) for (size_t j = i - 1; ~j; --j) base[i] = std::min(base[i], base[i] ^ base[j]); &#125; uint64_t find_by_rank(const uint64_t&amp; k) &#123; uint64_t ret = 0; for (size_t i = 0; i != base.size(); ++i) if (k &amp; uint64_t(1) &lt;&lt; uint64_t(i)) ret ^= base[i]; return ret; &#125;&#125;;int main() &#123; size_t t; cin &gt;&gt; t; for (size_t cas = 1; cas &lt;= t; ++cas) &#123; size_t n; cin &gt;&gt; n; Vec vec; for (size_t i = 0; i != n; ++i) &#123; uint64_t a; cin &gt;&gt; a; vec.add(a); &#125; size_t q; cin &gt;&gt; q; vec.sort(); uint64_t flag = (n == vec.size()) - 1; cout &lt;&lt; \"Case #\" &lt;&lt; cas &lt;&lt; \":\\n\"; while (q--) &#123; uint64_t k; cin &gt;&gt; k; if ((k + flag) &amp; ~((uint64_t(1) &lt;&lt; uint64_t(vec.size())) - uint64_t(1))) cout &lt;&lt; \"-1\\n\"; else cout &lt;&lt; vec.find_by_rank(k + flag) &lt;&lt; '\\n'; &#125; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"线性基","slug":"线性基","permalink":"http://yoursite.com/tags/线性基/"}]}]}